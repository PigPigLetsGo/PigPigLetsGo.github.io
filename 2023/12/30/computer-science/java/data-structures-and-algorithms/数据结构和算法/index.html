



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Dkx の Java小窝" href="https://pigpigletsgo.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Dkx の Java小窝" href="https://pigpigletsgo.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Dkx の Java小窝" href="https://pigpigletsgo.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="https://pigpigletsgo.github.io/2023/12/30/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">



  <title>
数据结构与算法 - Java - 数据结构与算法 |
Dou的个人博客 = Dkx の Java 小窝 = 别怕路长梦远</title>
<meta name="generator" content="Hexo 7.0.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">数据结构与算法
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-12-30 16:04:38">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-12-30T16:04:38+08:00">2023-12-30</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>253k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>3:50</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Dou的个人博客</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/6c7f469735b99a6a04773240429dc7e0.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/5651daf17bf5de77514e658264d7cccc.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a8d0ac76b87f7593653e29559d61b32d.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/666b3077b407f3c0ce9c10c00b861abe.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a8d0ac76b87f7593653e29559d61b32d.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/6c7f469735b99a6a04773240429dc7e0.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/data-structures-and-algorithms/" itemprop="item" rel="index" title="分类于 数据结构与算法"><span itemprop="name">数据结构与算法</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/data-structures-and-algorithms/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://pigpigletsgo.github.io/2023/12/30/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Dkx">
    <meta itemprop="description" content="别怕路长梦远, 欢迎来我的博客空间">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Dkx の Java 小窝">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="toc"><a class="markdownIt-Anchor" href="#toc">#</a> [toc]</h2>
<h2 id="数据结构和算法的重要性"><a class="markdownIt-Anchor" href="#数据结构和算法的重要性">#</a> 数据结构和算法的重要性🎄</h2>
<blockquote>
<ol>
<li><mark>算法是程序的灵魂</mark>，优秀的程序可以在海量数据计算时，依然保持高速计算</li>
<li>一般来讲，程序会使用了内存计算框架 (比如 Spark) 和缓存技术 (比如 Redis 等) 来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核心功能是哪个部分呢？</li>
<li>拿实际工作经历来说，在 Unix 下开发服务器程序，功能是要支持上千万人同时在线，在上线前，做内测，一切 OK 后，可上线后，服务器就支撑不住了，公司的 CTO 对代码进行优化，再次上线，坚如磐石，你就能感受到程序是有灵魂的，就是算法。</li>
<li>目前程序员面试的门槛越来越高，<mark>很多一线 IT 公司 (大厂)</mark>，<mark>都会有数据结构和算法面试题</mark> (负责的告诉你，肯定有的)</li>
<li><font style="color:red">如果你不想永远都是代码工人，那就花时间来研究下数据结构和算法</font>。</li>
</ol>
</blockquote>
<h2 id="数据结构和算法的概述"><a class="markdownIt-Anchor" href="#数据结构和算法的概述">#</a> 数据结构和算法的概述</h2>
<p><strong>数据结构和算法的关系</strong>。</p>
<ul>
<li><mark>数据 (Data) 结构 (Structure)<mark> 是一门研究组织</mark>数据</mark>方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮，更加有效率的代码。</li>
<li>要学好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决。</li>
<li>程序 = <mark>数据结构</mark> + 算法</li>
<li><mark>数据结构</mark>是<mark>算法的基础</mark>，换言之，想要<mark>学好算法</mark>，需要把<mark>数据结构学到位</mark>。</li>
<li>思维概括：学数据结构和算法只是打个基础，并不是学会了就能写出好的程序，比方说你会数组那么就会归并算法了吗？并不会所以什么东西都是需要学的不会的就学。在学会一个算法的基础上去营造一个新的算法就是进步</li>
</ul>
<p><strong>数据结构和算法的联系</strong>：</p>
<ul>
<li>简单的一些问题就用数据结构</li>
<li>比较复杂的问题就实用数据结构 + 算法</li>
</ul>
<ol>
<li>修路问题 =&gt; 最小生成树 (加权值)[数据结构] + 普利姆算法</li>
<li>最短路径问题 =&gt; 图 + 费罗伊德算法</li>
<li>汉若塔 =&gt; 分支算法</li>
<li>八皇后问题 =&gt; 回溯法</li>
</ol>
<h2 id="线性结构和非线性结构"><a class="markdownIt-Anchor" href="#线性结构和非线性结构">#</a> 线性结构和非线性结构</h2>
<h3 id="线性结构"><a class="markdownIt-Anchor" href="#线性结构">#</a> 线性结构</h3>
<ol>
<li>线性结构作为最常用的数据结构，其特点是<mark>数据元素之间存在一对一的线性关系</mark>。</li>
<li>线性结构有两种不同的存储结构，即<mark>顺序存储结构 (<strong>数组</strong>)<mark> 和</mark>链式存储结构 (<strong>链表</strong>)</mark>。顺序存储的线性表称为顺序表，顺序表中的<mark>存储元素 (地址) 是连续</mark>的。</li>
<li>链式存储的线性表称为链表，链表中的<mark>存储元素不一定是连续</mark>的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>线性结构常见的有：<mark>数组，队列，链表和栈</mark>。</li>
</ol>
<h3 id="非线性结构"><a class="markdownIt-Anchor" href="#非线性结构">#</a> 非线性结构</h3>
<p>非线性结构，数学用语，其<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODAlQkIlRTglQkUlOTEvNTQz">逻辑</span>特征是一个结点元素可能有多个直接前驱和多个直接后继。</p>
<p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>
<h1 id="数据结构和算法"><a class="markdownIt-Anchor" href="#数据结构和算法">#</a> 数据结构和算法</h1>
<h2 id="稀疏数组和队列"><a class="markdownIt-Anchor" href="#稀疏数组和队列">#</a> 稀疏数组和队列</h2>
<h3 id="稀疏sparsearray数组"><a class="markdownIt-Anchor" href="#稀疏sparsearray数组">#</a> 稀疏 sparsearray 数组</h3>
<p><strong>先看一个实际的需求</strong> 。</p>
<blockquote>
<p>编写的五子棋程序中，有<mark>存盘退出</mark>和<mark>续上盘</mark>的功能。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855953.png" alt="1"></p>
<p><strong>分析问题</strong>：</p>
<p>因为该二维数组的很多值是默认值 0，因此记录了<mark>很多没有意义的数据</mark> -&gt; 使用<mark>稀疏数组</mark>对二维数组进行压缩。</p>
<p><strong>基本介绍</strong>。</p>
<p>当一个数组中大部分元素为 0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p><strong>稀疏数组的处理方法是</strong>：</p>
<ol>
<li>记录数组<mark>一共有几行几列，有多少个不同</mark>的值。</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<mark>缩小程序</mark>的规模。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855598.png" alt=""></p>
<p>二维数组 转 稀疏数组的思路：</p>
<ol>
<li>遍历 原始的二维数组，得到有效数据的个数 sum</li>
<li>根据 sum 就可以创建稀疏数组 <code>sparse int[sum + 1][3]</code></li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<p>稀疏 数组转原始的二维数组的思路：</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 <code>chessArr2 = int[11][11]</code></li>
<li>再读取稀疏数组后几行的数据，并赋给 原始的二维数组即可。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855360.png" alt="1"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">   <span class="comment">//创建二维数组 棋盘，地图</span></span><br><span class="line">   <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">   arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">   arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">   arr[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="comment">//输出二维数组中的数据</span></span><br><span class="line">   System.out.println(<span class="string">&quot;原始的二维数组&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span>[] item:arr)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i:item)&#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将二维数组 转 稀疏数组的思路</span></span><br><span class="line">   <span class="comment">//1.先遍历二维数组，得到非0数据个数</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; arr[i].length;j ++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;二维数组中有效数据的个数：&quot;</span>+count);</span><br><span class="line">   <span class="type">int</span>[][] sparse = <span class="keyword">new</span> <span class="title class_">int</span>[count+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">   <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">      sparse[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">      sparse[<span class="number">0</span>][<span class="number">1</span>] = arr[i].length;</span><br><span class="line">      sparse[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//遍历二维数组，将非0的值存放到稀疏数组中</span></span><br><span class="line">   <span class="comment">//定义一个计数器来记录第几个非0的数据</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            count1 ++;</span><br><span class="line">            sparse[count1][<span class="number">0</span>] = i;</span><br><span class="line">            sparse[count1][<span class="number">1</span>] = j;</span><br><span class="line">            sparse[count1][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出稀疏数组的值</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span>[] item:sparse)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i:item)&#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将稀疏数组 恢复为 原始的二维数组</span></span><br><span class="line">   <span class="comment">//1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">   <span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[sparse[<span class="number">0</span>][<span class="number">0</span>]][sparse[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出的二维数组的数据全都是为0的</span></span><br><span class="line">   <span class="comment">//for(int[] item:arr1)&#123;</span></span><br><span class="line">   <span class="comment">//    for(int i:item)&#123;</span></span><br><span class="line">   <span class="comment">//        System.out.printf(&quot;%d\t&quot;,i);</span></span><br><span class="line">   <span class="comment">//    &#125;</span></span><br><span class="line">   <span class="comment">//    System.out.println();</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.再读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组即可</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; sparse.length;i ++)&#123;</span><br><span class="line">      <span class="comment">//sparse第i行的第2列是存储二维数据的值的位置</span></span><br><span class="line">      arr1[sparse[i][<span class="number">0</span>]][sparse[i][<span class="number">1</span>]] = sparse[i][<span class="number">2</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//输出的二维数组的数据</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span>[] item:arr1)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i:item)&#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">原始的二维数组</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二维数组中有效数据的个数：3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出稀疏数组的值</span><br><span class="line">11	11	3	</span><br><span class="line">1	2	1	</span><br><span class="line">2	3	2	</span><br><span class="line">5	5	2	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出稀疏数组恢复后的数据</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a class="markdownIt-Anchor" href="#队列">#</a> 队列</h2>
<p>银行排队的案例：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855839.png" alt="1"></p>
<p>队列介绍：</p>
<ul>
<li>队列是一个<mark>有序列表</mark>，可以用<mark>数组</mark>或是<mark>链表</mark>来实现。</li>
<li>遵循<mark>先入先出</mark>的原则，即：<mark>先存入队列的数据，要先取出，后存入的要后取出</mark>。</li>
<li>示意图 (使用数组模拟队列示意图)：</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855969.png" alt="1q"></p>
<h3 id="数组模拟队列"><a class="markdownIt-Anchor" href="#数组模拟队列">#</a> 数组模拟队列</h3>
<ul>
<li>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中 maxSize 是该队列的最大容量。</li>
<li>因为队列的输出，输入是分别从前后端来处理，因此需要两个变量<strong> front</strong> 及<strong> rear</strong> 分别<strong>记录队列全后端</strong>的下标，front 会随着数据输出而改变，而 rear 则是随着数据输入而改变。如下图所示：</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161855300.png" alt=""></p>
<ul>
<li>当我们将数据存入队列时称为 &quot;addQueue&quot;，&quot;addQueue&quot; 的处理需要有两个步骤：<strong>思路分析</strong></li>
</ul>
<ol>
<li>将尾指针往后移：rear+1, 当 front == rear [空]</li>
<li>若尾指针 rear 小于队列的最小下标 maxSize - 1, 则将数据存入 rear 所指的数组元素中，否则无法存入数据。rear == maxSize - 1 [队列满]。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">event_key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            <span class="comment">//显示菜单</span></span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">            event_key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span>(event_key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请添加数据到队列中&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    arrayQueue.addQueue(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.println(value);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;&gt;&gt; &quot;</span>+head);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请选择存在项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt; 程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span> <span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="comment">//指向队列头部，分析出front是指向队列头的前一个位置</span></span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了不能加入数据了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//rear向后移</span></span><br><span class="line">        rear++;</span><br><span class="line">        <span class="comment">//向数组中添加数据</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列数据，出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常会导致程序停止相当于return终止程序了所以下面不能再写代码了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//front向前移</span></span><br><span class="line">        front++;</span><br><span class="line">        <span class="comment">//取出当前front位置的数组元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        arr[front] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组遍历元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i ++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;&gt;&gt; arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列头数据，注意：不能取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析和优化</strong>：</p>
<ol>
<li>目前数组使用一次就不能用，没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个环形的数组 取模:  <code>%</code>  的方式来完成 (使用一个算法)。</li>
</ol>
<h3 id="数组模拟环形队列"><a class="markdownIt-Anchor" href="#数组模拟环形队列">#</a> 数组模拟环形队列</h3>
<p>对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<p><strong>分析说明</strong>：</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front [满]</li>
<li>rear == front [空]</li>
<li>测试示意图：</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856111.png" alt=""></p>
<p><strong>思路如下</strong>:</p>
<ol>
<li>
<p>front  变量的含义做一个调整： front 就指向队列的第一个元素，也就是说 arr [front] 就是队列的第一个元素</p>
<p>front 的初始值 = 0</p>
</li>
<li>
<p>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置。因为希望空出一个空间做为约定.</p>
<p>rear 的初始值 = 0</p>
</li>
<li>
<p>当队列满时，条件是 (rear  + 1) % maxSize == front 【满】</p>
</li>
<li>
<p>对队列为空的条件， rear == front 空</p>
</li>
<li>
<p>当我们这样分析， 队列中有效的数据的个数 (rear + maxSize - front) % maxSize //rear = 1 front = 0</p>
</li>
<li>
<p>我们就可以在原来的队列上修改得到，一个环形队列</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//初始化环形队列</span></span><br><span class="line">        <span class="type">ArrayQueue01</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue01</span>(<span class="number">4</span>);<span class="comment">//说明设置4,其队列的有效数据最大是3.空出了一个约定空间</span></span><br><span class="line">        <span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">event_key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            <span class="comment">//显示菜单</span></span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">            event_key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span>(event_key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        arrayQueue.showQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请添加数据到队列中&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                        arrayQueue.addQueue(num);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.println(value);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;&gt;&gt; &quot;</span>+head);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请选择存在项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt; 程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;All&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue01</span> <span class="params">(<span class="type">int</span> maxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列满了，不能添加数据了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向数组进行赋值</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear向后移，考虑环形数组所以需要使用取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里需要分析出front是指向队列的第一个元素</span></span><br><span class="line"><span class="comment">         * 1.先把front，对应的值保留到一个临时变量</span></span><br><span class="line"><span class="comment">         * 2.将front后移，考虑取模</span></span><br><span class="line"><span class="comment">         * 3.降临时保存的变量返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列中所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front;i &lt; front + size();i ++)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;&gt;&gt; arr[%d]=%d\n&quot;</span>,i % maxSize,arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h2>
<p>链表是有序的列表，但是它在内存中是存储如下：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856538.png" alt=""></p>
<p>小结：</p>
<ol>
<li>链表是以节点方式来存储，是链式存储。</li>
<li>每个节点包含 data 域，next 域：指向下一个节点。</li>
<li>如图：发现链表的各个节点不一定是连续存储。</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定。</li>
</ol>
<p><strong>单链表</strong> (带头节点) <strong>逻辑结构</strong>示意图如下：<mark>并不是连续存储的</mark>。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856015.png" alt=""></p>
<p><strong>单链表的应用实例</strong>:</p>
<p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理</p>
<ol>
<li>第一种方法在添加英雄时，直接添加到链表的尾部</li>
</ol>
<ul>
<li>思路分析示意图：<br>
<img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856161.png" alt=""></li>
</ul>
<ol start="2">
<li>第二种方式在添加英雄时，根据排名将英雄插入到指定位置<br>
 (如果有这个排名，则添加失败，并给出提示)</li>
</ol>
<ul>
<li>思路分析示意图：<br>
<img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856950.png" alt=""></li>
</ul>
<ol start="3">
<li>修改节点功能</li>
</ol>
<ul>
<li>思路：先找到该节点，通过遍历，<span class="exturl" data-url="aHR0cDovL3RlbXAubmFtZQ==">temp.name</span> = <span class="exturl" data-url="aHR0cDovL2gubmFtZQ==">h.name</span>;temp.nickname = h.nickname</li>
</ul>
<ol start="4">
<li>删除节点</li>
</ol>
<ul>
<li>思路分析示意图：<br>
<img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161857570.png" alt=""></li>
</ul>
<h3 id="单链表面试题新浪-百度-腾讯"><a class="markdownIt-Anchor" href="#单链表面试题新浪-百度-腾讯">#</a> 单链表面试题 (新浪、百度、腾讯)</h3>
<p>单链表的常见面试题有如下:</p>
<ol>
<li>
<p>求单链表中有效节点的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法：获取到单链表的节点的个数(如果是带头节点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">   <span class="comment">//空链表直接返回0</span></span><br><span class="line">   <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//定义辅助变量，没有统计头节点，通过h.next直接获取下一个节点的数据</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> h.next;</span><br><span class="line">   <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">      count++;</span><br><span class="line">      temp = temp.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回有效的个数</span></span><br><span class="line">   <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找单链表中的倒数第 k 个结点  【新浪面试题】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找单链表中的倒数第k个节点[新浪面试题]</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1.编写一个方法，接受head节点，同时接受一个index</span></span><br><span class="line"><span class="comment"> * 2.index表示是倒数第index个节点</span></span><br><span class="line"><span class="comment"> * 3.先把链表从头到尾遍历，得到链表的总的长度getLength</span></span><br><span class="line"><span class="comment"> * 4.得到size后，我们从链表的第一个开始遍历(size - index)个，就可以得到</span></span><br><span class="line"><span class="comment"> * 5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode h,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">   <span class="comment">//判断如果链表为空，则返回Null</span></span><br><span class="line">   <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(h);</span><br><span class="line">   <span class="comment">//第二次遍历，size - index位置，就是我们倒数的第k个节点</span></span><br><span class="line">   <span class="comment">//先做一个index的校验</span></span><br><span class="line">   <span class="keyword">if</span>(index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//定义辅助变量，for循环定位到倒数的index数据</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size - index;i ++)&#123;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单链表的反转【腾讯面试题，有点难度】</p>
<ul>
<li>思路分析示意图：</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856299.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将单链表反转 [腾讯面试题]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">   <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">   <span class="keyword">if</span>(h.next == <span class="literal">null</span> || h.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//定义一个辅助变量，帮助我们遍历原来的链表</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">   <span class="comment">//指向当前节点[cur]的下一个节点</span></span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在心的链表reverseHead的最前端</span></span><br><span class="line">   <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">      next = cur.next;</span><br><span class="line">      <span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">      cur.next = reverseHead.next;</span><br><span class="line">      <span class="comment">//将cur连接到新的链表上</span></span><br><span class="line">      reverseHead.next = cur;</span><br><span class="line">      <span class="comment">//让cur后移</span></span><br><span class="line">      cur = next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将head.next指向reverseHead.next,实现单链表的反转</span></span><br><span class="line">   h.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从尾到头打印单链表 (<font style="color:red"><strong>不破坏链表结构</strong></font>)【百度，要求方式 1：反向遍历 。  方式 2：Stack 栈】</p>
<ul>
<li>思路分析示意图：</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856313.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="comment"> * 这样就能保证链表本身的结构不发生变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">   <span class="comment">//判断链表是否为空</span></span><br><span class="line">   <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建一个栈，将各个节点压入栈</span></span><br><span class="line">   Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">   <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">   <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">   <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//入栈</span></span><br><span class="line">      stack.push(cur);</span><br><span class="line">      <span class="comment">//向后移动，遍历节点</span></span><br><span class="line">      cur = cur.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将栈中的节点进行打印,pop出栈</span></span><br><span class="line">   <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(stack.pop());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完整代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//创建几个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;松江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表并加入链表中</span></span><br><span class="line">        <span class="type">SingleLinkedListTwo</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedListTwo</span>();</span><br><span class="line"><span class="comment">//        linkedList.add(h);</span></span><br><span class="line"><span class="comment">//        linkedList.add(h3);</span></span><br><span class="line"><span class="comment">//        linkedList.add(h2);</span></span><br><span class="line"><span class="comment">//        linkedList.add(h1);</span></span><br><span class="line"></span><br><span class="line">        linkedList.addByOrder(h);</span><br><span class="line">        linkedList.addByOrder(h3);</span><br><span class="line">        linkedList.addByOrder(h2);</span><br><span class="line">        linkedList.addByOrder(h1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;正常情况下链表的数据&quot;</span>);</span><br><span class="line">        linkedList.list();</span><br><span class="line">        linkedList.reverseList(linkedList.getHead());</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后的链表数据&quot;</span>);</span><br><span class="line">        linkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序打印链表的数据&quot;</span>);</span><br><span class="line">        linkedList.reversePrint(linkedList.getHead());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        //显示链表中的数据</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;修改之前的数据&quot;);</span></span><br><span class="line"><span class="comment">        linkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //测试修改节点的代码</span></span><br><span class="line"><span class="comment">        HeroNode h02 = new HeroNode(2,&quot;小卢&quot;,&quot;玉麒麟~~&quot;);</span></span><br><span class="line"><span class="comment">        linkedList.update(h02);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //显示链表中的数据</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;修改之后的数据&quot;);</span></span><br><span class="line"><span class="comment">        linkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        linkedList.del(2);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;删除后的数据&quot;);</span></span><br><span class="line"><span class="comment">        linkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        linkedList.del(4);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;删除后的数据&quot;);</span></span><br><span class="line"><span class="comment">        linkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //获取单链表的有效个数</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;返回有效数据个数：&quot;+linkedList.getLength(linkedList.getHead()));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //得到倒数第k个数据</span></span><br><span class="line"><span class="comment">        HeroNode result = linkedList.findLastIndexNode(linkedList.getHead(),1);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;倒数第k个节点的数据：&quot;+result);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义SingleLinkedListTwo管理节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedListTwo</span> &#123;</span><br><span class="line">    <span class="comment">//初始化头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(h.next == <span class="literal">null</span> || h.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助变量，帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">        <span class="comment">//指向当前节点[cur]的下一个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在心的链表reverseHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            cur.next = reverseHead.next;</span><br><span class="line">            <span class="comment">//将cur连接到新的链表上</span></span><br><span class="line">            reverseHead.next = cur;</span><br><span class="line">            <span class="comment">//让cur后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next指向reverseHead.next,实现单链表的反转</span></span><br><span class="line">        h.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="comment">     * 这样就能保证链表本身的结构不发生变化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个栈，将各个节点压入栈</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">        <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">//向后移动，遍历节点</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中的节点进行打印,pop出栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next，指向 新的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后，就将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环是，那么temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next，指向 新的节点</span></span><br><span class="line">        temp.next = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二中方式在添加人物时，根据排名也就是编号，将人物插入到指定位置</span></span><br><span class="line"><span class="comment">     * (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//标示添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no &gt; h.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//说明希望添加的节点的编号已经存在了</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no == h.no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;添加的人物编号%d已经存在,不能重复添加&quot;</span>,h.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h.next = temp.next;</span><br><span class="line">            temp.next = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点的信息,根据no编号来修改，即no编号不能改</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.根据h的no来修改即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//标志 标记是否找到</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否遍历到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否找到</span></span><br><span class="line">            <span class="keyword">if</span>(temp.no == h.no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name = h.name;</span><br><span class="line">            temp.nickName = h.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;被修改的人物编号：&quot;</span>+h.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到需要修改的编号，无法进行修改&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说明我们在比较时，是temp.next.no和 需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">//定义临时变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//标志，记录是否找到待删除节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next.no == no)&#123;</span><br><span class="line">                <span class="comment">//标志设置可执行</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断标志</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//将temp下一个引用指向temp下下个next那么中间的就没有引用了jvm就会做垃圾回收机制将其处理</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除节点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找单链表中的倒数第k个节点[新浪面试题]</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 1.编写一个方法，接受head节点，同时接受一个index</span></span><br><span class="line"><span class="comment">     * 2.index表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">     * 3.先把链表从头到尾遍历，得到链表的总的长度getLength</span></span><br><span class="line"><span class="comment">     * 4.得到size后，我们从链表的第一个开始遍历(size - index)个，就可以得到</span></span><br><span class="line"><span class="comment">     * 5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode h,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//判断如果链表为空，则返回Null</span></span><br><span class="line">        <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(h);</span><br><span class="line">        <span class="comment">//第二次遍历，size - index位置，就是我们倒数的第k个节点</span></span><br><span class="line">        <span class="comment">//先做一个index的校验</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量，for循环定位到倒数的index数据</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> h.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size - index;i ++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法：获取到单链表的节点的个数(如果是带头节点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h 链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode h)</span>&#123;</span><br><span class="line">        <span class="comment">//空链表直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(h.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量，没有统计头节点，通过h.next直接获取下一个节点的数据</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> h.next;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回有效的个数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示链表的数据[遍历]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们需要一个辅助变量来进行遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp向后移动,不后移就是死循环</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义HeroNode 每个 HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表应用实例"><a class="markdownIt-Anchor" href="#双向链表应用实例">#</a> 双向链表应用实例</h3>
<p>使用带 head 头的双向链表实现 –水浒英雄排行榜</p>
<p>管理单向链表的缺点分析:</p>
<ol>
<li>单向链表，查找的方向只能是一个方向，而双向链  表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一  个节点 (认真体会).</li>
<li>示意图帮助理解删除</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161856489.png" alt=""></p>
<p>分析 双向链表的遍历，添加，修改，删除的操作思路 ===》代码实现</p>
<ol>
<li>遍历 方和 单链表一样，只是可以向前，也可以向后查找</li>
<li>添加  (默认添加到双向链表的最后)
<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next = newHeroNode</li>
<li>newHeroNode.pre = temp;</li>
</ol>
</li>
<li>修改 思路和 原来的单向链表一样.</li>
<li>删除
<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如 temp<br>
temp.pre.next = temp.next<br>
temp.next.pre = temp.pre;</li>
</ol>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">du</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>,<span class="string">&quot;松江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        du.addByOrder(h);</span><br><span class="line">        du.addByOrder(h3);</span><br><span class="line">        du.addByOrder(h2);</span><br><span class="line">        du.addByOrder(h1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;修改前的数据&quot;);</span></span><br><span class="line">        du.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        HeroNode01 h01 = new HeroNode01(2,&quot;小卢&quot;,&quot;玉麒麟~~&quot;);</span></span><br><span class="line"><span class="comment">//        du.update(h01);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;修改后的数据&quot;);</span></span><br><span class="line"><span class="comment">//        du.list();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        du.del(1);</span></span><br><span class="line"><span class="comment">//        du.del(3);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;删除后的数据&quot;);</span></span><br><span class="line"><span class="comment">//        du.list();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//初始化头节点，这个节点不动</span></span><br><span class="line">    <span class="type">HeroNode01</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 <span class="title function_">getHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode01 h)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.no &gt; h.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no == h.no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;节点的主键(%d)存在重复&quot;</span>,temp.next.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为防止出现空指针情况，需要对temp节点位置进行判断</span></span><br><span class="line"><span class="comment">             * 若双向链表尚未达尾端，则需要将h节点与其相邻的后面的节点进行连接</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                h.next = temp.next;</span><br><span class="line">                temp.next.pre = h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无论双向链表是否达尾端，都需要将h节点与其相邻的前面的节点进行连接</span></span><br><span class="line">            temp.next = h;</span><br><span class="line">            h.pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表删除节点</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.对于双向链表，我们可以直接找到要删除这个节点</span></span><br><span class="line"><span class="comment">     * 2.找到后，自我删除即可,而不用说找到删除节点的前一个节点然后进行删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no == no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果删除最后一个节点</span></span><br><span class="line"><span class="comment">             * 让当前要删除的节点的前一个节点的next指向下一个节点</span></span><br><span class="line"><span class="comment">             * 而后一个节点是null所以next为null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果是最后一个节点执行下面操作会出现异常</span></span><br><span class="line"><span class="comment">             * 最后一个节点的next是空的</span></span><br><span class="line"><span class="comment">             * 所以next为null就不可能有pre因此就产生了问题</span></span><br><span class="line"><span class="comment">             * 最后一个节点的时候就不需要执行下面的操作了，否则报错PointerException</span></span><br><span class="line"><span class="comment">             * 判断后一个节点是否为null解决报错问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有可删除节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode01 n)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.no == n.no)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name = n.name;</span><br><span class="line">            temp.nickName = n.nickName;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改的编号为：&quot;</span>+temp.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有可修改的编号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode01 h)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = h;</span><br><span class="line">        h.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双向链表的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头结点不能动，所以需要使用辅助变量</span></span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历是否循环到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode01</span> &#123;</span><br><span class="line">    <span class="comment">//指向下一个节点,默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 next;</span><br><span class="line">    <span class="comment">//指向前一个节点,默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 pre;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode01</span><span class="params">(<span class="type">int</span> no, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode01&#123;&quot;</span>+</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单向环形链表应用场景"><a class="markdownIt-Anchor" href="#单向环形链表应用场景">#</a> 单向环形链表应用场景</h3>
<p>Josephu (约瑟夫、约瑟夫环) 问题</p>
<p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><strong>单向环形链表介绍</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161857436.png" alt=""></p>
<p><strong>Josephu 问题</strong></p>
<p>ØJosephu 问题</p>
<p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>Ø 提示</p>
<p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p>Ø 示意图说明</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161857188.png" alt=""></p>
<p>约瑟夫问题 - 创建环形链表的思路图解：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858378.png" alt=""></p>
<p>约瑟夫问题 - 小孩出圈的思路分析图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858452.png" alt=""></p>
<p>Josephu 代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">		<span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">		circleSingleLinkedList.addBoy(<span class="number">125</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">		circleSingleLinkedList.showBoy();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">		circleSingleLinkedList.countBoy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">125</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">		<span class="comment">//String str = &quot;7*2*2-5+1-5+3-3&quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">		<span class="comment">// nums 做一个数据校验</span></span><br><span class="line">		<span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line">		<span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">			<span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">			<span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">			<span class="comment">// 如果是第一个小孩</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">				first = boy;</span><br><span class="line">				first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">				curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(boy);<span class="comment">//</span></span><br><span class="line">				boy.setNext(first);<span class="comment">//</span></span><br><span class="line">				curBoy = boy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;没有任何小孩~~&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">		<span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;小孩的编号 %d \n&quot;</span>, curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment">	 *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment">	 *            表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">	 *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">		<span class="comment">// 先对数据进行校验</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;参数输入有误， 请重新输入&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">		<span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">		<span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//小孩报数前，先让 first 和  helper 移动 k - 1次</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		    <span class="comment">//first和helper一块向后移动它们两个始终都是围绕着我个环形first为头helper为绕环形最后一个</span></span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈</span></span><br><span class="line">		<span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">			System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">			<span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper.setNext(first); <span class="comment">//</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d \n&quot;</span>, first.getNo());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈"><a class="markdownIt-Anchor" href="#栈">#</a> 栈</h2>
<p><strong>栈的一个实际需求</strong></p>
<p>请输入一个表达式</p>
<p>计算式:[7<em>2</em>2-5+1-5+3-3] 点击计算【如下图】</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858884.png" alt=""></p>
<p>请问：计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算，因为我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的 (对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-&gt; <mark>栈</mark>.</p>
<p><strong>栈的介绍</strong></p>
<ol>
<li>栈的英文为 (<mark>stack</mark>)</li>
<li>栈是一个<mark>先入后出</mark> (FILO-First In Last Out) 的有序列表。</li>
<li>栈 (stack) 是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为<mark>变化的一端，称为栈顶 (Top)</mark>，另一端为<mark>固定的一端，称为栈底 (Bottom)</mark>。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
<li><mark>出栈 (pop) 和入栈 (push) 的概念</mark> (如图所示)</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858370.png" alt=""></p>
<p><strong>栈的应用场景</strong></p>
<ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换 [中缀表达式转后缀表达式] 与求值 (实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先 (depth 一 first) 搜索法。</li>
</ol>
<p><strong>栈的快速入门</strong></p>
<ol>
<li>用数组模拟栈的使用，由于栈是一种有序列表，  当然可以使用数组的结构来储存栈的数据内容，  下面我们就用数组模拟栈的出栈，入栈等操作。</li>
<li>实现思路分析，并画出示意图</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858827.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">        <span class="comment">//测试数组模拟栈是否正确</span></span><br><span class="line">        <span class="comment">//先创建一个ArrayStack对象 --&gt; 表示栈</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">char</span>  <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 展示栈数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(push): 向栈中添加数据(入栈)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(pop): 弹出栈顶元素(出栈)&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出数组模拟栈程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        stack.list();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请添加数据&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                        stack.push(value);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;弹出栈顶元素：%d\n&quot;</span>,pop);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请选择存在的选项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//数组模拟栈，数据存入该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;</span><br><span class="line">    <span class="comment">//top表示栈顶，初始化为-1表示没有数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span> <span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满了</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈满了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时需要从栈顶开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;&gt;&gt; stack[%d] = %d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>课堂练习，将老师写的程序改成使用链表来模拟栈</li>
</ol>
<ul>
<li>出栈的图解示意图</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858565.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListAnArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedListDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedListDemo</span>();</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span>  <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a(push) 添加数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(list) 显示栈中所有数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(pop) 弹出栈顶元素&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请添加数据&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                        demo.add(value);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> demo.get();</span><br><span class="line">                        System.out.println(<span class="string">&quot;&gt;&gt; 弹出元素为：&quot;</span>+i);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        demo.list();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请选择存在选项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDemo</span> &#123;</span><br><span class="line">    <span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LinkedList</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">LinkedList</span> <span class="variable">top</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LinkedList <span class="title function_">getStack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">new_element</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(h);</span><br><span class="line">        <span class="comment">//因为头节点不能动，需要一个辅助变量完成</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> stack;</span><br><span class="line">        <span class="comment">//对链表进行遍历，遍历到最后一个节点即为链表的尾部，进行添加节点</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动节点位置</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对节点的下一个节点进行赋值</span></span><br><span class="line">        temp.next = new_element;</span><br><span class="line">        <span class="comment">//将top节点指向这个最后一个数据的节点</span></span><br><span class="line">        top = new_element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//将top指针前移动一个</span></span><br><span class="line">        <span class="comment">//需要重新遍历链表找到top节点的前一个节点，再由top指针指向这个节点</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">head</span> <span class="operator">=</span> stack;</span><br><span class="line">        <span class="comment">//将 top 指针指向的节点出栈</span></span><br><span class="line">        <span class="comment">//因为出站后，top指针需要向前移动，所以需要一个辅助指针完成出栈</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">tmp</span> <span class="operator">=</span> top;</span><br><span class="line">        <span class="comment">//判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到head.next == null节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(head.next == top)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针后移</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出循环后，找到top节点的前一个节点，对head.next节点进行删除赋值null</span></span><br><span class="line">        <span class="comment">//因为top.next节点是null,而head.next节点就是top.next节点的上一个节点</span></span><br><span class="line">        head.next = top.next;</span><br><span class="line">        <span class="comment">//将top指针指向这个节点，完成top指针的前移动作</span></span><br><span class="line">        top = head;</span><br><span class="line">        <span class="comment">//返回前一个节点的data数据</span></span><br><span class="line">        <span class="keyword">return</span> tmp.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">temp</span> <span class="operator">=</span> stack;</span><br><span class="line">        <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt; (&quot;</span>+count+<span class="string">&quot;)\t:\t&quot;</span>+temp.next.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> LinkedList next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span> <span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈实现综合计算器"><a class="markdownIt-Anchor" href="#栈实现综合计算器">#</a> 栈实现综合计算器</h3>
<p>使用栈来实现综合计算器 - 自定义优先级 [priority]<br>
Ø 简化思路:</p>
<ol>
<li>3+2*6-2</li>
<li>30+2*6-2</li>
<li>7<em>2</em>2-5+1-5+3-4</li>
</ol>
<p><strong>使用栈完成表达式的计算 思路</strong></p>
<ol>
<li>
<p>通过一个 index 值（索引），来遍历我们的表达式</p>
</li>
<li>
<p>如果我们发现是一个数字，就直接入数栈</p>
</li>
<li>
<p>如果发现扫描到是一个符号，就分如下情况</p>
<p>3.1 如果发现当前的符号栈为 空，就直接入栈<br>
 3.2 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中 pop 出两个数，在从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 (* 计算后下一个就是当前的操作符 - 入栈)， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</p>
</li>
<li>
<p>当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行.</p>
</li>
<li>
<p>最后在数栈只有一个数字，就是表达式的结果</p>
</li>
</ol>
<p>验证： 3+2*6-2 = 13</p>
<p>示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161858790.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个运算的表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;(7-2)*3+1&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈，一个数栈，一个字符栈各自存储不同的东西</span></span><br><span class="line">        <span class="type">ArrayStack02</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack02</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack02</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack02</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//扫描表达式的index值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从数栈中pop的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从数栈中pop的第二个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从字符栈中pop出的运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从数栈中pop出两个数值计算的结果</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描得到的char保存到ch</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression运算表达式</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//依次得到expression 的每一个字符</span></span><br><span class="line">            ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断ch是什么，然后做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch)) &#123;<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断当前的符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span></span><br><span class="line">                    <span class="comment">//这里需要判断是否此时的栈顶是否为左括号，如果是左括号不进入此循环</span></span><br><span class="line">                    <span class="comment">//我们设定的左括号是优先级大于加减乘除，所以当发现下一个进栈的符号的优先级比此时的栈顶的左括号优先级小的时候，</span></span><br><span class="line">                    <span class="comment">//应该让符号直接进栈，不进行弹出左符号的运算（左括号弹出来运算是不行的）</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek()) &amp; operStack.peek() != <span class="number">40</span>) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        <span class="comment">//把运算的结果如数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//然后将当前的操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 进行右括号的判断。匹配左括号</span></span><br><span class="line"><span class="comment">                         * 当发现进入的是右括号时就优先进行括号内的计算</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="number">41</span>)&#123;</span><br><span class="line">                        <span class="comment">//先让右括号进栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="number">41</span>) &#123;</span><br><span class="line">                            <span class="comment">//再把右括号弹出</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">oper1</span> <span class="operator">=</span> operStack.pop();</span><br><span class="line">                            <span class="comment">//弹出右括号后开始进行括号内运算</span></span><br><span class="line">                            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                                <span class="comment">//右括号</span></span><br><span class="line">                                num1 = numStack.pop();</span><br><span class="line">                                num2 = numStack.pop();</span><br><span class="line">                                oper = operStack.pop();</span><br><span class="line">                                res = numStack.cal(num1, num2, oper);</span><br><span class="line">                                <span class="comment">//把运算的结果如数栈</span></span><br><span class="line">                                numStack.push(res);</span><br><span class="line">                                <span class="comment">//当运算到栈顶符号为左括号时候，就弹出栈顶元素左括号，结束循环</span></span><br><span class="line">                                <span class="keyword">if</span>(operStack.peek() == <span class="number">40</span>) &#123;</span><br><span class="line">                                    <span class="type">int</span> <span class="variable">oper2</span> <span class="operator">=</span> operStack.pop();</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果为空直接入符号栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是数，则直接入数栈</span></span><br><span class="line">                <span class="comment">//分析思路</span></span><br><span class="line">                <span class="comment">//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">                <span class="comment">//2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                <span class="comment">//3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">                    <span class="comment">//注意是看后一位，不是index++</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(expression.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//如果后一位是运算符，则入栈 keepNum = &quot;1&quot; 或者 &quot;123&quot;</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//重要的!!!!!!, keepNum清空</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index + 1, 并判断是否扫描到expression最后.</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个数字[结果]</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1,num2,oper);</span><br><span class="line">            numStack.push(res);<span class="comment">//入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数栈的最后数，pop出，就是结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式%s = %d&quot;</span>,expression,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack02</span> &#123;</span><br><span class="line">    <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//数组模拟栈，数据存入该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;</span><br><span class="line">    <span class="comment">//top表示栈顶，初始化为-1表示没有数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack02</span> <span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个方法，可以返回当前栈顶的值，但是不是真正的pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满了</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈满了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时需要从栈顶开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;&gt;&gt; stack[%d] = %d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回运算符的优先级，优先级是程序员来确定，优先级使用数字表示</span></span><br><span class="line"><span class="comment">     * 数字越大，则优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;(&#x27;</span> || oper == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假设目前的表达式只有 + - * /</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为一个运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span> || val == <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                || val == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">int</span>  oper)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//TODO 注意计算的顺序</span></span><br><span class="line">        <span class="keyword">switch</span>(oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;计算错误&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀-中缀-后缀表达式逆波兰表达式"><a class="markdownIt-Anchor" href="#前缀-中缀-后缀表达式逆波兰表达式">#</a> 前缀、中缀、后缀表达式 (逆波兰表达式)</h3>
<h4 id="前缀表达式波兰表达式"><a class="markdownIt-Anchor" href="#前缀表达式波兰表达式">#</a> 前缀表达式 (波兰表达式)</h4>
<ol>
<li>前缀表达式又称<mark>波兰式</mark>，前缀表达式的运算符位于操作数之前</li>
<li>举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6</li>
</ol>
<p><strong>前缀表达式的计算机求值</strong></p>
<p>从<mark>右</mark>至<mark>左</mark>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和  次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<p>例如:  (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:</p>
<ol>
<li>从右至左扫描，将 6、5、4、3 压入堆栈</li>
<li>遇到 + 运算符，因此弹出 3 和 4（3 为栈顶元素，4 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈</li>
<li>接下来是 × 运算符，因此弹出 7 和 5，计算出 7×5=35，将 35 入栈</li>
<li>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</li>
</ol>
<h4 id="中缀表达式"><a class="markdownIt-Anchor" href="#中缀表达式">#</a> 中缀表达式</h4>
<ol>
<li>中缀表达式就是常见的运算表达式，如 (3+4)×5-6</li>
<li>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作 (前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作 (一般转成后缀表达式.)</li>
</ol>
<h4 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式">#</a> 后缀表达式</h4>
<ol>
<li>后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后</li>
<li>中举例说明： (3+4)×5-6 对应的后缀表达式就是  3 4 + 5 × 6 –</li>
<li>再比如:</li>
</ol>
<table>
<thead>
<tr>
<th>正常的表达式</th>
<th>逆波兰表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>a+b</td>
<td>a b +</td>
</tr>
<tr>
<td>a+(b-c)</td>
<td>a b c - +</td>
</tr>
<tr>
<td>a+(b-c)*d</td>
<td>a b c - d * +</td>
</tr>
<tr>
<td>a+d*(b-c)</td>
<td>a d b c - * +</td>
</tr>
<tr>
<td>a=1+3</td>
<td>a 1 3 + =</td>
</tr>
</tbody>
</table>
<p><strong>后缀表达式的计算机求值</strong></p>
<p>从<mark>左</mark>至<mark>右</mark>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<p>例如: <strong>(3+4)×5-6</strong> 对应的后缀表达式就是 <strong>3 4 + 5 × 6 -</strong> <strong>,</strong> <strong>针对后缀表达式求值步骤如下</strong>:</p>
<ol>
<li>从左至右扫描，将 3 和 4 压入堆栈；</li>
<li>遇到 + 运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；</li>
<li>将 5 入栈；</li>
<li>接下来是 × 运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；</li>
<li>将 6 入栈；</li>
<li>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</li>
</ol>
<h4 id="中缀转后缀表达式"><a class="markdownIt-Anchor" href="#中缀转后缀表达式">#</a> 中缀转后缀表达式</h4>
<p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 <strong>中缀表达式</strong>转成<strong>后缀表达式</strong>。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2</li>
<li>从左至右扫描中缀表达式</li>
<li>遇到操作数时，将其压 s2</li>
<li>遇到运算符时，比较其与 s1 栈顶运算符的优先级：
<ol>
<li>如果 s1 为空，或栈顶运算符为左括号 “(”，则直接将此运算符入栈</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入 s1</li>
<li>否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到 (4-1) 与 s1 中新的栈顶运算符相比较</li>
</ol>
</li>
<li>遇到括号时:
<ol>
<li>如果是左括号 “(”，则直接压入 s1</li>
<li>如果是右括号 “)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤 2 至 5，直到表达式的最右边</li>
<li>将 s1 中剩余的运算符依次弹出并压入 s2</li>
<li>依次弹出 s2 中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></li>
</ol>
<p>示意图：</p>
<p>中缀表达式 转 后缀表达式的 思路步骤分析</p>
<p>打比方 ： 降龙十八掌 ：学习 -》 应用 [层次]</p>
<p>算法 -》 第一个层面： 理解算法 -》灵活运用算法</p>
<p>第二层： 设计算法 -》 运用 【】</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859882.png" alt=""></p>
<p><strong>举例说明</strong>：</p>
<p>将中缀表达式 **“1+((2+3)×4)-5”** 转换为后缀表达式的过程如下:</p>
<p>因此结果为 **“1 2 3 + 4 × + 5 –”**</p>
<table>
<thead>
<tr>
<th>扫描到的元素</th>
<th>s2 (栈底 -&gt; 栈顶)</th>
<th>s1 (栈底 -&gt; 栈顶)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>空</td>
<td>数字，直接入栈</td>
</tr>
<tr>
<td>+</td>
<td>1</td>
<td>+</td>
<td>s1 为空，运算符直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ (</td>
<td>左括号，直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ ( (</td>
<td>同上</td>
</tr>
<tr>
<td>2</td>
<td>1 2</td>
<td>+ ( (</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>1 2</td>
<td>+ ( ( +</td>
<td>s1 栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>3</td>
<td>1 2 3</td>
<td>+ ( ( +</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 +</td>
<td>+ (</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>×</td>
<td>1 2 3 +</td>
<td>+ ( ×</td>
<td>s1 栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>4</td>
<td>1 2 3 + 4</td>
<td>+ ( ×</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 + 4 ×</td>
<td>+</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>-</td>
<td>1 2 3 + 4 × +</td>
<td>-</td>
<td>- 与 + 优先级相同，因此弹出 +，再压入 -</td>
</tr>
<tr>
<td>5</td>
<td>1 2 3 + 4 × + 5</td>
<td>-</td>
<td>数字</td>
</tr>
<tr>
<td>到达最右端</td>
<td>1  2 3 + 4 × + 5 -</td>
<td>空</td>
<td>s1 中剩余的运算符</td>
</tr>
</tbody>
</table>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义中缀表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)x4)-5&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1.1+((2+3)x4)-5 =&gt; 1 2 3 + 4 x + 5 -</span></span><br><span class="line"><span class="comment">         * 2.因为直接对str进行操作，不太方便，因此 先将 “1+((2+3)x4)-5” =&gt; 中缀的表达式对应的List即&quot;1+((2+3)x4)-5&quot;</span></span><br><span class="line"><span class="comment">         * =&gt; ArrayList[1,2,3,+,4,x,+,5,-]</span></span><br><span class="line"><span class="comment">         * 3.将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List即ArrayList[1+((2+3)x4)-5]</span></span><br><span class="line"><span class="comment">         * =&gt; ArrayList[1,2,3,+,4,x,+,5,-]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; resultList = toInfixExpressionList(suffixExpression);</span><br><span class="line">        System.out.println(resultList);<span class="comment">//[1, +, (, (, 2, +, 3, ), x, 4, ), -, 5]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; resultList1 = parseSuffixExpressionList(resultList);</span><br><span class="line">        System.out.println(resultList1);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;逆波兰表达式运算结果: %d&quot;</span>,calculate(resultList1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个逆波兰表达式，依次将数据和运算符，放入到ArrayList中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suffixExpression</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String ele:split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 即ArrayList [1, +, (, (, 2, +, 3, ), x, 4, ), -, 5] =&gt; ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line"><span class="comment">     * 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个栈一个集合</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 说明：因为ls这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line"><span class="comment">         * 因此比较麻烦，这里我们就不用Stack&lt;String&gt;直接使用List&lt;String&gt; ls</span></span><br><span class="line"><span class="comment">         * Stack&lt;String&gt; ls = new Stack&lt;String&gt;(); 存储中间结果的栈ls</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历List集合中的数据</span></span><br><span class="line">        <span class="keyword">for</span>(String i:list)&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，加入List集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                ls.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//如果是右括号&quot;)&quot;,则依次弹出Stack栈顶的运算符，并压入List集合，直到遇到左括号为止，此时将一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    ls.add(stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 当item的优先级小于等于stack栈顶运算符，将stack栈顶的运算符弹出并加入到list中，再次转到(4.1)与stack中新的</span></span><br><span class="line"><span class="comment">                 * 栈顶运算符相比较</span></span><br><span class="line"><span class="comment">                 * 问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span>(stack.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(stack.peek()) &gt;= Operation.getValue(i))&#123;</span><br><span class="line">                    ls.add(stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将i压入栈</span></span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将stack中剩余的运算符依次弹出并加入list中</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            ls.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法：将中缀表达式转成对应的list</span></span><br><span class="line"><span class="comment">     * s = &quot;1+((2+3)x4)-5&quot;;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//这是一个指针，用于遍历中缀表达式字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对多位数的拼接</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//每遍历到一个字符， 就放入到ch</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//如果ch是一个非数组，我们需要加入到list集合中</span></span><br><span class="line">            <span class="keyword">if</span>((ch = s.charAt(i)) &lt; <span class="number">48</span> || (ch = s.charAt(i)) &gt; <span class="number">57</span>)&#123;</span><br><span class="line">                list.add(ch + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="comment">//i指针后移</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是一个数，需要考虑多位数</span></span><br><span class="line">                <span class="comment">//先将str置成空字符串&quot;&quot; &#x27;0&#x27;[48] -&gt; &#x27;9&#x27;[57]</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; (ch = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (ch = s.charAt(i)) &lt;= <span class="number">57</span>)&#123;</span><br><span class="line">                    <span class="comment">//拼接多位数</span></span><br><span class="line">                    str += ch;</span><br><span class="line">                    <span class="comment">//i指针后移</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">     * 1.从左至右扫描，将3和4压入栈</span></span><br><span class="line"><span class="comment">     * 2.遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素),计算出3+4的值，得7，再将7入栈</span></span><br><span class="line"><span class="comment">     * 3.将5入栈</span></span><br><span class="line"><span class="comment">     * 4.接下来是x运算符，因此弹出5和7，计算出7x5=35,将35入栈</span></span><br><span class="line"><span class="comment">     * 5.将6入栈</span></span><br><span class="line"><span class="comment">     * 6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈，只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String i:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                stack.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;x&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您输入的逆波兰表达式有问题不能计算&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把结果压入栈中</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在栈中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写一个类Operation可以返回一个运算符对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;x&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;操作符发生了错误&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆波兰计算器"><a class="markdownIt-Anchor" href="#逆波兰计算器">#</a> 逆波兰计算器</h3>
<p>我们完成一个逆波兰计算器，要求完成如下任务：</p>
<ol>
<li>输入一个逆波兰表达式 (后缀表达式)，使用栈 (stack)，计算其结果</li>
<li>支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算</li>
<li>思路分析
<ol>
<li>从左至右扫描，将 3 和 4 压入栈</li>
<li>遇到 + 运算符，因此弹出 4 和 3 (4 为栈顶元素，3 为次顶元素)，计算出 3+4 的值，得 7，再将 7 入栈</li>
<li>将 5 入栈</li>
<li>接下来是 x 运算符，因此弹出 5 和 7，计算出 7x5=35，将 35 入栈</li>
<li>将 6 入栈</li>
<li>最后是 - 运算符，计算出 35-6 的值，即 29，由此得出最终结果</li>
</ol>
</li>
<li>代码完成：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义逆波兰表达式</span></span><br><span class="line">        <span class="comment">//说明：为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 x 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.先将&quot;3 4 + 5 x 6 -&quot; =&gt; 放到ArrayList中</span></span><br><span class="line"><span class="comment">         * 2.将ArrayList传递给一个方法，遍历ArrayList 配置栈 完成计算</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; listString = getListString(suffixExpression);</span><br><span class="line">        <span class="type">int</span> <span class="variable">calculate</span> <span class="operator">=</span> calculate(listString);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt; 逆波兰表达式运算结果：&quot;</span>+calculate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个逆波兰表达式，依次将数据和运算符，放入到ArrayList中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> suffixExpression</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String ele:split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">     * 1.从左至右扫描，将3和4压入栈</span></span><br><span class="line"><span class="comment">     * 2.遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素),计算出3+4的值，得7，再将7入栈</span></span><br><span class="line"><span class="comment">     * 3.将5入栈</span></span><br><span class="line"><span class="comment">     * 4.接下来是x运算符，因此弹出5和7，计算出7x5=35,将35入栈</span></span><br><span class="line"><span class="comment">     * 5.将6入栈</span></span><br><span class="line"><span class="comment">     * 6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈，只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String i:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                stack.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;x&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;您输入的逆波兰表达式有问题不能计算&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把结果压入栈中</span></span><br><span class="line">                stack.push(res+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在栈中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归">#</a> 递归</h2>
<p><strong>递归应用场景</strong></p>
<p>看个实际应用场景，迷宫问题 (回溯)， 递归 (Recursion)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859123.png" alt=""></p>
<p><strong>递归的概念</strong></p>
<p>简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</p>
<p><strong>递归调用机制</strong></p>
<p>我列举两个小案例，来帮助大家理解递归，部分学员已经学习过递归了，这里在给大家回顾一下递归调用机制</p>
<ol>
<li>打印问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出什么?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		test(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>阶乘问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859550.png" alt=""></p>
<p><strong>递归能解决什么样的问题</strong></p>
<p>递归用于解决什么样的问题</p>
<ol>
<li>各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题 (google 编程大赛)</li>
<li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li>
<li>将用栈解决的问题–&gt; 递归代码比较简洁</li>
</ol>
<p><strong>递归需要遵守的重要规则</strong></p>
<p>递归需要遵守的重要规则</p>
<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间 (栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如 n 变量</li>
<li>如果方法中使用的是引用类型变量 (比如数组)，就会共享该引用类型的数据.</li>
<li><mark>递归必须向退出递归的条件逼近</mark>，否则就是无限递归，出现 StackOverflowError，死归了：)</li>
<li>当一个<mark>方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁</mark>，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h3 id="递归-迷宫问题"><a class="markdownIt-Anchor" href="#递归-迷宫问题">#</a> 递归 - 迷宫问题</h3>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859781.png" alt=""></p>
<p>说明:</p>
<ol>
<li>小球得到的路径，和程序员  设置的找路策略有关即：找  路的上下左右的顺序相关</li>
<li>再得到小球路径时，可以先  使用 (下右上左)，再改成 (上  右下左)，看看路径是不是有变化</li>
<li>测试回溯现象
<ol>
<li>创建一面墙将小球堵住</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二维数组模拟迷宫</span></span><br><span class="line">     <span class="comment">//地图</span></span><br><span class="line">     <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">     <span class="comment">//生成地图的地形</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr[<span class="number">0</span>].length;i ++)&#123;</span><br><span class="line">         arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">         arr[arr.length - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">         arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">         arr[i][arr[<span class="number">0</span>].length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//添加地形中的一面阻碍的墙</span></span><br><span class="line">     arr[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     arr[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//添加一面墙将小球堵死</span></span><br><span class="line">     arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">     arr[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>思考：如何求出最短路径？</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用二维数组模拟迷宫</span></span><br><span class="line">        <span class="comment">//地图</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//生成地图的地形</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr[<span class="number">0</span>].length;i ++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            arr[arr.length - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            arr[i][arr[<span class="number">0</span>].length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加地形中的一面阻碍的墙</span></span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//添加一面墙将小球堵死</span></span><br><span class="line"><span class="comment">//        arr[1][2] = 1;</span></span><br><span class="line"><span class="comment">//        arr[2][2] = 1;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输出地图情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] temp:arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:temp)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\t\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> setWay01(arr,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        <span class="comment">//输出新的地图，小球走过并标识过的地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过并标识的 输出地图情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] temp:arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:temp)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\t\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 使用递归回溯给小球找路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 表示从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 表示从哪个位置开始找</span></span><br><span class="line"><span class="comment">     *  i j : 表示的是地图中的位置坐标点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到了通路返回true 否则返回false</span></span><br><span class="line"><span class="comment">     * 1.规则:</span></span><br><span class="line"><span class="comment">     * 如果小球找到int[6][5]则说明通路找到了</span></span><br><span class="line"><span class="comment">     * 2.约定:</span></span><br><span class="line"><span class="comment">     * 当int[i][j]为0时表示位置没有走过,当为1表示为墙不能越过,2表示通路可以走,3表示该位置已经走过了但是走不通</span></span><br><span class="line"><span class="comment">     * 3.策略:</span></span><br><span class="line"><span class="comment">     * 走迷宫时需要确定一个策略(思考的方法) 下 -&gt; 右 -&gt; 上 -&gt; 左. 如果该点走不通再回溯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;<span class="comment">//通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>)&#123; <span class="comment">//判断如果这个点还没走过</span></span><br><span class="line">                arr[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(setWay(arr,i+<span class="number">1</span>,j))&#123; <span class="comment">//下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(arr,i,j+<span class="number">1</span>))&#123; <span class="comment">//右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(arr,i-<span class="number">1</span>,j))&#123; <span class="comment">//上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(arr,i,j-<span class="number">1</span>))&#123; <span class="comment">//左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//走不同 标记为3</span></span><br><span class="line">                    arr[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="comment">//返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果arr[i][j] != 0，可能是1,2,3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 怎么走出迷宫是代码决定的，换一种思路走出迷宫</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 表示球的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 表示球的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true表示走出迷宫，false表示没有走出迷宫</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay01</span><span class="params">(<span class="type">int</span>[][] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            arr[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(setWay01(arr,i-<span class="number">1</span>,j))&#123;<span class="comment">//上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay01(arr,i,j+<span class="number">1</span>))&#123;<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay01(arr,i+<span class="number">1</span>,j))&#123;<span class="comment">//下</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay01(arr,i,j-<span class="number">1</span>))&#123;<span class="comment">//左</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[i][j] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归-八皇后问题回溯算法"><a class="markdownIt-Anchor" href="#递归-八皇后问题回溯算法">#</a> 递归 - 八皇后问题 (回溯算法)</h3>
<p><strong>八皇后问题介绍</strong></p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯・贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法 (92)。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859594.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859391.png" alt=""></p>
<p><strong>八皇后问题算法思路分析</strong></p>
<ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…… 直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤 【示意图】</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900978.png" alt=""></p>
<p><strong>说明</strong>：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr [8] = {0 , 4, 7, 5, 2, 6, 1, 3} // 对应 arr 下标 表示第几行，即第几个皇后，arr [i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bahuanghou</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">judgeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">        <span class="type">Bahuanghou</span> <span class="variable">queue8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bahuanghou</span>();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共有%d解法&quot;</span>, count);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共判断冲突的次数%d次&quot;</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == max) &#123;  <span class="comment">//n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个皇后,即开始递归</span></span><br><span class="line">                check(n+<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">// n = 1  放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line">            <span class="comment">// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line">            <span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序算法的介绍"><a class="markdownIt-Anchor" href="#排序算法的介绍">#</a> 排序算法的介绍</h2>
<p>排序也称排序算法 (Sort Algorithm)，排序是将<strong>一  组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列  的过程</strong>。</p>
<p>排序不是数据结构而是算法</p>
<p>排序的分类：</p>
<ol>
<li>内部排序:</li>
</ol>
<p>指将需要处理的所有数据都加载  到<strong>内部存储器</strong> (<mark>内存</mark>) 中进行排序。</p>
<ol start="2">
<li>外部排序法：</li>
</ol>
<p><strong>数据量过大</strong>，无法全部加载到内  存中，需要借助<strong>外部存储</strong> (<mark>文件等</mark>) 进行</p>
<p>排序。</p>
<ol start="3">
<li>常见的排序算法分类 (见下图):</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859572.png" alt=""></p>
<h3 id="算法的时间复杂度"><a class="markdownIt-Anchor" href="#算法的时间复杂度">#</a> 算法的时间复杂度</h3>
<p>度量一个程序 (算法) 执行时间的两种方法</p>
<ol>
<li>
<p>事后统计的方法<br>
这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</p>
</li>
<li>
<p>事前估算的方法<br>
通过分析某个算法的时间复杂度来判断哪个算法更优.</p>
</li>
</ol>
<h3 id="算法的时间复杂度-2"><a class="markdownIt-Anchor" href="#算法的时间复杂度-2">#</a> 算法的时间复杂度</h3>
<p>时间频度</p>
<p>Ø 基本介绍</p>
<p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T (n)。[举例说明]</p>
<p>Ø<strong> 举例说明 - 基本案例</strong></p>
<p>比如计算 1-100 所有数字之和，我们设计两种算法：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859900.png" alt=""></p>
<p>T(n)=n+1;</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859622.png" alt=""></p>
<p>T(n)=1；</p>
<p>Ø<strong> 举例说明 - 忽略常数项</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161859777.png" alt=""></p>
<p>Ø<strong> 举例说明 - 忽略低次项</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900511.png" alt=""></p>
<p>Ø<strong> 举例说明 - 忽略系数</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900231.png" alt=""></p>
<p><strong>时间复杂度</strong></p>
<ol>
<li>
<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T (n) 表示，若有某个辅助函数 f (n)，使得当 n 趋近于无穷大时，T (n) /f (n) 的极限值为不等于零的常数，则称 f (n) 是 T (n) 的同数量级函数。记作 T (n)=Ｏ( f (n) )，称Ｏ( f (n) ) 为算法的渐进时间复杂度，简称时间复杂度。</p>
</li>
<li>
<p>T (n) 不同，但时间复杂度可能相同。 如：T (n)=n²+7n+6 与 T (n)=3n²+2n+2 它们的 T (n) 不同，但时间复杂度相同，都为 O (n²)。</p>
</li>
<li>
<p>计算时间复杂度的方法：</p>
</li>
</ol>
<p>・用常数 1 代替运行时间中的所有加法常数 T (n)=n²+7n+6 =&gt; T (n)=n²+7n+1</p>
<p>・修改后的运行次数函数中，只保留最高阶项 T (n)=n²+7n+1 =&gt; T (n) = n²</p>
<p>・去除最高阶项的系数 T (n) = n²  =&gt; T (n) = n² =&gt; O (n²)</p>
<h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序">#</a> 冒泡排序</h3>
<p>基本介绍</p>
<p>冒泡排序（Bubble Sorting）的基本思想是：通过对待</p>
<p>排序序列从前向后（从下标较小的元素开始）, 依次比较</p>
<p>相邻元素的值，若发现逆序则交换，使值较大</p>
<p>的元素逐渐从前移向后部，就象水底下的气泡一样逐渐</p>
<p>向上冒。</p>
<p>因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下</p>
<p>来没有进行过交换，就说明序列有序，因此要在排序过程中设置</p>
<p>一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900791.png" alt=""></p>
<p>演示冒泡过程的例子 (图解)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900022.png" alt=""></p>
<p>冒泡排序应用实例</p>
<p>我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3, 9, -1, 10, -2  使用冒泡排序法将其排成一个从小到大的有序数列。</p>
<p>图解：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900920.png" alt=""></p>
<p>代码实现：</p>
<p>先将排序的结构拆分了写，步骤如下：</p>
<p>每次进行排序的时候都需要将长度 - 1 - n 因为排序后范围总是要缩小的否则就会一直来回的排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一趟排序结果：&quot;</span>+ Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span> - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二趟排序结果：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span> - <span class="number">2</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三趟排序结果：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化代码：将排序的过程结合为嵌套循环来完成冒泡排序：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//标识变量</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//冒泡排序 的时间复杂度为 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - i - <span class="number">1</span>;j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//如果进行过交换则将标识变量赋值为true</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;趟，的排序结果为: &quot;</span>+Arrays.toString(arr));</span><br><span class="line">            <span class="comment">//判断标识变量进行对应的操作</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="comment">//在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果发生过交换则进入else中，将flag重置进行下次判断</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序">#</a> 选择排序</h3>
<p><strong>基本介绍</strong></p>
<p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p><strong>选择排序思想</strong>:</p>
<p>选择排序（select sorting）也是一种简单的排序方法。它的<strong>基本思想</strong>是：第一次从 arr [0] <code>~</code> arr [n-1] 中选取最小值，与 arr [0] 交换，第二次从 arr [1] <code>~</code> arr [n-1] 中选取最小值，与 arr [1] 交换，第三次从 arr [2] <code>~</code> arr [n-1] 中选取最小值，与 arr [2] 交换，…，第 i 次从 arr [i-1]~arr [n-1] 中选取最小值，与 arr [i-1] 交换，…, 第 n-1 次从 arr [n-2]~arr [n-1] 中选取最小值，与 arr [n-2] 交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。</p>
<p><strong>选择排序思路分析图</strong> *:</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901514.png" alt=""><br>
101, 34, 119, 1</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">   <span class="comment">/*判断数组为空或为一个元素的情况，即边界检查*/</span></span><br><span class="line">   <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*每次要进行比较的两个数，的前面那个数的下标*/</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; </span><br><span class="line">      <span class="comment">//min变量保存该趟比较过程中，最小元素所对应的索引，</span></span><br><span class="line">      <span class="comment">//先假设前面的元素为最小元素</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">      <span class="comment">/*每趟比较，将前面的元素与其后的元素逐个比较*/</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">         <span class="comment">//如果后面的元素小，将后面元素的索引极为最小值的索引</span></span><br><span class="line">         <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//然后交换此次查找到的最小值和原始的最小值</span></span><br><span class="line">      swap(arr, i, minIndex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">   arr[i] = arr[j];</span><br><span class="line">   arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序的优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt;= right;i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[max] &lt; arr[i])</span><br><span class="line">                    max = i;</span><br><span class="line">                <span class="keyword">if</span>(arr[min] &gt; arr[i])</span><br><span class="line">                    min = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最大值放在最右端</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[max];</span><br><span class="line">            arr[max] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min == right)&#123;</span><br><span class="line">                min = max;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最下值放在最左端</span></span><br><span class="line">            temp = arr[min];</span><br><span class="line">            arr[min] = arr[left];</span><br><span class="line">            arr[left] = temp;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序">#</a> 插入排序</h3>
<p><strong>插入排序法介绍</strong>：</p>
<p>插入式排序属于内部排序法，是对于预排序的元素以插入的方式找寻元素的适当位置，以达到排序的目的。</p>
<p><strong>插入排序法思想</strong>:</p>
<p>插入排序（Insertion Sorting）的<strong>基本思想</strong>是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><strong>插入排序思路图</strong>：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901111.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] ar = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//需要使用j循环值来进行位置互换</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ar.length;i ++)&#123;</span><br><span class="line">        <span class="comment">//取一个值进行比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ar[i];</span><br><span class="line">        <span class="comment">//j = i - 1 循环0等于或到j的数值,j也就是i-1的值,判断是否满足交换条件执行则j-- </span></span><br><span class="line">        <span class="keyword">for</span>(j = i-<span class="number">1</span>;j &gt;= <span class="number">0</span> &amp;&amp; ar[j] &gt; tmp;j --)&#123;</span><br><span class="line">            <span class="comment">//将大的元素赋值到索引前</span></span><br><span class="line">            ar[j+<span class="number">1</span>] = ar[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素小的赋值到索引后,因为 j-- j循环变量在满足条件执行方法体时不会及时执行 j--</span></span><br><span class="line">        ar[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(ar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化 - 折半插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> j,low,mid,high,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="comment">//循环的起始数据</span></span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环的循环数值</span></span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//取第i个元素赋值到tmp中进行比较</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="comment">/*找到合适的插入位置high+1，如果中间位置元素</span></span><br><span class="line"><span class="comment">         *比要插入元素大，则查找区域向低半区移动，否</span></span><br><span class="line"><span class="comment">         *则向高半区移动</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//从前面的元素开始判断到temp的元素如果不满足则直接进行下一次循环</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="comment">/*每次执行将low与长度相加的值除2得出mid指针位置*/</span></span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//判断mid的索引位置的值 是否 大于temp的值</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; temp)&#123;</span><br><span class="line">                <span class="comment">//满足交换条件,指针位置-1,缩短判断范围</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不满足交换条件 指针位置+1,缩短判断范围</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*high+1后的元素后移*/</span></span><br><span class="line">        <span class="comment">//经过上面判断i-1为temp后一位的位置,从high循环到 i</span></span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>;j &gt;= high + <span class="number">1</span>;j --) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*将元素插入到指定位置*/</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化 - 路插入排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j, first, last, mid;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="comment">/*临时数组*/</span></span><br><span class="line"><span class="type">int</span>[] tempArr =<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">tempArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*first和last分别指临时数组tempArr中排好序的元素的第一个和最后一个位置*/</span></span><br><span class="line">first = last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">   <span class="comment">/*j 是调整系数*/</span></span><br><span class="line">   <span class="keyword">if</span>(first &gt; last)&#123;</span><br><span class="line">      j = len;        </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*tempArr中间元素的位置*/</span></span><br><span class="line">   mid = ((first+last+j)/<span class="number">2</span>)%len; </span><br><span class="line">   <span class="comment">/*arr[i]应该插入在tempArr的前半部分*/</span></span><br><span class="line">   <span class="keyword">if</span>(arr[i] &lt; tempArr[mid])&#123;      </span><br><span class="line">      <span class="comment">/*j指向tempArr数组中的第一个元素*/</span></span><br><span class="line">      j = first;</span><br><span class="line">      <span class="comment">/*first 前移，取余是为了实现循环数组效果*/</span></span><br><span class="line">      first = (first-<span class="number">1</span>+len)%len;  </span><br><span class="line">      <span class="comment">/*待插元素大于 j 所指元素*/</span></span><br><span class="line">      <span class="keyword">while</span>(arr[i] &gt; tempArr[j])&#123;    </span><br><span class="line">         <span class="comment">/*j 所指元素前移，取余是为了实现循环数组效果*/</span></span><br><span class="line">         tempArr[(j-<span class="number">1</span>+len)%len] = tempArr[j];  </span><br><span class="line">         <span class="comment">/*j 指向下一个元素*/</span></span><br><span class="line">         j = j+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*移动结束，待插元素插在tempArr[j]前*/</span></span><br><span class="line">      tempArr[(j-<span class="number">1</span>+len)%len] = arr[i];    </span><br><span class="line">      <span class="comment">/*arr[i]应该插入在tempArr的后半部分*/</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">/*j指向tempArr数组中的最后一个元素*/</span></span><br><span class="line">      j = last;</span><br><span class="line">      <span class="comment">/*last后移， 指向插入后的最后一个元素*/</span></span><br><span class="line">      last++;</span><br><span class="line">      <span class="comment">/*待插元素小于 j 所指元素*/</span></span><br><span class="line">      <span class="keyword">while</span>(arr[i] &lt; tempArr[j])&#123;  </span><br><span class="line">         <span class="comment">/*j 所指元素后移*/</span></span><br><span class="line">         tempArr[(j+<span class="number">1</span>)%len] = tempArr[j]; </span><br><span class="line">         <span class="comment">/*j 指向上一个元素*/</span></span><br><span class="line">         j = (j-<span class="number">1</span>+len)%len;         </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*移动结束，待插元素插在tempArr[j]后*/</span></span><br><span class="line">      tempArr[(j+<span class="number">1</span>)%len] = arr[i]; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*把在tempArr中排好序的元素依次赋给arr*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;                    </span><br><span class="line">   arr[i] = tempArr[(first+i)%len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序">#</a> 希尔排序</h3>
<p><strong>简单插入排序存在的问题</strong></p>
<p>我们看简单的插入排序可能存在的问题.</p>
<p>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1 (最小), 这样的过程是：</p>
<p 2,3,4,5,6,6=""></p>
<p 2,3,4,5,5,6=""></p>
<p 2,3,4,4,5,6=""></p>
<p 2,3,3,4,5,6=""></p>
<p 2,2,3,4,5,6=""></p>
<p 1,2,3,4,5,6=""></p>
<p><strong>结论</strong>：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p>
<p>希尔排序法介绍</p>
<p>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<p>希尔排序法基本思想</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</p>
<p>希尔排序法  的示意图</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901589.png" alt=""></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901412.png" alt=""></p>
<p>代码实现：</p>
<p><mark>交换法</mark>（效率较低）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] ar = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    art(ar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">art</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">//每次执行外循环将数组的 长度/2 分开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len/<span class="number">2</span>;gap &gt; <span class="number">0</span>;gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//从/2的长度开始循环数组全部从/2后的长度开始循环到数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap;i &lt; len;i++) &#123;</span><br><span class="line">            <span class="comment">//将从/2的长度开始进行遍历</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//判断循环 判断j是否大于等于0 和 数组前后元素的大小</span></span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                <span class="comment">//调用排序方法</span></span><br><span class="line">                sort(arr,j,j - gap);</span><br><span class="line">                <span class="comment">//当j-gap还是满足if判断条件那么就看第二个条件是否满足如果满足则再次进行交换位置</span></span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ar,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ar[b];</span><br><span class="line">    ar[b] = ar[a];</span><br><span class="line">    ar[a] = tmp;</span><br><span class="line">    System.out.println(Arrays.toString(ar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>移动法</mark>（效率比交换高很多很多）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len / <span class="number">2</span>;gap &gt; <span class="number">0</span>;gap = gap / <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> gap;i &lt; len;i ++)&#123;</span><br><span class="line">         <span class="comment">//使用插入排序的思路</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">         <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">         <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap])&#123;</span><br><span class="line">            arr[j] = arr[j - gap];</span><br><span class="line">            j -= gap;</span><br><span class="line">         &#125;</span><br><span class="line">         arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序">#</a> 快速排序</h3>
<p><strong>快速排序法介绍</strong>:</p>
<p>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p><strong>快速排序法示意图</strong>:</p>
<p>以每个递归分支的最后一个元素为基准进行排序</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902712.png" alt=""></p>
<p>以每个递归分支的最中间的元素为基准进行排序</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902376.png" alt=""></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> left;<span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> right;<span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时交换值变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot值小放到左边比pivot值大的放到右边</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; max)&#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找，找到大于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[low] &lt; pivot)&#123;</span><br><span class="line">                low += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在pivot的右边一直找，找到小于pivot值，才退出</span></span><br><span class="line">            <span class="keyword">while</span>(arr[max] &gt; pivot)&#123;</span><br><span class="line">                max -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果low &gt;= max说明pivot 的左右两边的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot的值，右边全部是大于等于pivot的值</span></span><br><span class="line">            <span class="keyword">if</span>(low &gt;= max)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[low];</span><br><span class="line">            arr[low] = arr[max];</span><br><span class="line">            arr[max] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[low] == pivot值 相等 则 max -- ，前移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[low] == pivot)&#123;</span><br><span class="line">                max -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[max] == pivot值 相等 则 low ++ ，后移</span></span><br><span class="line">            <span class="keyword">if</span>(arr[max] == pivot)&#123;</span><br><span class="line">                low += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果low == max,必须low ++ , max -- ,否则会出现堆栈溢出</span></span><br><span class="line">            <span class="keyword">if</span>(low == max)&#123;</span><br><span class="line">                low += <span class="number">1</span>;</span><br><span class="line">                max -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; max)&#123;</span><br><span class="line">                quickSort(arr,left,max);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">if</span>(right &gt; low)&#123;</span><br><span class="line">                quickSort(arr,low,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序">#</a> 归并排序</h3>
<p><strong>归并排序介绍</strong>:</p>
<p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分 (divide) 成一些小的问题然后递归求解，而治 (conquer) 的阶段则将分的阶段得到的各答案 &quot;修补&quot; 在一起，即分而治之)。</p>
<p><strong>归并排序思想示意图 1 - 基本思想</strong>:</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902386.png" alt=""></p>
<p><strong>说明</strong>:</p>
<p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。</p>
<p><strong>归并排序思想示意图 2 - 合并相邻有序子序列</strong>:</p>
<p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8] 和 [1,2,3,6] 两个已经有序的子序列，合并为最终序列 [1,2,3,4,5,6,7,8]，来看下实现步骤</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902315.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuibingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr= &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>,temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分+合方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr,mid + <span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;<span class="comment">//初始化i，左边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;<span class="comment">//初始化j，右边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * (一)</span></span><br><span class="line"><span class="comment">         * 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line"><span class="comment">         * 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果左边有序序列的当前元素，小于等于右边有序的当前元素</span></span><br><span class="line"><span class="comment">             * 即将左边的当前元素，拷贝到temp数组</span></span><br><span class="line"><span class="comment">             * 然后t ++ i ++</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * (二)</span></span><br><span class="line"><span class="comment">         * 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * (三)</span></span><br><span class="line"><span class="comment">         * 将temp数组的元素拷贝到arr</span></span><br><span class="line"><span class="comment">         * 注意：并不是每次都拷贝所有的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次合并tempLeft = 0, right = 1</span></span><br><span class="line"><span class="comment">         * 第二次合并tempLeft = 2 right = 3</span></span><br><span class="line"><span class="comment">         * 第三次合并tempLeft = 0 right = 3</span></span><br><span class="line"><span class="comment">         * 最后一次tempLeft = 0 right = 7</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(tempLeft &lt;= right)&#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序">#</a> 基数排序</h3>
<p><strong>基数排序 (桶排序) 介绍</strong>:</p>
<ol>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUYlQkElRTYlOTUlQjAlRTYlOEUlOTIlRTUlQkElOEYvNzg3NTQ5OA==">基</span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUYlQkElRTYlOTUlQjAlRTYlOEUlOTIlRTUlQkElOEYvNzg3NTQ5OA==">数排序</span>（radix sort）属于 “分配式排序”（distribution sort），又称 “桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlODMlRTclQjQlQTAlRTUlODglODYlRTklODUlOEQvMjEwNzQxOQ==">元素分配</span>至某些 “桶” 中，达到排序的作用</p>
</li>
<li>
<p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li>
<p>基数排序 (Radix Sort) 是<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC8zNjAyNzM3Lmh0bWw=">桶排序</span>的扩展</p>
</li>
<li>
<p>基数排序是 1887 年赫尔曼・何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
</li>
</ol>
<p><strong>基数排序基本思想</strong></p>
<ol>
<li>
<p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
</li>
<li>
<p>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</p>
</li>
</ol>
<p><strong>基数排序图文说明</strong></p>
<p>将数组 {53, 3, 542, 748, 14, 214} 使用基数排序，进行升序排序。</p>
<p>第 1 轮排序 [按照个位排序]:</p>
<p>说明： 事先准备 10 个数组 (10 个桶)， 0-9 分别对应 位数的 0-9</p>
<ol>
<li>将 各个数，按照个位大小 放入到 对应的 各个数组中</li>
<li>然后从 0-9 个数组 / 桶，依次，按照加入元素的先后顺序取出</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902994.png" alt=""></p>
<p>示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902405.png" alt=""></p>
<p>分解代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JichuSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>,<span class="number">3</span>,<span class="number">542</span>,<span class="number">748</span>,<span class="number">14</span>,<span class="number">214</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">         * 定义一个二维数组，表示10个桶，每个桶就是一个一维数组</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1.二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">         * 2.为了防止在放入数值的时候，数据溢出，则每个一维数组（桶），大小定义为arr.length</span></span><br><span class="line"><span class="comment">         * 3.名明确,基础排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">         * 可以这么理解:</span></span><br><span class="line"><span class="comment">         * 比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">            <span class="comment">//取出每个元素的个位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; bucketElementCounts.length;k ++)&#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入原数组</span></span><br><span class="line">            <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶（即第k个一维数组），放入</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; bucketElementCounts[k];l ++)&#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index ++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一轮排序结果：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//======================================</span></span><br><span class="line">        <span class="comment">//第二轮(针对十位进行排序)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">            <span class="comment">//取出每个元素的十位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; bucketElementCounts.length;k ++)&#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入原数组</span></span><br><span class="line">            <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶（即第k个一维数组），放入</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; bucketElementCounts[k];l ++)&#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index ++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二轮排序结果：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">        <span class="comment">//==========================================</span></span><br><span class="line">        <span class="comment">//第三轮(针对百位进行排序)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length;j ++)&#123;</span><br><span class="line">            <span class="comment">//取出每个元素的百位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">100</span> % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; bucketElementCounts.length;k ++)&#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入原数组</span></span><br><span class="line">            <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶（即第k个一维数组），放入</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; bucketElementCounts[k];l ++)&#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index ++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三轮排序结果：&quot;</span>+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规律：每轮求数值的位数值一直在改变其它不变</p>
<p>基数排序实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JichuSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//根据前面的推到过程，我们可以得到最终的基数排序代码</span></span><br><span class="line">        <span class="comment">//1.得到数组中最大的数的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];<span class="comment">//假设第一个元素就是最大为数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line"><span class="comment">         * 定义一个二维数组，表示10个桶，每个桶就是一个一维数组</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1.二维数组包含10个一维数组</span></span><br><span class="line"><span class="comment">         * 2.为了防止在放入数值的时候，数据溢出，则每个一维数组（桶），大小定义为arr.length</span></span><br><span class="line"><span class="comment">         * 3.名明确,基础排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line"><span class="comment">         * 可以这么理解:</span></span><br><span class="line"><span class="comment">         * 比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一轮（针对每个元素的个位进行排序处理）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素的个位的值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                <span class="comment">//如果桶中，有数据，我们才放入原数组</span></span><br><span class="line">                <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//循环该桶即第k个桶（即第k个一维数组），放入</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;轮排序结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用排序算法总结和对比"><a class="markdownIt-Anchor" href="#常用排序算法总结和对比">#</a> 常用排序算法总结和对比</h3>
<p>常用排序算法对比</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902636.png" alt=""></p>
<p><strong>相关术语解释</strong>：</p>
<ol>
<li>稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；</li>
<li>不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
<li><mark>n</mark>: 数据规模</li>
<li><mark>k</mark>: “桶” 的个数</li>
<li><mark>In-place</mark>: 不占用额外内存</li>
<li><mark>Out-place</mark>: 占用额外内存</li>
</ol>
<h2 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法">#</a> 查找算法</h2>
<p><strong>查找算法介绍</strong></p>
<p>在 java 中，我们常用的查找有四种:</p>
<ol>
<li>顺序 (线性) 查找</li>
<li>二分查找 / 折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ol>
<h3 id="线性查找算法"><a class="markdownIt-Anchor" href="#线性查找算法">#</a> 线性查找算法</h3>
<p><font style="color:red">要求数组是一个有序的数组</font>.</p>
<p>有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】  要求：如果找到了，就提示找到，并给出下标值。</p>
<p>思路：如果查找到全部符合条件的值。[思路分析.]</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902359.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lineSearch(arr, <span class="number">5</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lineSearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == value)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="二分查找算法"><a class="markdownIt-Anchor" href="#二分查找算法">#</a> 二分查找算法</h3>
<p><strong>二分查找</strong>：</p>
<p><font style="color:red">要求数组是一个有序的数组</font>.</p>
<p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示 &quot;没有这个数&quot;。</p>
<p>课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binary_search</span> &#123;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] ar = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> run(ar,<span class="number">8</span>);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> trans)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断 目标值是否小于索引0的值,目标值是否大于索引长度的值,长度</span></span><br><span class="line">        <span class="keyword">if</span>(trans &lt; nums[first] || trans &gt; nums[last] || first &gt; last)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断循环</span></span><br><span class="line">        <span class="keyword">while</span>(first &lt;= last)&#123;</span><br><span class="line">            <span class="comment">//将长度除2的值赋值给mid,起始位置,访问数组中间的数据</span></span><br><span class="line">            mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//判断数字是否小了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; trans)</span><br><span class="line">                <span class="comment">//如果小了则让last - 1然后再次除2判断数字的大小</span></span><br><span class="line">                last = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//else只执行一个结果</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//判断数字是否大了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; trans)</span><br><span class="line">                <span class="comment">//如果数字大了则first + 1然后再次除2判断数字的大了,每次都是一半一半的进行试探的判断</span></span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//else只执行一个结果</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//如果两个判断不满足则执行返回值当前的索引位置就是目标值</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果全程没有找到则返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chazhao01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">89</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        List&lt;Integer&gt; i1 = binarySearch1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;多个值的下标：&quot;</span>+i1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(value &gt; midValue)&#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; midValue)&#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(value &gt; midValue)&#123;<span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch1(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; midValue)&#123;<span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch1(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 思路分析</span></span><br><span class="line"><span class="comment">             * 1.在找到mid索引值，不要马上返回</span></span><br><span class="line"><span class="comment">             * 2.向mid索引值的左边扫描，将所有满足value的元素下标加入集合中</span></span><br><span class="line"><span class="comment">             * 3.向mid索引值的右边扫描，将所有满足value的元素下标加入集合中</span></span><br><span class="line"><span class="comment">             * 4.将集合返回</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//向mid索引值的左边扫描，将所有满足value的元素的下标加入集合中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || arr[temp] != value)&#123;<span class="comment">//结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，将temp放入到集合中</span></span><br><span class="line">                list.add(temp);</span><br><span class="line">                <span class="comment">//temp左移</span></span><br><span class="line">                temp -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; arr.length - <span class="number">1</span> || arr[temp] != value)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插值查找算法"><a class="markdownIt-Anchor" href="#插值查找算法">#</a> 插值查找算法</h3>
<p><strong>插值查找原理介绍</strong>:</p>
<ol>
<li>
<p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。</p>
</li>
<li>
<p>将折半查找中的求 mid 索引的公式，low 表示左边索引 left, high 表示右边索引 right.  key 就是前面我们讲的 findVal<br>
<img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902056.png" alt=""></p>
</li>
<li>
<p>int mid = low + (high - low)  <code>*</code>  (key - arr[low]) / (arr[high] -arr[low]) ;/<em> 插值索引</em> /<br>
 对应前面的代码公式：<br>
int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p>
</li>
<li>
<p>举例说明插值查找算法 1-100 的数组</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i ++)&#123;</span><br><span class="line">            arr[(i - <span class="number">1</span>)] += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(insertValuesearch(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>,<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 查找值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，返回对应下标，没有返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertValuesearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意：value &lt; arr[0] 和 value &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">         * 否则我们得到的mid可能越界</span></span><br><span class="line"><span class="comment">         * arr.length - 1 &lt; right 判断传入的right值是否大于了传入数组的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right || value &lt; arr[<span class="number">0</span>] || value &gt; arr[arr.length - <span class="number">1</span>] || arr.length - <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求mid的值 称为自适应写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &gt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向右边递归</span></span><br><span class="line">            <span class="keyword">return</span> insertValuesearch(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向左边递归</span></span><br><span class="line">            <span class="keyword">return</span> insertValuesearch(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:red">插入查找注意事项</font>：</p>
<ol>
<li>对于数据量较大，<strong>关键字分布比较均匀</strong>的查找表来说，采用<strong>插值查找</strong>，<strong> 速度较快</strong>.</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ol>
<h3 id="斐波那契黄金分割法查找算法"><a class="markdownIt-Anchor" href="#斐波那契黄金分割法查找算法">#</a> 斐波那契 (黄金分割法) 查找算法</h3>
<p><strong>斐波那契 (黄金分割法) 查找基本介绍</strong>:</p>
<ol>
<li>
<p>黄金分割点是指把一条<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQkElQkYlRTYlQUUlQjUvODY3OTgwMg==">线段</span>分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8wLjYxOA=="> 0.618</span>。由于按此比例设计的造型十分美丽，因此称为<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklQkIlODQlRTklODclOTElRTUlODglODYlRTUlODklQjIvMTE1ODk2">黄金分割</span>，也称为<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlQTQlOTYlRTYlQUYlOTQvNzU5MDkzOQ==">中外比</span>。这是一个神奇的数字，会带来意向不大的效果。</p>
</li>
<li>
<p>斐波那契数列  {1, 1, 2, 3, 5, 8, 13, 21, 34, 55} 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902110.png" alt=""></p>
<p>斐波那契 (黄金分割法) 查找算法</p>
<p><strong>斐波那契 (黄金分割法) 原理</strong>:</p>
<p>斐波那契查找原理与前两种相似，仅仅  改变了中间结点（mid）的位置，mid 不  再是中间或插值得到，而是位于黄金分  割点附近，即 mid=low+F (k-1)-1  （F 代表斐波那契数列），如下图所示<br>
对 F (k-1)-1 的理解：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902101.png" alt=""></p>
<ol>
<li>由斐波那契数列 F [k]=F [k-1]+F [k-2] 的性质，可以得到 （F [k]-1）=（F [k-1]-1）+（F [k-2]-1）+1 。该式说明：只要顺序表的长度为 F [k]-1，则可以将该表分成长度为 F [k-1]-1 和 F [k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F (k-1)-1</li>
<li>类似的，每一子段也可以用相同的方式分割</li>
<li>但顺序表长度 n 不一定刚好等于 F [k]-1，所以需要将原来的顺序表长度 n 增加至 F [k]-1。这里的 k 值只要能使得 F [k]-1 恰好大于或等于 n 即可，由以下代码得到，顺序表长度增加后，新增的位置（从 n+1 到 F [k]-1 位置），都赋为 n 位置的值即可。</li>
</ol>
<p><strong>斐波那契查找应用案例</strong>：</p>
<p>请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示 &quot;没有这个数&quot;。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonnacciSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fibSearch(arr, <span class="number">89</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;index : &quot;</span>+i);</span><br><span class="line">        System.out.println(Arrays.toString(fib()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为后面我们mid = low + f[k - 1] - 1;需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">     * 非递归方法得到一个斐波那契数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib()&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; maxSize;i ++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写斐波那契数列查找算法</span></span><br><span class="line"><span class="comment">     * 使用递归方式编写算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 我们需要查找的关键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示斐波那契数列分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存放mid的值</span></span><br><span class="line">        <span class="type">int</span>[] f = fib();</span><br><span class="line">        <span class="comment">//f[k] = 1,1,2,3,5,8 (8 - 1 = 7) ==&gt; false k == 5</span></span><br><span class="line">        <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>)&#123;</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为f[k]值可能大于a的长度，因此我们需要使用Arrays类，构造一个新数组，并指向a[]</span></span><br><span class="line"><span class="comment">         * 不足的部分会使用0填充</span></span><br><span class="line"><span class="comment">         * [1, 8, 10, 89, 1000, 1234, 0, 0]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(a,f[k]);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实际上需求使用a数组最后的数填充temp</span></span><br><span class="line"><span class="comment">         * 举例：</span></span><br><span class="line"><span class="comment">         * temp = &#123;1,8, 10, 89, 1000, 1234&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234,1234,1234&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>;i &lt; temp.length;i ++)&#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用while来循环处理，找到我们的数key</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp	[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 为什么是 k--</span></span><br><span class="line"><span class="comment">                 * 说明：</span></span><br><span class="line"><span class="comment">                 * 1.全部元素 = 前面的元素 + 后面元素</span></span><br><span class="line"><span class="comment">                 * 2.f[k] = f[k - 1] + f[k - 2];</span></span><br><span class="line"><span class="comment">                 * 因为前面有f[k - 1]个元素，所以可以继续拆分f[k - 1] = f[k - 2] + f[k - 3]</span></span><br><span class="line"><span class="comment">                 * 即在f[k - 1]的前面继续查找k --</span></span><br><span class="line"><span class="comment">                 * 即下次循环mid = f[k - 1 - 1] - 1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp[mid])&#123;<span class="comment">//我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 为什么是 k -= 2;</span></span><br><span class="line"><span class="comment">                 * 说明：</span></span><br><span class="line"><span class="comment">                 * 1.全部元素 = 前面元素+后面元素</span></span><br><span class="line"><span class="comment">                 * 2.f[k] = f[k - 1]  + f[k - 2]</span></span><br><span class="line"><span class="comment">                 * 3.因为后面我们有f[k - 2]所以可以继续拆分f[k - 1] = f[k - 3] + f[k - 4]</span></span><br><span class="line"><span class="comment">                 * 4.即在f[k - 2]的前面进行查找k -= 2</span></span><br><span class="line"><span class="comment">                 * 5.即下次循环mid = f[k - 1 - 2] - 1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span>(mid &lt;= high)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表">#</a> 哈希表</h2>
<p><strong>看一个实际需求，google 公司的一个上机题</strong>:</p>
<p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入 (id, 性别，年龄，住址…), 当输入该员工的 id 时，要求查找到该员工的 所有信息.</p>
<p>要求：不使用数据库，尽量节省内存，速度越快越好  =&gt;  <mark>哈希表</mark> (散列)</p>
<p><strong>哈希表的基本介绍</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQTMlRTUlODglOTclRTglQTElQTg=">散列表</span>（Hash table，也叫<strong>哈希表</strong>），是根据关键码值 (Key value) 而直接进行访问的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTclQkIlOTMlRTYlOUUlODQvMTQ1MA==">数据结构</span>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQTMlRTUlODglOTclRTUlODclQkQlRTYlOTUlQjA=">散列函数</span>，存放记录的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTclQkIlODQ=">数组</span>叫做<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQTMlRTUlODglOTclRTglQTElQTg=">散列</span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQTMlRTUlODglOTclRTglQTElQTg=">表</span>。</p>
<p>15  111 % 15</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903974.png" alt=""></p>
<p><strong>哈希表 (散列)- 应用实例</strong></p>
<p><strong>google 公司的一个上机题</strong>:</p>
<p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入 (id, 性别，年龄，名字，住址…), 当输入该员工的 id 时，要求查找到该员工的 所有信息.</p>
<p>要求:</p>
<p>不使用数据库，速度越快越好 =&gt; <mark>哈希表</mark> (散列)</p>
<p>添加时，保证按照 id 从低到高插入  [课后思考：如果 id 不是从 低到高插入，但要求各条链表仍是从低到高，怎么解决？]</p>
<ol>
<li>使用链表来实现哈希表，该链表不带表头  [即：链表的第一个结点就存放雇员信息]</li>
<li>思路分析并画出示意图</li>
<li>代码实现 [增删改查 (显示所有员工，按 id 查询)]</li>
</ol>
<p>示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903704.png" alt=""></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">HashTable</span> <span class="variable">hashTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;l(list) 查看所有雇员信息&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add) 添加雇员信息到链表&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(select) 根据id查找指定雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d(delet) 根据id删除指定雇员信息,并返回信息&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;D(delet) 根据id删除指定雇员信息&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit) 退出&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">            ch = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入需要查找的雇员id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    hashTable.findEmpById(id1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                    hashTable.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入名称&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(id,name);</span><br><span class="line">                    hashTable.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请输入要删除的雇员id&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                        <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> hashTable.delEmp(id2);</span><br><span class="line">                        System.out.printf(<span class="string">&quot;&gt;&gt;&gt;\tData:\t%s\n&quot;</span>,emp1);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请输入要删除的雇员id&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">vlaue</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                        hashTable.delEmp01(vlaue);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;选择存在项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HashTable管理多条链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="comment">//表示共有多少条链表(链表的大小)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//构造器，初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTable</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化size值</span></span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化数组大小</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//TODO 注意: 每一个链表都需要初始化否则报错空指针异常</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id，得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[num - <span class="number">1</span>].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的链表(遍历HashTable)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数，使用一个简单取模法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查找雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedListArray[num - <span class="number">1</span>].findById(id);</span><br><span class="line">        <span class="keyword">if</span>(emp != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;在第%d个链表中查找到 的雇员信息如下：\n&gt;&gt;&gt; id: %d\n&gt;&gt;&gt; name: %s&quot;</span>,num,emp.id,emp.name+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抱歉&gt;&quot;</span>+num+<span class="string">&quot;&lt;链表中没有找到任何信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">delEmp</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">del</span> <span class="operator">=</span> empLinkedListArray[num - <span class="number">1</span>].del(id);</span><br><span class="line">        <span class="keyword">return</span> del;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delEmp01</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        empLinkedListArray[num - <span class="number">1</span>].del01(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//表示链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp，因此我们这个链表的head是直接指向第一个Emp</span></span><br><span class="line">    <span class="keyword">private</span> Emp head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加雇员到链表</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.假设，当添加雇员时，id是自增长，即id的分配总是从小到大</span></span><br><span class="line"><span class="comment">     * 因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助指针，帮助定位到最后</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//说明到链表最后</span></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//指针后移</span></span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时直接将tmp加入到链表即可</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历链表的雇员信a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&gt;&quot;</span>+(no + <span class="number">1</span>)+<span class="string">&quot;&lt;个链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*-==第&gt;&quot;</span>+(no + <span class="number">1</span>)+<span class="string">&quot;&lt;个链表中的雇员的信息为==-*&quot;</span>);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;&gt;&gt;&gt; id: %d \n&gt;&gt;&gt; name: %s&quot;</span>,curEmp.id,curEmp.name+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="comment">//判断是否遍历到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//指针后移</span></span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查找雇员信息</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id == id)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> curEmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除雇员,并返回删除的雇员信息</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">del</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+id+<span class="string">&quot;&lt;链表为空删除无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值指针</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//记录上一个位置指针</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id == id)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curEmp == <span class="literal">null</span>)&#123;</span><br><span class="line">                curEmp = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前节点赋值给pre</span></span><br><span class="line">            pre = curEmp;</span><br><span class="line">            <span class="comment">//curEmp节点向后移动</span></span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前节点是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(curEmp == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断头节点是否和当前节点相同</span></span><br><span class="line">        <span class="keyword">if</span>(head == curEmp)&#123;</span><br><span class="line">            <span class="comment">//将curEmp.next元素赋值给头节点</span></span><br><span class="line">            head = curEmp.next;</span><br><span class="line">            <span class="keyword">return</span> curEmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将赋值的元素再赋值给pre的next</span></span><br><span class="line">        pre.next = curEmp.next;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del01</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+id+<span class="string">&quot;&lt;链表为空删除无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id == id)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curEmp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该&quot;</span>+id+<span class="string">&quot;雇员删除成功&quot;</span>);</span><br><span class="line">            <span class="comment">//判断下一个next节点是否为null</span></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//如果下一个next就是null那么就说明了这是第一个元素直接将头元素赋值为null即可</span></span><br><span class="line">                head = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//否则将下一个元素赋值为null</span></span><br><span class="line">                curEmp.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您输入的雇员可能本来就不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树结构基础部分"><a class="markdownIt-Anchor" href="#树结构基础部分">#</a> 树结构基础部分</h2>
<h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h3>
<p><strong>为什么需要树这种数据结构</strong></p>
<ol>
<li>数组存储方式的分析<br>
<strong>优点</strong>：通过<mark>下标方式访问元素</mark>，速度快。对于有序数组，还可使用<mark>二分查找提高检索速度</mark>。<br>
<strong>缺点</strong>：如果要检索具体某个值，或者<mark>插入值 (按一定顺序) 会整体移动</mark>，效率较低 [示意图]。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903674.png" alt=""></p>
<ol start="2">
<li>链式存储方式的分析<br>
<strong>优点</strong>：在一定程度上对数组存储方式有优化 (比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<br>
<strong>缺点</strong>：在进行检索时，效率仍然较低，比如 (检索某个值，需要从头节点开始遍历)</li>
<li>【示意图】</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903376.png" alt=""></p>
<ol start="3">
<li>树存储方式的分析<br>
能提高数据存储，读取的效率，比如利用 二叉排序树 (Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。【示意图，后面详讲】<br>
<strong>案例</strong>: [7, 3, 10, 1, 5, 9, 12]</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903631.png" alt=""></p>
<h4 id="树的常用术语"><a class="markdownIt-Anchor" href="#树的常用术语">#</a> 树的常用术语：</h4>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903841.png" alt=""></p>
<p>树的常用术语 (结合示意图理解):</p>
<ol>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点 (没有子节点的节点)</li>
<li>节点的权 (节点值)</li>
<li>路径 (从 root 节点找到该节点的路线）</li>
<li>层</li>
<li>子树</li>
<li>树的高度 (最大层数)</li>
<li>森林：多颗子树构成森林</li>
</ol>
<p><strong>二叉树的概念</strong></p>
<ol>
<li>树有很多种，<mark>每个节点最多只能有两个子节点</mark>的一种形式<mark>称为二叉树</mark>。</li>
<li>二叉树的<mark>子节点</mark>分为<mark>左节点</mark>和<mark>右节点</mark>。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903760.png" alt=""></p>
<p><strong>二叉树的概念</strong></p>
<ol start="3">
<li>如果该二叉树的所有<mark>叶子节点都在最后一层</mark>，并且结点总数 = 2^n -1 , n 为层数，则我们称为<mark>满二叉树</mark>。</li>
<li>如果该二叉树的所有<mark>叶子节点都在最后一层</mark>或者<mark>倒数第二层</mark>，<mark>而且</mark><mark>最后一层的叶子节点在左边连续</mark>，<mark>倒数第二层的叶子节点在右边连续</mark>，我们称为<mark>完全二叉树</mark>。<br>
我们重点讲解一下二叉树的<strong>前序遍历</strong>，<strong>中序遍历</strong>和<strong>后序遍历</strong>。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903921.png" alt=""></p>
<h4 id="二叉树遍历应用实例前序中序后序"><a class="markdownIt-Anchor" href="#二叉树遍历应用实例前序中序后序">#</a> 二叉树遍历应用实例 (前序，中序，后序)</h4>
<p><strong>二叉树遍历的说明</strong></p>
<p>使用前序，中序和后序对下面的二叉树进行遍历.</p>
<p><mark>前序遍历</mark>：先输出父节点，再遍历左子树和右子树</p>
<p><mark>中序遍历</mark>：先遍历左子树，再输出父节点，再遍历右子树</p>
<p><mark>后序遍历</mark>：先遍历左子树，再遍历右子树，最后输出父节点</p>
<p><mark>小结</mark>：看输出父节点的顺序，就确定是前序，中序还是后序</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903028.png" alt=""></p>
<p><strong>要求如下</strong>：</p>
<ol>
<li>前上图的 3 号节点 “卢俊”  , 增加一个左子节点 [5, 关胜]</li>
<li>使用前序，中序，后序遍历，请写出各自输出的顺序是什么？</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903018.png" alt=""></p>
<p><strong>输出顺序思路</strong>：</p>
<blockquote>
<p>前序：中，左，右 -&gt; 父节点 (1) &gt; 左 (2)[左节点没有右节点就到下一个旁边的] &gt; 右 (3)[先输出父节点，然后左节点和右节点] &gt; 左 (5) &gt; 右 (4)<br>
 最终结果：1，2，3，5，4</p>
<p>中序：左，中，右 -&gt; 左节点 (2)[没有左右节点] &gt; 父节点 (1) &gt; 左节点 (5)[3 是父节点它的左节点是 3] &gt; 父节点 (3) &gt; 右节点 (4)<br>
 最终结果：2，1，5，3，4</p>
<p>后序：左，右，中 -&gt; 左节点 (2)[没有左右节点到旁边节点] &gt; 3 节点的左节点 (5)[节点 3 是父节点先输出左节点 5] &gt; 3 节点的有节点 (4) &gt; 父节点 (3) &gt; 父节点 (1)<br>
 最终结果：2，5，4，3，1</p>
</blockquote>
<p>代码实现：</p>
<p>测试前序，中序，后序的输出顺序的代码案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树(后面使用递归方式创建二叉树)</span></span><br><span class="line">        root.setLeft(node);</span><br><span class="line">        root.setRight(node1);</span><br><span class="line">        node1.setRight(node2);</span><br><span class="line">        node1.setLeft(node3);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);<span class="comment">//1,2,3,5,4</span></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();<span class="comment">//2,1,3,5,4</span></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();<span class="comment">//5,4,3,2,1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//定义BinaryTree二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历，遍历是从根节点(root)开始的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树-查找指定节点"><a class="markdownIt-Anchor" href="#二叉树-查找指定节点">#</a> 二叉树 -<mark> 查找指定节点</mark></h4>
<p>要求</p>
<ol>
<li>请编写<strong>前序查找</strong>，<strong>中序查找</strong>和<strong>后序查找</strong>的<strong>方法</strong></li>
<li>并分别使用<strong>三种查找方式</strong>，<strong>查找 heroNode = 5</strong> 的节点</li>
<li>并<strong>分析各种查找方式</strong>，分别<strong>比较了多少次</strong></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树(后面使用递归方式创建二叉树)</span></span><br><span class="line">        root.setLeft(node);</span><br><span class="line">        root.setRight(node1);</span><br><span class="line">        node1.setRight(node2);</span><br><span class="line">        node1.setLeft(node3);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);<span class="comment">//1,2,3,5,4</span></span><br><span class="line"><span class="comment">//        binaryTree.preOrder();</span></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line"><span class="comment">//        binaryTree.infixOrder();//2,1,3,5,4</span></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line"><span class="comment">//        binaryTree.postOrder();//5,4,3,2,1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------前序遍历方式-----------------&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> binaryTree.preOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(resNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为%d的信息&quot;</span>,resNode.getNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------中序遍历方式-----------------&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode1</span> <span class="operator">=</span> binaryTree.infixOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(resNode1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为%d的信息&quot;</span>,resNode.getNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------后序遍历方式-----------------&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode2</span> <span class="operator">=</span> binaryTree.postOrderSearch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(resNode2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号为%d的信息&quot;</span>,resNode.getNo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//定义BinaryTree二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历，遍历是从根节点(root)开始的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countPre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countInfix</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countPost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回该Node，如果没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        countPre++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入前序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countPre);</span><br><span class="line">        <span class="comment">//比较当前节点是不是要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">         * 2.如果做递归前序查找，找到节点，则返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            heroNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明左子树找到</span></span><br><span class="line">        <span class="keyword">if</span>(heroNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            heroNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空，如果不为空则递归向左子节点遍历查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countInfix ++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入中序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countInfix);</span><br><span class="line">        <span class="comment">//判断当前节点是否 为需要查找的</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空，如果不为空则递归向右子节点遍历查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无论是否为空 都要返回递归节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断节点不为空则返回</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countPost ++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入后序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countPost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为需要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-----------------前序遍历方式-----------------</span><br><span class="line">进入前序遍历~~~	一共遍历了&gt;	1	&lt;次</span><br><span class="line">进入前序遍历~~~	一共遍历了&gt;	2	&lt;次</span><br><span class="line">进入前序遍历~~~	一共遍历了&gt;	3	&lt;次</span><br><span class="line">进入前序遍历~~~	一共遍历了&gt;	4	&lt;次</span><br><span class="line">查找到的信息为 [↓]</span><br><span class="line">&gt;&gt;&gt;		id:	5</span><br><span class="line">&gt;&gt;&gt;		name:	关胜</span><br><span class="line">-----------------中序遍历方式-----------------</span><br><span class="line">进入中序遍历~~~	一共遍历了&gt;	1	&lt;次</span><br><span class="line">进入中序遍历~~~	一共遍历了&gt;	2	&lt;次</span><br><span class="line">进入中序遍历~~~	一共遍历了&gt;	3	&lt;次</span><br><span class="line">查找到的信息为 [↓]</span><br><span class="line">&gt;&gt;&gt;		id:	5</span><br><span class="line">&gt;&gt;&gt;		name:	关胜</span><br><span class="line">-----------------后序遍历方式-----------------</span><br><span class="line">进入后序遍历~~~	一共遍历了&gt;	1	&lt;次</span><br><span class="line">进入后序遍历~~~	一共遍历了&gt;	2	&lt;次</span><br><span class="line">查找到的信息为 [↓]</span><br><span class="line">&gt;&gt;&gt;		id:	5</span><br><span class="line">&gt;&gt;&gt;		name:	关胜</span><br></pre></td></tr></table></figure>
<p><strong>分析结果</strong>：前序查找次数：4 ，中序查找次数：3 ，后序查找次数：2</p>
<h4 id="二叉树-删除节点"><a class="markdownIt-Anchor" href="#二叉树-删除节点">#</a> 二叉树 -<mark> 删除节点</mark></h4>
<p>要求：</p>
<ol>
<li>如果删除的节点是叶子节点，则删除该节点。</li>
<li>如果删除的节点是非叶子节点，则删除该子树。</li>
<li>测试，删除掉 5 号叶子节点和 3 号子树。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630120206935.png" alt="image-20230630120206935"></p>
<p>完成删除的思路分析：</p>
<p>二叉树 - 删除节点</p>
<p>思考题 (课后练习)</p>
<p>如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，<strong>需要指定规则</strong>，<strong> 假如规定如下</strong>:</p>
<ol>
<li>如果该非叶子节点 A 只有一个子节点 B，则子节点 B 替代节点 A</li>
<li>如果该非叶子节点 A 有左子节点 B 和右子节点 C，则让左子节点 B 替代节点 A。</li>
</ol>
<p>思路：</p>
<blockquote>
<p>首先先处理：</p>
<p>考虑如果树是空树 root，如果只有一个 root 节点，则等价将二叉树置空</p>
</blockquote>
<p>然后进行下面步骤：</p>
<ol>
<li>因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点。</li>
<li>如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将 <code>this.left = null;</code>  并且就返回<sup> `return;`</sup>(结束递归删除)</li>
<li>如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将 <code>this.right = null;</code>  并且就返回<sup> `return;`</sup>(结束递归删除)</li>
<li>如果第 2 和第 3 步没有删除节点，那么我们就需要向左子树进行递归删除</li>
<li>如果第 4 步也没有删除节点，则应当向右子树进行递归删除</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树(后面使用递归方式创建二叉树)</span></span><br><span class="line">        root.setLeft(node);</span><br><span class="line">        root.setRight(node1);</span><br><span class="line">        node1.setRight(node2);</span><br><span class="line">        node1.setLeft(node3);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">        //测试</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;前序遍历&quot;);//1,2,3,5,4</span></span><br><span class="line"><span class="comment">        binaryTree.preOrder();</span></span><br><span class="line"><span class="comment">        //测试</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">        binaryTree.infixOrder();//2,1,3,5,4</span></span><br><span class="line"><span class="comment">        //测试</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;后序遍历&quot;);</span></span><br><span class="line"><span class="comment">        binaryTree.postOrder();//5,4,3,2,1</span></span><br><span class="line"><span class="comment">        TODO */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------前序遍历方式-----------------&quot;);</span></span><br><span class="line"><span class="comment">        HeroNode resNode = binaryTree.preOrderSearch(5);</span></span><br><span class="line"><span class="comment">        if(resNode != null)&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;,resNode.getNo(),resNode.getName());</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;没有找到编号为%d的信息&quot;,resNode.getNo());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------中序遍历方式-----------------&quot;);</span></span><br><span class="line"><span class="comment">        HeroNode resNode1 = binaryTree.infixOrderSearch(5);</span></span><br><span class="line"><span class="comment">        if(resNode1 != null)&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;,resNode.getNo(),resNode.getName());</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;没有找到编号为%d的信息&quot;,resNode.getNo());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------后序遍历方式-----------------&quot;);</span></span><br><span class="line"><span class="comment">        HeroNode resNode2 = binaryTree.postOrderSearch(5);</span></span><br><span class="line"><span class="comment">        if(resNode2 != null)&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;查找到的信息为 [↓]\n&gt;&gt;&gt;\t\tid:\t%d\n&gt;&gt;&gt;\t\tname:\t%s\n&quot;,resNode.getNo(),resNode.getName());</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">            System.out.printf(&quot;没有找到编号为%d的信息&quot;,resNode.getNo());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        TODO */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* TODO</span></span><br><span class="line"><span class="comment">        //测试删除节点</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------删除前，前序遍历情况-----------------&quot;);</span></span><br><span class="line"><span class="comment">        binaryTree.preOrder();//1,2,3,5,4</span></span><br><span class="line"><span class="comment">        binaryTree.delNode(5);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------删除后，前序遍历情况-----------------&quot;);</span></span><br><span class="line"><span class="comment">        binaryTree.preOrder();//1,2,3,4</span></span><br><span class="line"><span class="comment">        TODO */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------删除前，前序遍历情况-----------------&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();<span class="comment">//1,2,3,5,4</span></span><br><span class="line">        binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------删除后，前序遍历情况-----------------&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();<span class="comment">//1,2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//定义BinaryTree二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果只有一个root节点，这里立即判断root是不是就是要删除节点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.root.getNo() == no)&#123;</span><br><span class="line">                <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//递归删除</span></span><br><span class="line">                <span class="built_in">this</span>.root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历，遍历是从根节点(root)开始的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.postOrderSearch(no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countPre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countInfix</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countPost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树后序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回该Node，如果没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        countPre++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入前序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countPre);</span><br><span class="line">        <span class="comment">//比较当前节点是不是要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.判断当前节点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line"><span class="comment">         * 2.如果做递归前序查找，找到节点，则返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            heroNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明左子树找到</span></span><br><span class="line">        <span class="keyword">if</span>(heroNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            heroNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空，如果不为空则递归向左子节点遍历查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countInfix ++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入中序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countInfix);</span><br><span class="line">        <span class="comment">//判断当前节点是否 为需要查找的</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空，如果不为空则递归向右子节点遍历查找</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无论是否为空 都要返回递归节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//判断左子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断节点不为空则返回</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断右子节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countPost ++;</span><br><span class="line">        System.out.printf(<span class="string">&quot;进入后序遍历~~~\t一共遍历了&gt;\t%d\t&lt;次\n&quot;</span>,countPost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否为需要查找的节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.no == no)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归删除节点</span></span><br><span class="line"><span class="comment">     * 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">     * 2.如果删除的节点是非叶子结点，则删除该子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         * 1.因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点</span></span><br><span class="line"><span class="comment">         * 2.如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left = null;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">         * 3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right = null;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">         * 4.如果第2和第3步没有删除节点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">         * 5.如果第4步也没有删除节点，则应当向右子树进行递归删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">// 2.如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left = null;并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right = null;并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.如果第2和第3步没有删除节点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 5.如果第4步也没有删除节点，则应当向右子树进行递归删除</span></span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码讲解：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630174738464.png" alt="image-20230630174738464"></p>
<h3 id="顺序存储二叉树"><a class="markdownIt-Anchor" href="#顺序存储二叉树">#</a> <mark>顺序存储</mark>二叉树</h3>
<p><strong>基本说明</strong>：</p>
<p>从数据存储来看，<mark>数组存储方式</mark>和<mark>树存储方式</mark>可以<mark>相互转换</mark>，即<mark>数组可以转换成树</mark>，<mark>树也可以转换成数组</mark>，看下图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630192358216.png" alt="image-20230630192358216"></p>
<p><strong>概述</strong>：</p>
<p>顺序存储使用<mark>数组的形式实现</mark>；由于<mark>非完全二叉树会导致数组中出现空缺</mark>，<mark>有的位置不能填上数字</mark>，所以顺序存储二叉树通常情况下只考虑<mark>完全二叉树</mark>。</p>
<p><strong>原理</strong>：</p>
<p><mark>顺序存储在数组中</mark>是按照<mark>第一层第二层依次往下存储</mark>的，遍历方式也有<mark>前序遍历</mark>，<mark>中序遍历</mark>，<mark>后序遍历</mark>。</p>
<p><strong>要求</strong>：</p>
<ol>
<li>上图的二叉树的节点，要求以数组的方式来存放 arr:[1,2,3,4,5,6]</li>
<li>要求在遍历数组 arr 时，仍然可以以  <mark>前序遍历</mark>，<mark>中序遍历</mark>，<mark>后序遍历</mark>的方式完成节点的遍历</li>
</ol>
<p><strong>顺序存储二叉树的特点</strong>：</p>
<ol>
<li><strong style="color:red">顺序二叉树通常只考虑</strong><mark>完全二叉树</mark></li>
<li>第 n 个元素的左子节点为 <code>2*n+1</code></li>
<li>第 n 个元素的右子节点为 <code>2*n+2</code></li>
<li>第 n 个元素的父节点为 <code>(n-1)/2</code></li>
<li>n：表示二叉树中的第几个元素的<mark>下标</mark>（<mark>按 0 开始编号如下图所示</mark>）</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630192711961.png" alt="image-20230630192711961"></p>
<p>对上述的详细解释：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630193107449.png" alt="image-20230630193107449"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/6/3019:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">ArrayBinaryTree</span> <span class="variable">arrayBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBinaryTree</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序&quot;</span>);</span><br><span class="line">        arrayBinaryTree.preOrder();<span class="comment">//1,2,4,5,3,6,7</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序&quot;</span>);</span><br><span class="line">        arrayBinaryTree.infixOrder();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序&quot;</span>);</span><br><span class="line">        arrayBinaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//存储数据节点的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重载preOrder方法为了调用方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示数组的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\t&quot;</span>,arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//顺序二叉树中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">		 <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            infixOrder((<span class="number">2</span> * index + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//输出节点</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\t&quot;</span>,arr[index]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length)&#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序二叉树后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length)&#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出节点</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\t&quot;</span>,arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>无论是 前序遍历，中序遍历，后序遍历，它们的索引都对应那个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---------------------前序遍历---------------------</span><br><span class="line">&gt;&gt;&gt; 当前的下标为0	元素为:1</span><br><span class="line">&gt;&gt;&gt; 当前的下标为1	元素为:2</span><br><span class="line">&gt;&gt;&gt; 当前的下标为3	元素为:4</span><br><span class="line">&gt;&gt;&gt; 当前的下标为4	元素为:5</span><br><span class="line">&gt;&gt;&gt; 当前的下标为2	元素为:3</span><br><span class="line">&gt;&gt;&gt; 当前的下标为5	元素为:6</span><br><span class="line">&gt;&gt;&gt; 当前的下标为6	元素为:7</span><br><span class="line">---------------------中序遍历---------------------</span><br><span class="line">&gt;&gt;&gt; 当前的下标为3	元素为:4</span><br><span class="line">&gt;&gt;&gt; 当前的下标为1	元素为:2</span><br><span class="line">&gt;&gt;&gt; 当前的下标为4	元素为:5</span><br><span class="line">&gt;&gt;&gt; 当前的下标为0	元素为:1</span><br><span class="line">&gt;&gt;&gt; 当前的下标为5	元素为:6</span><br><span class="line">&gt;&gt;&gt; 当前的下标为2	元素为:3</span><br><span class="line">&gt;&gt;&gt; 当前的下标为6	元素为:7</span><br><span class="line">---------------------后序遍历---------------------</span><br><span class="line">&gt;&gt;&gt; 当前的下标为3	元素为:4</span><br><span class="line">&gt;&gt;&gt; 当前的下标为4	元素为:5</span><br><span class="line">&gt;&gt;&gt; 当前的下标为1	元素为:2</span><br><span class="line">&gt;&gt;&gt; 当前的下标为5	元素为:6</span><br><span class="line">&gt;&gt;&gt; 当前的下标为6	元素为:7</span><br><span class="line">&gt;&gt;&gt; 当前的下标为2	元素为:3</span><br><span class="line">&gt;&gt;&gt; 当前的下标为0	元素为:1</span><br></pre></td></tr></table></figure>
<h3 id="线索化二叉树"><a class="markdownIt-Anchor" href="#线索化二叉树">#</a> <mark>线索化</mark>二叉树</h3>
<p><strong>先看一个问题</strong>：</p>
<p>将数列 {1,3,6,8,10,14} 构建成一颗二叉树，n<sup> 数组长度</sup> + 1=7</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230630211156278.png" alt="image-20230630211156278"></p>
<p><strong>问题分析</strong>：</p>
<ol>
<li 8,3,10,1,14,6="">当我们对上面的二叉树进行中序遍历时，数列为</li>
<li>但是 6,8,10,14 这几个节点的 左右指针，并没有完全的利用上</li>
<li>如果我们希望充分的利用各个节点的左右指针，让各个节点可以指向自己的前后节点，怎么办？</li>
<li>解决方案 - <mark>线索化二叉树</mark></li>
</ol>
<p><strong>线索化二叉树基本介绍</strong></p>
<ol>
<li>
<p>n 个节点的二叉链表中含有 n<sup> 数组元素个数</sup> + 1 [公式 2n-(n-1)=n+1] 个<mark>空指针域</mark>。利用<mark>二叉链表中</mark>的<mark>空指针域</mark>，存放指向<font style="color:skyblue">该节点</font>在<font style="color:red">某种遍历次序</font>下的<mark>前驱</mark>和<mark>后续</mark>节点的指针 (这种附加的指针称为 “<mark>线索</mark>”)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230701100223283.png" alt="image-20230701100223283"></p>
</li>
<li>
<p>这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong> (Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为<mark>前序线索二叉树</mark>，<mark>中序线索二叉树</mark>，<mark>后序线索二叉树</mark> <strong>三种</strong>。</p>
</li>
<li>
<p>一个节点的<mark>前</mark>一个节点，称为<mark>前驱</mark>节点</p>
</li>
<li>
<p>一个节点的<mark>后</mark>一个节点，称为<mark>后继</mark>节点</p>
</li>
</ol>
<p><strong>线索二叉树引用案例</strong></p>
<p 8,3,10,1,14,6=""><strong>应用案例说明</strong>：将下面的二叉树，进行<strong>中序线索二叉树</strong>。中序遍历的数列为</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230701101834786.png" alt="image-20230701101834786"></p>
<p><strong>思路分析</strong>：</p>
<p 8,3,10,1,14,6="">中序遍历的结果：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230701101932874.png" alt="image-20230701101932874"></p>
<ul>
<li>8 的后继节点为 3</li>
<li>3 由于 <strong>左右节点都有元素，不能线索化</strong></li>
<li>10 的前驱节点为 3 ，后继节点为 1</li>
<li>1 不能线索化<sup> root 节点</sup></li>
<li>14 的前驱节点为 1，后继节点为 6</li>
<li>6 有左节点，有节点没有元素，不能线索化</li>
</ul>
<p><font style="color:red"><strong>引出问题</strong></font>：根据中序遍历结果：{8,3,10,1,14,6} 在图中 1 的前驱是 3 后继是 6 可是中序遍历的<mark>结果不一样</mark></p>
<p><strong>说明：当线索化二叉树后，Node 节点的 属性 left 和 right，有如下情况</strong>：</p>
<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点，比如①节点 left 指向的左子树，而⑩节点的 left 指向的就是前驱节点</li>
<li>right 指向的是右子树，也可能是指向后继节点，比如 ①节点 right 指向的是右子树，而⑩节点的 right 指向的是后继节点</li>
</ol>
<p><strong>代码实现</strong>：</p>
<p><strong>下面的代码，有几个地方需要注意</strong>：</p>
<ul>
<li>
<p>HeroNode 就是一个 简单的二叉树节点，不同的是多了两个 type 属性：</p>
<ul>
<li><strong>leftType</strong>：左节点的类型：0 表示 [<mark>左子树</mark>]，1 表示 [<mark>前驱节点</mark>]</li>
<li><strong>rightType</strong>：右节点的类型：0 表示 [<mark>右子树</mark>]，1 表示 [<mark>后继节点</mark>]</li>
</ul>
</li>
<li>
<p><font style="color:red"><strong>为什么需要</strong></font>？</p>
<ul>
<li>上面原理讲解了，left 或者 right 会有<mark>两种身份</mark>，需要一个<mark>额外的属性来指明</mark></li>
</ul>
</li>
<li>
<p>threadNodes：线索化二叉树<strong>方法</strong></p>
<ul>
<li>是将一颗<mark>二叉树</mark>，进行<mark>线索化标记</mark>。<mark>只是将可以线索化的节点进行赋值</mark>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mrcode.study.dsalgtutorialdemo.datastructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线索化二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeTest</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> HeroNode left;</span><br><span class="line">        <span class="keyword">public</span> HeroNode right;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左节点的类型：0：左子树，1：前驱节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> leftType;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右节点的类型：0：右子树，1：后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> HeroNode root;</span><br><span class="line">        <span class="keyword">public</span> HeroNode pre; <span class="comment">// 保留上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线索化二叉树：以 中序的方式线索化</span></span><br><span class="line"><span class="comment">         * 重载方法方便调用而已</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadeNodes</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 从 root 开始遍历，然后 线索化</span></span><br><span class="line">            <span class="built_in">this</span>.threadeNodes(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行中序线索化二叉树的方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">threadeNodes</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历顺序：先左、自己、再右</span></span><br><span class="line">            <span class="comment">// 向左递归到最后</span></span><br><span class="line">            threadeNodes(node.left);</span><br><span class="line">            <span class="comment">// 难点就是在这里，如何线索化自己</span></span><br><span class="line">            <span class="comment">// 当自己的 left 节点为空，则设置为前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = pre;</span><br><span class="line">                node.leftType = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为要设置后继节点，只有回到自己的后继节点的时候，才能把自己设置为前一个的后继节点</span></span><br><span class="line">            <span class="comment">// 当前一个节点的 right 为空时，则需要自己是后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                pre.right = node;</span><br><span class="line">                pre.rightType = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数列： 1,3,6,8,10,14</span></span><br><span class="line">            <span class="comment">// 中序： 8,3,10,1,14,6</span></span><br><span class="line">            <span class="comment">// 这里最好结合图示的二叉树来看，容易理解</span></span><br><span class="line">            <span class="comment">// 因为中序遍历，先遍历左边，所以 8 是第一个输出的节点</span></span><br><span class="line">            <span class="comment">// 当 node = 8 时，pre 还没有被赋值过，则为空。这是正确的，因为 8 就是第一个节点</span></span><br><span class="line">            <span class="comment">// 当 8 处理完成之后，处理 3 时</span></span><br><span class="line">            <span class="comment">// 当 node = 3 时，pre 被赋值为 8 了。</span></span><br><span class="line">            pre = node;</span><br><span class="line">            threadeNodes(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadeNodesTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;无用&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;卢俊&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;林冲2&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;林冲3&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">n14</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;林冲4&quot;</span>);</span><br><span class="line">        n1.left = n3;</span><br><span class="line">        n1.right = n6;</span><br><span class="line">        n3.left = n8;</span><br><span class="line">        n3.right = n10;</span><br><span class="line">        n6.left= n14;</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line">        tree.root = n1;</span><br><span class="line"></span><br><span class="line">        tree.threadeNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证：</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">left</span> <span class="operator">=</span> n10.left;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">right</span> <span class="operator">=</span> n10.right;</span><br><span class="line">        System.out.println(<span class="string">&quot;10 号节点的前驱节点：&quot;</span> + left.id);</span><br><span class="line">        System.out.println(<span class="string">&quot;10 号节点的后继节点：&quot;</span> + right.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 号节点的前驱节点：3</span><br><span class="line">10 号节点的后继节点：1</span><br></pre></td></tr></table></figure>
<p><strong>如果看代码注释看不明白的话，下面来解释</strong>：</p>
<ul>
<li>
<p>线索化的时候，就是要按照 <strong>中序遍历</strong> 的顺序，去找可以线索化的节点</p>
<p><strong>中序遍历顺序</strong>：先左，自己，再右</p>
<p>我们主要的代码是在 <strong>自己这一块</strong></p>
</li>
<li>
<p>确定前一个节点 pre</p>
<p>这个 pre 很难理解，对照下图进行理解</p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20201202230643686.f3691332.png" alt="image-20201202230643686"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 数列： 1,3,6,8,10,14</span><br><span class="line">// 中序： 8,3,10,1,14,6</span><br><span class="line"></span><br><span class="line">// 因为中序遍历，先遍历左边，所以 8 是第一个输出的节点</span><br><span class="line">// 当 node = 8 时，pre 还没有被赋值过，则为空。这是正确的，因为 8 就是第一个节点</span><br><span class="line">// 当 8 处理完成之后，处理 3 时</span><br><span class="line">// 当 node = 3 时，pre 被赋值为 8 了。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>设置前驱节点</strong></p>
<p>难点的讲解在于 pre，这里就简单了</p>
<p>如果当 node = 8 时，pre 还是 null，因为 8 就是中序的第一个节点。因此 8 没有前驱</p>
<p>如果当 node = 3 时，pre = 8，那么 3 是不符合线索化要求的，因为 8 是 3 的 left</p>
</li>
<li>
<p><strong>设置后继节点</strong></p>
<p>接上面的逻辑。</p>
<p>如果当 node = 8 时，本来 该给 8 设置它的后继节点，但是此时根本就获取不到节点 3 ，因为节点是单向的。</p>
<p>如果利用前一个节点 pre。</p>
<p>当 node = 3 时， pre = 8 ，这时就可以为节点  8 处理它的后继节点了，<strong>因为根据中序的顺序</strong>，<strong>左</strong>，<strong>自己</strong>，<strong>后</strong>。<strong>那么自己一定是前一个的后继</strong>。只要前一个 right 为 null ，就符合线索化。</p>
</li>
</ul>
<p>上述最难的 3 个点说明，请对照上图查看，先看一遍代码，再看说明。然后去 debug 你就懂了。</p>
<h3 id="遍历线索化二叉树"><a class="markdownIt-Anchor" href="#遍历线索化二叉树">#</a> <mark>遍历</mark>线索化二叉树</h3>
<p><strong>说明</strong>：对前面的中序线索化的二叉树，进行<mark>遍历</mark></p>
<p><strong>分析</strong>：因为线索化后，各个节点指向有变化，因此<strong style="color:red">原来的遍历方式不能使用</strong>, 这时需要使用<mark>新的方式</mark><strong>遍历线索化二叉树</strong>, 各个节点可以通过<mark>线型方式遍历</mark>，因此<mark>无需使用递归方式</mark>，这样也<mark>提高了遍历的效率</mark>，<strong>遍历的<mark>次序</mark>应当和<mark>中序遍历</mark>保持<mark>一致</mark></strong>。</p>
<p><strong style="color:red">注意</strong>：使用原来的方式中序遍历线索化二叉树则会造成<font style="color:red">堆栈溢出</font>.</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/413:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树</span></span><br><span class="line">        root.left = node;</span><br><span class="line">        root.right = node1;</span><br><span class="line">        node.left = node2;</span><br><span class="line">        node.right = node3;</span><br><span class="line">        node1.left = node4;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试线索化</span></span><br><span class="line">        <span class="type">ThreadedBinaryTree01</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree01</span>();</span><br><span class="line">        <span class="comment">//设置root节点</span></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        <span class="comment">//调用线索化二叉树的方法进行线索化</span></span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 使用遍历二叉树的方式来中序遍历线索化后的二叉树则会造成堆栈溢出</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.infixOrder();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用中序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HeroNode01 root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了实现线索化，需要创建指向当前节点的前驱节点的指针</span></span><br><span class="line"><span class="comment">     * 在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">HeroNode01</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode01 root)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载方法 方便调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历线索化二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的节点，从root开始</span></span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环的找到leftType == 1的节点，第一个找到就是8节点</span></span><br><span class="line"><span class="comment">             * 后面随着遍历而变化，因为当leftType == 1时，说明该节点是按照线索化</span></span><br><span class="line"><span class="comment">             * 处理后的有效节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印当前这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.rightType == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">                node = node.right;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 就是当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能进行线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(一) 先线索化左子树</span></span><br><span class="line">        threadedNodes(node.left);</span><br><span class="line">        <span class="comment">//(二) 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前节点的左指针执行前驱节点</span></span><br><span class="line">            node.left = pre;</span><br><span class="line">            <span class="comment">//修改左指针类型标记为前驱节点</span></span><br><span class="line">            node.leftType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前node节点设置pre右指针的后继节点</span></span><br><span class="line">            pre.right = node;</span><br><span class="line">            <span class="comment">//修改右指针类型标记为前驱节点</span></span><br><span class="line">            pre.rightType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前节点赋值给pre节点(形成前后关系)</span></span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="comment">//(三) 先线索化右子树</span></span><br><span class="line">        threadedNodes(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历二叉树(TODO 注意：不能使用遍历线索化后的二叉树)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 left;</span><br><span class="line">    <span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.如果leftType == 0 表示指向的是左子树，如果1则表示指向前驱节点</span></span><br><span class="line"><span class="comment">     * 2.如果rightType == 0 表示指向的是右子树，如果1表示指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode01</span> <span class="params">(<span class="type">int</span> no,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode01&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前序遍历线索化二叉树"><a class="markdownIt-Anchor" href="#前序遍历线索化二叉树">#</a> <mark>前序遍历</mark>线索化二叉树</h3>
<p>二叉树 实现线索化二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.threadedNodesPreOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPreOrder</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      node.left = pre;</span><br><span class="line">      node.leftType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      pre.right = node;</span><br><span class="line">      pre.rightType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   pre = node;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">      threadedNodesPreOrder(node.left);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(node.rightType == <span class="number">0</span>)&#123;</span><br><span class="line">      threadedNodesPreOrder(node.right);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点 实现：无</p>
<p>遍历代码线索化二叉树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">      System.out.println(node);</span><br><span class="line">      <span class="keyword">while</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">         node = node.left;</span><br><span class="line">         System.out.println(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(node.rightType == <span class="number">1</span>)&#123;</span><br><span class="line">         node = node.right;</span><br><span class="line">         System.out.println(node);</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HeroNode01</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动创建二叉树</span></span><br><span class="line">root.left = node;</span><br><span class="line">root.right = node1;</span><br><span class="line">node.left = node2;</span><br><span class="line">node.right = node3;</span><br><span class="line">node1.left = node4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线索化</span></span><br><span class="line"><span class="type">ThreadedBinaryTree01</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree01</span>();</span><br><span class="line"><span class="comment">//设置root节点</span></span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line"><span class="comment">//调用前序线索化二叉树的方法进行线索化</span></span><br><span class="line">threadedBinaryTree.threadedNodesPreOrder();</span><br><span class="line"><span class="comment">//使用前序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line">threadedBinaryTree.listPreOrder();</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HeroNode01&#123;no=1, name=&#x27;tom&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=3, name=&#x27;jack&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=8, name=&#x27;mary&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=10, name=&#x27;king&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=6, name=&#x27;smith&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=14, name=&#x27;dim&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历线索化二叉树"><a class="markdownIt-Anchor" href="#中序遍历线索化二叉树">#</a> <mark>中序遍历</mark>线索化二叉树</h3>
<p>二叉树 实现线索化二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedInfixNodes</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.threadedInfixNodes(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedInfixNodes</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">   <span class="comment">//如果node == null，不能进行线索化</span></span><br><span class="line">   <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//(一) 先线索化左子树</span></span><br><span class="line">   threadedInfixNodes(node.left);</span><br><span class="line">   <span class="comment">//(二) 线索化当前节点</span></span><br><span class="line">   <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">   <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//将当前节点的左指针执行前驱节点</span></span><br><span class="line">      node.left = pre;</span><br><span class="line">      <span class="comment">//修改左指针类型标记为前驱节点</span></span><br><span class="line">      node.leftType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//处理后继节点</span></span><br><span class="line">   <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//将当前node节点设置pre右指针的后继节点</span></span><br><span class="line">      pre.right = node;</span><br><span class="line">      <span class="comment">//修改右指针类型标记为前驱节点</span></span><br><span class="line">      pre.rightType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将当前节点赋值给pre节点(形成前后关系)</span></span><br><span class="line">   pre = node;</span><br><span class="line">   <span class="comment">//(三) 先线索化右子树</span></span><br><span class="line">   threadedInfixNodes(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点 实现 ：无</p>
<p>遍历线索化二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listInfoxOrder</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//定义一个变量，存储当前遍历的节点，从root开始</span></span><br><span class="line">   <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环的找到leftType == 1的节点，第一个找到就是8节点</span></span><br><span class="line"><span class="comment">             * 后面随着遍历而变化，因为当leftType == 1时，说明该节点是按照线索化</span></span><br><span class="line"><span class="comment">             * 处理后的有效节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">      <span class="keyword">while</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">         node = node.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//打印当前这个节点</span></span><br><span class="line">      System.out.println(node);</span><br><span class="line">      <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">      <span class="keyword">while</span>(node.rightType == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">         node = node.right;</span><br><span class="line">         System.out.println(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">      node = node.right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HeroNode01</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动创建二叉树</span></span><br><span class="line">root.left = node;</span><br><span class="line">root.right = node1;</span><br><span class="line">node.left = node2;</span><br><span class="line">node.right = node3;</span><br><span class="line">node1.left = node4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线索化</span></span><br><span class="line"><span class="type">ThreadedBinaryTree01</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree01</span>();</span><br><span class="line"><span class="comment">//设置root节点</span></span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line"><span class="comment">//调用中序线索化二叉树的方法进行线索化</span></span><br><span class="line">threadedBinaryTree.threadedInfixNodes();</span><br><span class="line"><span class="comment">//使用中序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line">threadedBinaryTree.listInfoxOrder();</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HeroNode01&#123;no=<span class="number">8</span>, name=<span class="string">&#x27;mary&#x27;</span>&#125;</span><br><span class="line">HeroNode01&#123;no=<span class="number">3</span>, name=<span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line">HeroNode01&#123;no=<span class="number">10</span>, name=<span class="string">&#x27;king&#x27;</span>&#125;</span><br><span class="line">HeroNode01&#123;no=<span class="number">1</span>, name=<span class="string">&#x27;tom&#x27;</span>&#125;</span><br><span class="line">HeroNode01&#123;no=<span class="number">14</span>, name=<span class="string">&#x27;dim&#x27;</span>&#125;</span><br><span class="line">HeroNode01&#123;no=<span class="number">6</span>, name=<span class="string">&#x27;smith&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历线索化二叉树"><a class="markdownIt-Anchor" href="#后序遍历线索化二叉树">#</a> <mark>后序遍历</mark>线索化二叉树</h3>
<p>二叉树  实现线索化二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPostOrder</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.threadedNodesPostOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPostOrder</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//线索化左子树</span></span><br><span class="line">   threadedNodesPostOrder(node.left);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线索化右子树</span></span><br><span class="line">   threadedNodesPostOrder(node.right);</span><br><span class="line">   <span class="comment">//线索化当前节点</span></span><br><span class="line">   <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = pre;</span><br><span class="line">      node.leftType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      pre.right = node;</span><br><span class="line">      pre.rightType = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历添加父节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderAddPar</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root.preOrderAddPar();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点  实现：添加父节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 left;</span><br><span class="line">    <span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.如果leftType == 0 表示指向的是左子树，如果1则表示指向前驱节点</span></span><br><span class="line"><span class="comment">     * 2.如果rightType == 0 表示指向的是右子树，如果1表示指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加父节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 <span class="title function_">getParent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(HeroNode01 parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode01</span> <span class="params">(<span class="type">int</span> no,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历添加父节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderAddPar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.setParent(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.setParent(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//2.向左遍历</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrderAddPar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//3.向右遍历</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrderAddPar();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode01&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历线索化二叉树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPostOrder</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; node.leftType !=<span class="number">1</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">HeroNode01</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//右节点是线索</span></span><br><span class="line">      <span class="keyword">if</span> (node.rightType == <span class="number">1</span>) &#123;</span><br><span class="line">         System.out.println(node);</span><br><span class="line">         pre = node;</span><br><span class="line">         node = node.right;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果上个处理的节点是当前节点的右节点</span></span><br><span class="line">         <span class="keyword">if</span> (node.right == pre) &#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">if</span> (node == root) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node;</span><br><span class="line">            node = node.getParent();</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果从左节点的进入则找到有子树的最左节点</span></span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.leftType !=<span class="number">1</span>) &#123;</span><br><span class="line">               node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HeroNode01</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line"><span class="type">HeroNode01</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动创建二叉树</span></span><br><span class="line">root.left = node;</span><br><span class="line">root.right = node1;</span><br><span class="line">node.left = node2;</span><br><span class="line">node.right = node3;</span><br><span class="line">node1.left = node4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线索化</span></span><br><span class="line"><span class="type">ThreadedBinaryTree01</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree01</span>();</span><br><span class="line"><span class="comment">//设置root节点</span></span><br><span class="line">threadedBinaryTree.setRoot(root);</span><br><span class="line"><span class="comment">//为节点遍历添加父节点</span></span><br><span class="line">threadedBinaryTree.preOrderAddPar();</span><br><span class="line"><span class="comment">//调用后序线索化二叉树的方法进行线索化</span></span><br><span class="line">threadedBinaryTree.threadedNodesPostOrder();</span><br><span class="line"><span class="comment">//使用后序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line">threadedBinaryTree.listPostOrder();</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HeroNode01&#123;no=8, name=&#x27;mary&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=10, name=&#x27;king&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=3, name=&#x27;jack&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=14, name=&#x27;dim&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=6, name=&#x27;smith&#x27;&#125;</span><br><span class="line">HeroNode01&#123;no=1, name=&#x27;tom&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码">#</a> 完整代码：</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/413:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode01</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树</span></span><br><span class="line">        root.left = node;</span><br><span class="line">        root.right = node1;</span><br><span class="line">        node.left = node2;</span><br><span class="line">        node.right = node3;</span><br><span class="line">        node1.left = node4;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试线索化</span></span><br><span class="line">        <span class="type">ThreadedBinaryTree01</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree01</span>();</span><br><span class="line">        <span class="comment">//设置root节点</span></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        <span class="comment">//为节点遍历添加父节点</span></span><br><span class="line">        threadedBinaryTree.preOrderAddPar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用中序线索化二叉树的方法进行线索化</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.threadedInfixNodes();</span></span><br><span class="line">        <span class="comment">//调用前序线索化二叉树的方法进行线索化</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.threadedNodesPreOrder();</span></span><br><span class="line">        <span class="comment">//调用后序线索化二叉树的方法进行线索化</span></span><br><span class="line">        threadedBinaryTree.threadedNodesPostOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 使用遍历二叉树的方式来中序遍历线索化后的二叉树则会造成堆栈溢出</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.infixOrder();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用中序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.listInfoxOrder();</span></span><br><span class="line">        <span class="comment">//使用前序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.listPreOrder();</span></span><br><span class="line">        <span class="comment">//使用后序遍历线索化的方法来遍历线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.listPostOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HeroNode01 root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了实现线索化，需要创建指向当前节点的前驱节点的指针</span></span><br><span class="line"><span class="comment">     * 在递归进行线索化时，pre总是保留前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">HeroNode01</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode01 root)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedInfixNodes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedInfixNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNodesPreOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPostOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNodesPostOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历线索化二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPreOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">while</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(node.rightType == <span class="number">1</span>)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历线索化二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listInfoxOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的节点，从root开始</span></span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 循环的找到leftType == 1的节点，第一个找到就是8节点</span></span><br><span class="line"><span class="comment">             * 后面随着遍历而变化，因为当leftType == 1时，说明该节点是按照线索化</span></span><br><span class="line"><span class="comment">             * 处理后的有效节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印当前这个节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向的是后继节点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span>(node.rightType == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">                node = node.right;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的节点</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listPostOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span> &amp;&amp; node.leftType !=<span class="number">1</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode01</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//右节点是线索</span></span><br><span class="line">            <span class="keyword">if</span> (node.rightType == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">                pre = node;</span><br><span class="line">                node = node.right;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果上个处理的节点是当前节点的右节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.right == pre) &#123;</span><br><span class="line">                    System.out.println(node);</span><br><span class="line">                    <span class="keyword">if</span> (node == root) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = node;</span><br><span class="line">                    node = node.getParent();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果从左节点的进入则找到有子树的最左节点</span></span><br><span class="line">                    node = node.right;</span><br><span class="line">                    <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.leftType !=<span class="number">1</span>) &#123;</span><br><span class="line">                        node = node.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 就是当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedInfixNodes</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能进行线索化</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(一) 先线索化左子树</span></span><br><span class="line">        threadedInfixNodes(node.left);</span><br><span class="line">        <span class="comment">//(二) 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前节点的左指针执行前驱节点</span></span><br><span class="line">            node.left = pre;</span><br><span class="line">            <span class="comment">//修改左指针类型标记为前驱节点</span></span><br><span class="line">            node.leftType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前node节点设置pre右指针的后继节点</span></span><br><span class="line">            pre.right = node;</span><br><span class="line">            <span class="comment">//修改右指针类型标记为前驱节点</span></span><br><span class="line">            pre.rightType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前节点赋值给pre节点(形成前后关系)</span></span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="comment">//(三) 先线索化右子树</span></span><br><span class="line">        threadedInfixNodes(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPreOrder</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.left = pre;</span><br><span class="line">            node.leftType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">            pre.rightType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.leftType == <span class="number">0</span>)&#123;</span><br><span class="line">            threadedNodesPreOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.rightType == <span class="number">0</span>)&#123;</span><br><span class="line">            threadedNodesPreOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPostOrder</span><span class="params">(HeroNode01 node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化左子树</span></span><br><span class="line">        threadedNodesPostOrder(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线索化右子树</span></span><br><span class="line">        threadedNodesPostOrder(node.right);</span><br><span class="line">        <span class="comment">//线索化当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = pre;</span><br><span class="line">            node.leftType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">            pre.rightType = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历添加父节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderAddPar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrderAddPar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历二叉树(TODO 注意：不能使用遍历线索化后的二叉树)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建HeroNode节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 left;</span><br><span class="line">    <span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1.如果leftType == 0 表示指向的是左子树，如果1则表示指向前驱节点</span></span><br><span class="line"><span class="comment">     * 2.如果rightType == 0 表示指向的是右子树，如果1表示指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode01 <span class="title function_">getParent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(HeroNode01 parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode01</span> <span class="params">(<span class="type">int</span> no,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历添加父节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderAddPar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.setParent(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.setParent(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//2.向左遍历</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrderAddPar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//3.向右遍历</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrderAddPar();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode01&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树结构实际应用"><a class="markdownIt-Anchor" href="#树结构实际应用">#</a> 树结构实际应用</h2>
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序">#</a> 堆排序</h3>
<p><strong>堆排序基本介绍</strong></p>
<ol>
<li>堆排序是利用<strong>堆</strong>这种数据结构而设计的一种<mark>排序算法</mark>，堆排序是一种<mark>选择排序</mark>，它的<mark>最坏，最好，平均时间复杂度均为 O (nlogn)，它也是不稳定排序</mark>。</li>
<li>堆是具有以下性质的<mark>完全二叉树</mark>：<mark>每个结点的值</mark>都<mark>大于</mark>或<mark>等于</mark>其<mark>左右孩子结点的值</mark>，称为<mark>大顶堆</mark>
<ul>
<li><strong style="color:red">注意</strong>: 没有要求<mark>结点</mark>的<mark>左孩子的值</mark>和<mark>右孩子的值</mark>的<mark>大小关系</mark>。</li>
</ul>
</li>
<li><mark>每个结点的值</mark>都<mark>小于</mark>或<mark>等于</mark>其<mark>左右孩子结点的值</mark>，称为<mark>小顶堆</mark></li>
</ol>
<h4 id="大顶堆举例说明"><a class="markdownIt-Anchor" href="#大顶堆举例说明">#</a> 大顶堆举例说明</h4>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704170408717.png" alt="image-20230704170408717"></p>
<p>我们对堆中的结点按层进行编号，映射到数组中就是下面这个样子:</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704170435750.png" alt="image-20230704170435750"></p>
<p><strong>大顶堆特点</strong>： <code>arr[i] &gt;= arr[2\*i+1] &amp;&amp; arr[i] &gt;= arr[2\*i+2]</code></p>
<ul>
<li>i 对应第几个节点，i 从 0 开始编号</li>
</ul>
<h4 id="小顶堆举例说明"><a class="markdownIt-Anchor" href="#小顶堆举例说明">#</a> 小顶堆举例说明</h4>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704170624790.png" alt="image-20230704170624790"></p>
<p><strong>小顶堆</strong>： <code>arr[i] &lt;= arr[2\*i+1] &amp;&amp; arr[i] &lt;= arr[2\*i+2]</code></p>
<ul>
<li>i 对应第几个节点，i 从 0 开始编号</li>
</ul>
<ol start="6">
<li>一般<mark>升序采用大顶堆</mark>，<mark>降序采用小顶堆</mark></li>
</ol>
<p><strong>堆排序基本思想</strong></p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值<font style="color:red"><sup>第二小的值</sup></font>。如此反复执行，便能得到一个有序序列了。</li>
</ol>
<p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
<p><strong>堆排序步骤图解说明</strong></p>
<p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)</strong>。</p>
<ol>
<li>假设给定无序序列结构如下</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171102845.png" alt="image-20230704171102845"></p>
<ol start="2">
<li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点  <code>arr.length/2-1=5/2-1=1</code> ，也就是下面的 6 结点），从左至右，从下至上进行调整。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171121981.png" alt="image-20230704171121981"></p>
<ol start="3">
<li>找到第二个非叶节点 4，由于 [4,9,8] 中 9 元素最大，4 和 9 交换。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171144931.png" alt="image-20230704171144931"></p>
<ol start="4">
<li>这时，交换导致了子根 [4,5,6] 结构混乱，继续调整，[4,5,6] 中 6 最大，交换 4 和 6。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171207684.png" alt="image-20230704171207684"></p>
<p>此时，我们就将一个无序序列构造成了一个大顶堆。</p>
<p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换</strong>。</p>
<ol>
<li>将堆顶元素 9 和末尾元素 4 进行交换</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171233081.png" alt="image-20230704171233081"></p>
<ol start="2">
<li>重新调整结构，使其继续满足堆定义</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171255536.png" alt="image-20230704171255536"></p>
<ol start="3">
<li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171316338.png" alt="image-20230704171316338"></p>
<ol start="4">
<li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230704171334035.png" alt="image-20230704171334035"></p>
<p><strong>再简单总结下堆排序的基本思路：</strong></p>
<ol>
<li><strong>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</strong></li>
<li><strong>将堆顶元素与末尾元素交换，将最大元素 &quot;沉&quot; 到数组末端；</strong></li>
<li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。</strong></li>
</ol>
<p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/416:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一次&quot;+ Arrays.toString(arr));//4, 9, 8, 5, 6</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二次&quot;+Arrays.toString(arr));//9,6,8,5,4</span></span><br><span class="line">        <span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端</span></span><br><span class="line"><span class="comment">         * 3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到</span></span><br><span class="line"><span class="comment">         * 整个序列有序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;j &gt; <span class="number">0</span>;j --)&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组(二叉树)，调整成一个大顶堆</span></span><br><span class="line"><span class="comment">     * 功能：完成将以i对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">     * 举例：int[] arr = &#123;4,6,8,5,9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4,9,8,5,6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调用adjustHeap传入的是i = 0 =&gt; 得到 &#123;4,9,8,5,6&#125; =&gt; &#123;9,6,8,5,4&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 数组中的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始调整</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1.k = i * 2 + 1 k是i节点的左子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;k &lt; length;k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//说明 左子节点的值小于右子节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//k 指向右子节点</span></span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                <span class="comment">//把较大的值赋值给当前节点</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                <span class="comment">//i 指向 k,继续循环比较</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后，我们已经将i为父节点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">        <span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赫夫曼树"><a class="markdownIt-Anchor" href="#赫夫曼树">#</a> 赫夫曼树</h3>
<p><strong>基本介绍</strong></p>
<ol>
<li>给定 n 个权值作为 n 个 <strong>叶子结点</strong> ，构造一颗二叉树，若该树的<strong>带权路径长度 (wpl) 达到最小</strong>，称这样的二叉树为<strong>最优二叉树</strong>，也称为<strong>赫夫曼树 (HuffmanTree)</strong>，还有的书翻译为<strong>霍夫曼树</strong>。</li>
<li>赫夫曼树是<strong>带权路径长度最短的树</strong>，<strong>权值较大的节点离根较近</strong>。</li>
</ol>
<p><strong>赫夫曼树几个重要概念和举例说明</strong></p>
<ol>
<li><strong>路径和长度</strong>：在一颗树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为 1，则从根节点到第 L 层节点的路径长度为 L-1。</li>
<li><strong>节点的权及带权路径长度</strong>：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。<strong>节点的带权路径长度为</strong>：从根节点到该节点之间的路径长度与该节点的权的乘积。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230705194848316.png" alt="image-20230705194848316"></p>
<ol start="3">
<li>树的带权路径长度：树的带权路径长度规定为所有 <strong>叶子结点</strong> 的带权路径长度之和，记为 WPL (weighted path length)，权值越大的节点离根节点越近的二叉树才是最优二叉树。</li>
<li>WPL 最小的就是<strong>赫夫曼树</strong> 下图中 - 中间的就是赫夫曼树</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230705195146344.png" alt="image-20230705195146344"></p>
<p><strong>赫夫曼树创建思路图解</strong></p>
<p>给你一个数列 {13,7,8,3,29,6,1} ，要求转成一颗赫夫曼树</p>
<p>思路分析示意图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230705195844840.png" alt="image-20230705195844840"></p>
<p><strong>构成赫夫曼树的步骤</strong>：</p>
<ol>
<li>从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树，该新的二叉树的根节点的权值是前两棵二叉树根节点权值的和</li>
<li>再将这棵新的二叉树，以根节点的权值大小再次排序，不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/519:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTree</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">        preOrder(huffmanTree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼二叉树数据为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.遍历arr数组</span></span><br><span class="line"><span class="comment">         * 2.将arr的每个元素构成一个Node</span></span><br><span class="line"><span class="comment">         * 3.将Node放入到ArrayList中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> value:arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序从小打大</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出节点权值最小的两棵二叉树</span></span><br><span class="line">            <span class="comment">//(1)取出权值最小的节点(二叉树)</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(2)取出第二小的节点(二叉树)</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(3)构建成一棵新的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//(5)将parent加入到list</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回赫夫曼树的root节点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * value: 节点权值</span></span><br><span class="line"><span class="comment">     * left: 指向左子节点</span></span><br><span class="line"><span class="comment">     * right: 指向右子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span> <span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="赫夫曼编码"><a class="markdownIt-Anchor" href="#赫夫曼编码">#</a> 赫夫曼编码</h4>
<p><strong>基本介绍</strong>：</p>
<ol>
<li>赫夫曼编码也翻译为 <strong>哈夫曼编码 (HuffmanCoding)</strong> ，又称霍夫曼编码，是一种编码方式，属于一种程序算法</li>
<li>赫夫曼编码是赫夫曼树在电讯通信中的经典的应用之一。</li>
<li>赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在 20% ~ 90% 之间</li>
<li>赫夫曼编码是可变字长编码 (VLC) 的一种，Huffman 与 1952 年提出一种编码方法，称之为最佳编码</li>
</ol>
<p>原理剖析：</p>
<ul>
<li>
<p>通信领域中信息的处理方式 1- 定长编码</p>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格)</p>
</li>
<li>
<p>// 对应 Ascii 码</p>
<blockquote>
<p>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97</p>
</blockquote>
</li>
<li>
<p>// 对应的二进制</p>
<blockquote>
<p>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001</p>
</blockquote>
</li>
<li>
<p>按照二进制来传递信息，总的长度是 359  (包括空格)</p>
</li>
</ul>
</li>
<li>
<p>通信领域中信息的处理方式 2 - 变长编码</p>
<ul>
<li>
<p>i like like like java do you like a java    // 共 40 个字符 (包括空格)</p>
</li>
<li>
<p>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数</p>
<p>0= , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</p>
</li>
<li>
<p><mark>说明</mark>：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了 9 次， 编码为 0 , 其它依次类推.</p>
</li>
<li>
<p>按照上面给各个字符规定的编码，则我们在传输 “i like like like java do you like a java” 数据时，编码就是</p>
<p><code>10010110100... </code></p>
</li>
<li>
<p>・字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码 (这个在<strong>赫夫曼编码</strong>中，我们还要进行举例说明，不捉急)</p>
</li>
</ul>
</li>
<li>
<p>通信领域中信息的处理方式 3 - 赫夫曼编码</p>
<ul>
<li>
<p>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数</p>
<p>按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值.(图后)</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230706151354255.png" alt="image-20230706151354255"></p>
<p>// 根据赫夫曼树，给各个字符</p>
<p>// 规定编码 ， 向左的路径为 0</p>
<p>// 向右的路径为 1 ， 编码如下:</p>
<p>o: 1000  u: 10010 d: 100110 y: 100111 i: 101</p>
<p>a : 110   k: 1110  e: 1111    j: 0000    v: 0001</p>
<p>l: 001     : 01</p>
<p>按照上面的赫夫曼编码，我们的 &quot;i like like like java do you like a java&quot;  字符串对应的编码为 (注意这里我们使用的无损压缩)</p>
<p>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</p>
<p><strong>长度为</strong> ： 133</p>
<p><mark>说明</mark>:</p>
<ol>
<li>原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</li>
<li>此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性</li>
</ol>
<p><mark>注意</mark>:, 这个赫夫曼树根据排序方法不同，也可能不太一样，<strong>这样对应的赫夫曼编码也不完全一样</strong>，但是 wpl 是一样的，都是最小的，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230706151550342.png" alt="image-20230706151550342"></p>
<h4 id="最佳实践-数据压缩创建赫夫曼树"><a class="markdownIt-Anchor" href="#最佳实践-数据压缩创建赫夫曼树">#</a> 最佳实践 - 数据压缩 (创建赫夫曼树)</h4>
<p>将给出的一段文本，比如 “i like like like java do you like a java” ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 “1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110”</p>
<p>步骤 1：根据赫夫曼编码压缩数据的原理，需要创建 “i like like like java do you like a java” 对应的赫夫曼树.</p>
<p>思路：前面已经分析过了，而且我们已然讲过了构建赫夫曼树的具体实现。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String content=<span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">		<span class="comment">//转成byte数组</span></span><br><span class="line">		<span class="type">byte</span>[] bytes = content.getBytes();</span><br><span class="line">		<span class="comment">//进行赫夫曼编码压缩</span></span><br><span class="line">		huffmanZip(bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">		<span class="comment">//先统计每一个byte出现的次数，并放入一个集合中</span></span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">		<span class="comment">//创建一颗赫夫曼树</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">		<span class="comment">//测试一下 赫夫曼树 是否创建成功!</span></span><br><span class="line">		<span class="comment">//输出root 的 值</span></span><br><span class="line">		System.out.println(root + <span class="string">&quot; &quot;</span> + root.left + <span class="string">&quot; &quot;</span> + root.right);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes byte数组，就是内容字符串对应的byte数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> List&lt;Node&gt; 形式如 &#123;Node&#123;&#x27;i&#x27;, 3&#125;, Node&#123;&#x27;a&#x27;, 5&#125;...&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//存储每一个byte出现了多少次。</span></span><br><span class="line">		Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//统计每一个byte出现的次数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">byte</span> b:bytes) &#123;</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">			<span class="keyword">if</span>(count==<span class="literal">null</span>) &#123;</span><br><span class="line">				counts.put(b, <span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				counts.put(b, count+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把每一个键值对转为一个node对象,并加入到 nodes集合</span></span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry:counts.entrySet()) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nodes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nodes 传入的是一个node集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回赫夫曼树的根节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 循环处理，</span></span><br><span class="line">		<span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 保证可以get(0) 和 get(1)</span></span><br><span class="line">			<span class="comment">// 排序</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. 需要nodes 集合存放的对象实现 Comparable接口</span></span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line">			<span class="comment">// 取出来权值最小的两个二叉树</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 取出最权值次小的二叉树, 作为新的二叉树的右子树</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 创建一颗新的二叉树 ， 新的节点 data 没有，权值为两颗子树权值和</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, left.weight + right.weight);</span><br><span class="line">			<span class="comment">// 把之前取出来的两颗二叉树设置为新创建的二叉树的子树</span></span><br><span class="line">			parent.left = left;</span><br><span class="line">			parent.right = right;</span><br><span class="line">			<span class="comment">// 把取出来的两个二叉树移除</span></span><br><span class="line">			nodes.remove(left);</span><br><span class="line">			nodes.remove(right);</span><br><span class="line">			<span class="comment">// 放入原来的二叉树集合中</span></span><br><span class="line">			nodes.add(parent);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回的节点就是赫夫曼树的根节点.</span></span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 Comparable&lt;Node&gt; 接口是让Node 对象可以进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">	Byte data;  <span class="comment">// 数据本身 , char 本质就是 Byte</span></span><br><span class="line">	<span class="type">int</span> weight; <span class="comment">// 可以理解成权值, 即字符出现的次数</span></span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="comment">//这样写是从小到大排序</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.weight - node.weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Node [data=&quot;</span> + data + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>);<span class="comment">// 先输出父节点</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践-数据压缩生成赫夫曼编码和赫夫曼编码后的数据"><a class="markdownIt-Anchor" href="#最佳实践-数据压缩生成赫夫曼编码和赫夫曼编码后的数据">#</a> 最佳实践 - 数据压缩 (生成赫夫曼编码和赫夫曼编码后的数据)</h4>
<p>我们已经生成了 赫夫曼树，下面我们继续完成任务</p>
<ol>
<li>生成赫夫曼树对应的赫夫曼编码，如下表:  =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</li>
<li>使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将 &quot;i like like like java do you like a java&quot; 字符串生成对应的编码数据，形式如下.<br>
1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</li>
</ol>
<p><strong>思路</strong>：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.huffmancode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String content=<span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">		<span class="comment">//转成byte数组</span></span><br><span class="line">		<span class="type">byte</span>[] bytes = content.getBytes();</span><br><span class="line">		<span class="comment">//进行赫夫曼编码压缩</span></span><br><span class="line">		<span class="type">byte</span>[] huffmanBytes = huffmanZip(bytes);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 content 进程赫夫曼编码，返回的就是 按 赫夫曼编码后的 byte数组</span></span><br><span class="line"><span class="comment">	 * 比如: &quot;i like like like java do you like a java&quot; =&gt; </span></span><br><span class="line"><span class="comment">	 * 101010011011110111101001101111011110100..  但是 是按照 byte数组来存放的,每8位 放入到一个 byte中!</span></span><br><span class="line"><span class="comment">	 * 比如：huffmanBytes[0] = -41(10101001)  huffmanBytes[1] = -61(10111101) ...</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">		<span class="comment">//先统计每一个byte出现的次数，并放入一个集合中</span></span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">		<span class="comment">//创建一颗赫夫曼树</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">		<span class="comment">//测试一下 赫夫曼树 是否创建成功!</span></span><br><span class="line">		<span class="comment">//输出root 的 值</span></span><br><span class="line">		<span class="comment">//System.out.println(root + &quot; &quot; + root.left + &quot; &quot; + root.right);</span></span><br><span class="line">		<span class="comment">//创建一个赫夫曼编码表</span></span><br><span class="line">		Map&lt;Byte, String&gt; huffmanCodes = getCodes(root);</span><br><span class="line">		<span class="comment">//测试一把, 看看 	赫夫曼编码表 是否正确</span></span><br><span class="line">		<span class="comment">//32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011</span></span><br><span class="line">		<span class="comment">//System.out.println(huffmanCodes);</span></span><br><span class="line">		<span class="comment">//遍历一把</span></span><br><span class="line">		Set&lt;Byte&gt; keySet = huffmanCodes.keySet();</span><br><span class="line">		<span class="keyword">for</span>(Byte key: keySet) &#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)key.intValue() + <span class="string">&quot;=&quot;</span> + huffmanCodes.get(key) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//对 bytes 进行哈夫曼编码，返回的是 一个byte数组</span></span><br><span class="line">		<span class="comment">//&quot;i like like like java do you like a java&quot; </span></span><br><span class="line">		<span class="comment">//对应的 是 &quot;1010100010111111110..&quot;</span></span><br><span class="line">		<span class="comment">//huffmanBytes[0] = 10101000 = -88</span></span><br><span class="line">		<span class="comment">//huffmanBytes[1] = 10111111 = -65</span></span><br><span class="line">		<span class="type">byte</span>[] huffmanBytes = zip(bytes,huffmanCodes);</span><br><span class="line">		<span class="comment">//测试一个 </span></span><br><span class="line">		System.out.println(<span class="string">&quot;\n&quot;</span> + Arrays.toString(huffmanBytes));</span><br><span class="line">		<span class="keyword">return</span> huffmanBytes;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//某个叶子节点存储路径</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">	<span class="comment">//存储赫夫曼编码</span></span><br><span class="line">	<span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 传入赫夫曼树的根节点，返回对应的赫夫曼编码 Map&lt;Byte, String&gt;</span></span><br><span class="line"><span class="comment">	 * 即形式如(和生成的赫夫曼树有关系)： 	</span></span><br><span class="line"><span class="comment">	 * 			o: 1000   	u: 10010  	d: 100110  		y: 100111  		i: 101</span></span><br><span class="line"><span class="comment">				a: 110     k: 1110    	e: 1111       	j: 0000       	v: 0001</span></span><br><span class="line"><span class="comment">				l: 001 		 : 01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tree</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理root的左子树</span></span><br><span class="line">		getCodes(root.left,<span class="string">&quot;0&quot;</span>,stringBuilder);</span><br><span class="line">		<span class="comment">//处理root的右子树</span></span><br><span class="line">		getCodes(root.right,<span class="string">&quot;1&quot;</span>,stringBuilder);</span><br><span class="line">		<span class="keyword">return</span> huffmanCodes;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该方法会node 节点的所有叶子节点的赫夫曼编码,并存放在huffmanCodes集合中</span></span><br><span class="line"><span class="comment">	 * 其形式如：&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stringBuilder</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">		stringBuilder2.append(code);</span><br><span class="line">		<span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;</span><br><span class="line">				getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">				getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 传入的&quot;i like ..&quot; 对应的字节数组，和 哈夫曼编码表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffCodes 返回哈夫曼编码后的byte[]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">//把需要压缩的byte数组处理成一个二进制的字符串</span></span><br><span class="line">		<span class="comment">//stringBuilder 就是 形式如 &quot;10101001101111011110...&quot;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">byte</span> b:bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCodes.get(b)); </span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;stringBuilder(就是哈夫曼编码后的串)=&quot;</span> + stringBuilder);</span><br><span class="line">		<span class="comment">//定义就是需要多少个byte来存储，这样就可以定义byte[] 的大小了</span></span><br><span class="line">		<span class="comment">//也可以一句话 len = (stringBuilder.length()+7) / 8</span></span><br><span class="line">		<span class="type">int</span> len; </span><br><span class="line">		<span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//用于存储压缩后的byte</span></span><br><span class="line">		<span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">		<span class="comment">//记录新byte的位置</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stringBuilder.length();i+=<span class="number">8</span>) &#123;</span><br><span class="line">			String strByte;</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">8</span>&gt;stringBuilder.length()) &#123;</span><br><span class="line">				strByte = stringBuilder.substring(i);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				strByte = stringBuilder.substring(i, i+<span class="number">8</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">byte</span> <span class="variable">byt</span> <span class="operator">=</span> (<span class="type">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">			by[index]=byt;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> by;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes byte数组，就是内容字符串对应的byte数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> List&lt;Node&gt; 形式如 &#123;Node&#123;&#x27;i&#x27;, 3&#125;, Node&#123;&#x27;a&#x27;, 5&#125;...&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//存储每一个byte出现了多少次。</span></span><br><span class="line">		Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//统计每一个byte出现的次数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">byte</span> b:bytes) &#123;</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">			<span class="keyword">if</span>(count==<span class="literal">null</span>) &#123;</span><br><span class="line">				counts.put(b, <span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				counts.put(b, count+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把每一个键值对转为一个node对象,并加入到 nodes集合</span></span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry:counts.entrySet()) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nodes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nodes 传入的是一个node集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回赫夫曼树的根节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 循环处理，</span></span><br><span class="line">		<span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// 保证可以get(0) 和 get(1)</span></span><br><span class="line">			<span class="comment">// 排序</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. 需要nodes 集合存放的对象实现 Comparable接口</span></span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line">			<span class="comment">// 取出来权值最小的两个二叉树</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 取出最权值次小的二叉树, 作为新的二叉树的右子树</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 创建一颗新的二叉树 ， 新的节点 data 没有，权值为两颗子树权值和</span></span><br><span class="line">			<span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, left.weight + right.weight);</span><br><span class="line">			<span class="comment">// 把之前取出来的两颗二叉树设置为新创建的二叉树的子树</span></span><br><span class="line">			parent.left = left;</span><br><span class="line">			parent.right = right;</span><br><span class="line">			<span class="comment">// 把取出来的两个二叉树移除</span></span><br><span class="line">			nodes.remove(left);</span><br><span class="line">			nodes.remove(right);</span><br><span class="line">			<span class="comment">// 放入原来的二叉树集合中</span></span><br><span class="line">			nodes.add(parent);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回的节点就是赫夫曼树的根节点.</span></span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 Comparable&lt;Node&gt; 接口是让Node 对象可以进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">	Byte data;  <span class="comment">// 数据本身 , char 本质就是 Byte</span></span><br><span class="line">	<span class="type">int</span> weight; <span class="comment">// 可以理解成权值, 即字符出现的次数</span></span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="comment">//这样写是从小到大排序</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.weight - node.weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Node [data=&quot;</span> + data + <span class="string">&quot;, weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>);<span class="comment">// 先输出父节点</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践-数据解压使用赫夫曼编码解码"><a class="markdownIt-Anchor" href="#最佳实践-数据解压使用赫夫曼编码解码">#</a> 最佳实践 - 数据解压 (使用赫夫曼编码解码)</h4>
<p>使用赫夫曼编码来解码数据，具体要求是</p>
<ol>
<li>前面我们得到了赫夫曼编码和对应的编码 byte [] , 即:[-88, -65, -56, -65, -56, -65, -55, 77<br>
, -57, 6, -24, -14, -117, -4, -60, -90, 28]</li>
<li>现在要求使用赫夫曼编码， 进行解码，又<br>
重新得到原来的字符串 &quot;i like like likejava do you like a java&quot;</li>
</ol>
<p><strong>思路</strong>：解码过程，就是编码的一个逆向操作。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/521:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTreeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">        System.out.println(contentBytes.length);<span class="comment">//40</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后的结果是：&quot;</span> + Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原来的字符串&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sourceBytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分步过程</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;Node01&gt; list = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">        System.out.println(list);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(&quot;----------------赫夫曼树----------------&quot;);</span></span><br><span class="line"><span class="comment">        Node01 huffmanTree = createHuffmanTree(list);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">        preOrder(huffmanTree);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //测试是否生成了对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">        Map&lt;Byte, String&gt; codes = getCodes(huffmanTree);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;生成的赫夫曼编码表：&quot;+codes);</span></span><br><span class="line"><span class="comment">        byte[] huffmanCodeBytes = zip(contentBytes,huffmanCodes);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;huffmanCodeBytes: &quot;+Arrays.toString(huffmanCodeBytes));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;赫夫曼字节数组对应的二进制字符串：&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a -&gt; 100 100 -&gt; a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//小的计数器</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//先取出一个&#x27;1&#x27;,&#x27;0&#x27;</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动 匹配字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//b == null说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明 匹配到了</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;<span class="comment">//i 直接移动到count位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后list中就存放了所有的字符 i like like like java do you like a java</span></span><br><span class="line">        <span class="comment">//把list中 的数据放入byte数组并返回</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte转成一个二进制的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true，需要，false，不需要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> b 对应的二进制的字符串(注意是按补码返回)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用变量保存b,将b转换成int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        <span class="comment">//判断是正数则需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">            <span class="comment">//说明：按位与 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过赫夫曼编码处理后的字节数组（压缩后的数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node01&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建的赫夫曼树</span></span><br><span class="line">        <span class="type">Node01</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = &quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 &quot;1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//遍历bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;测试 stringBuilder~~~=&quot; + stringBuilder.toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 &quot;1010100010111111110...&quot; 转成 byte[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; 等等[形式]</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生成赫夫曼编码表时，需要去拼接路径，定义一个StringBuilder，存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的Node节点的所有叶子节点的赫夫曼编码存放到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径：左子节点是0，右子节点是1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node01 node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code，加入到stringBuilder2中</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前node,是叶子节点还是非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是叶子节点</span></span><br><span class="line">                <span class="comment">//表示找到了某个叶子节点的最后</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes bytes 接受字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是List形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node01&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        List&lt;Node01&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历list，统计每一个byte出现的次数 -&gt; map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(b);</span><br><span class="line">            <span class="comment">//Map还没有这个字符数据，第一次则执行如下</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//已经存在了执行如下</span></span><br><span class="line">                map.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入list集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node01</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List创建赫夫曼树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node01 <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node01&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出第一棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点 没有data，只有权值</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node01</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将处理过的两颗二叉树从list中移除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的二叉树加入到list集合中</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node01</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node01&gt; &#123;</span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node01 left;</span><br><span class="line">    Node01 right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node01</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node01 o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node[data = &quot;</span> + data + <span class="string">&quot; , weight = &quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践-文件压缩"><a class="markdownIt-Anchor" href="#最佳实践-文件压缩">#</a> 最佳实践 - 文件压缩</h4>
<p>我们学习了通过赫夫曼编码对一个字符串进行编码和解码，下面我们来完成对文件的压缩和解压， 具体要求：给你一个图片文件，要求对其进行无损压缩，看看压缩效果如何。</p>
<p><strong>思路</strong>：读取文件 -&gt; 得到赫夫曼编码表 -&gt; 完成压缩</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">   <span class="comment">//创建输出流</span></span><br><span class="line">   <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//创建文件的输入流</span></span><br><span class="line">   <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//创建文件的输入流</span></span><br><span class="line">      is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">      <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">      <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">      <span class="comment">//读取文件</span></span><br><span class="line">      is.read(b);</span><br><span class="line">      <span class="comment">//获取到文件对应的赫夫曼编码表</span></span><br><span class="line">      <span class="comment">//直接对原文件进行压缩</span></span><br><span class="line">      <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">      <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">      os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">      <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">      oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">      <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">      oos.writeObject(huffmanBytes);</span><br><span class="line">      <span class="comment">//以对象流形式写入赫夫曼编码，为了解压(恢复源文件)时使用</span></span><br><span class="line">      <span class="comment">//注意：一定要把赫夫曼编码，写入压缩文件</span></span><br><span class="line">      oos.writeObject(huffmanCodes);</span><br><span class="line">   &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//关闭流，释放资源</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            oos.close();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/521:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTreeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="string">&quot;E://src.bmp&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;E://dst.zip&quot;</span>;</span><br><span class="line">        zipFile(srcFile,dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩文件OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件的输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//获取到文件对应的赫夫曼编码表</span></span><br><span class="line">            <span class="comment">//直接对原文件进行压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//以对象流形式写入赫夫曼编码，为了解压(恢复源文件)时使用</span></span><br><span class="line">            <span class="comment">//注意：一定要把赫夫曼编码，写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//关闭流，释放资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                    os.close();</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;赫夫曼字节数组对应的二进制字符串：&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a -&gt; 100 100 -&gt; a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//小的计数器</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//先取出一个&#x27;1&#x27;,&#x27;0&#x27;</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动 匹配字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//b == null说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明 匹配到了</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;<span class="comment">//i 直接移动到count位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后list中就存放了所有的字符 i like like like java do you like a java</span></span><br><span class="line">        <span class="comment">//把list中 的数据放入byte数组并返回</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte转成一个二进制的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true，需要，false，不需要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> b 对应的二进制的字符串(注意是按补码返回)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用变量保存b,将b转换成int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        <span class="comment">//判断是正数则需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">            <span class="comment">//说明：按位与 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过赫夫曼编码处理后的字节数组（压缩后的数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node01&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建的赫夫曼树</span></span><br><span class="line">        <span class="type">Node01</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = &quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 &quot;1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//遍历bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;测试 stringBuilder~~~=&quot; + stringBuilder.toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 &quot;1010100010111111110...&quot; 转成 byte[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; 等等[形式]</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生成赫夫曼编码表时，需要去拼接路径，定义一个StringBuilder，存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的Node节点的所有叶子节点的赫夫曼编码存放到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径：左子节点是0，右子节点是1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node01 node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code，加入到stringBuilder2中</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前node,是叶子节点还是非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是叶子节点</span></span><br><span class="line">                <span class="comment">//表示找到了某个叶子节点的最后</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes bytes 接受字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是List形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node01&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        List&lt;Node01&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历list，统计每一个byte出现的次数 -&gt; map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(b);</span><br><span class="line">            <span class="comment">//Map还没有这个字符数据，第一次则执行如下</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//已经存在了执行如下</span></span><br><span class="line">                map.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入list集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node01</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List创建赫夫曼树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node01 <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node01&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出第一棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点 没有data，只有权值</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node01</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将处理过的两颗二叉树从list中移除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的二叉树加入到list集合中</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node01</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node01&gt; &#123;</span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node01 left;</span><br><span class="line">    Node01 right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node01</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node01 o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node[data = &quot;</span> + data + <span class="string">&quot; , weight = &quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳实践文件解压文件恢复"><a class="markdownIt-Anchor" href="#最佳实践文件解压文件恢复">#</a> 最佳实践 —— 文件解压 (文件恢复)</h4>
<p>具体要求：将前面压缩的文件，重新恢复成原来的文件。</p>
<p>思路：读取压缩文件 (数据和赫夫曼编码表) -&gt; 完成解压 (文件恢复)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile,String dstFile)</span>&#123;</span><br><span class="line">   <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">      ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">      <span class="comment">//读取byte数组 huffmanBytes</span></span><br><span class="line">      <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[]) ois.readObject();</span><br><span class="line">      <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">      Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;) ois.readObject();</span><br><span class="line">      <span class="comment">//解码</span></span><br><span class="line">      <span class="type">byte</span>[] bytes = decode(huffmanCodes,huffmanBytes);</span><br><span class="line">      <span class="comment">//将bytes,数组写入到目标文件</span></span><br><span class="line">      os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">      <span class="comment">//写出数据到文件中</span></span><br><span class="line">      os.write(bytes);</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//关闭流，释放资源</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">            os.close();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            ois.close();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            is.close();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/521:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTreeCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String srcFile = &quot;E://src.bmp&quot;;</span></span><br><span class="line"><span class="comment">        String dstFile = &quot;E://dst.zip&quot;;</span></span><br><span class="line"><span class="comment">        zipFile(srcFile,dstFile);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;压缩文件OK&quot;);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="string">&quot;E://dst.zip&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;E://srcTwo.bmp&quot;</span>;</span><br><span class="line">        unZipFile(zipFile,dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压完毕OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组 huffmanBytes</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[]) ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;) ois.readObject();</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCodes,huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes,数组写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//写出数据到文件中</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//关闭流，释放资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法，将一个文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件的输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//获取到文件对应的赫夫曼编码表</span></span><br><span class="line">            <span class="comment">//直接对原文件进行压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//以对象流形式写入赫夫曼编码，为了解压(恢复源文件)时使用</span></span><br><span class="line">            <span class="comment">//注意：一定要把赫夫曼编码，写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//关闭流，释放资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                    os.close();</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;赫夫曼字节数组对应的二进制字符串：&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把字符串按照指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a -&gt; 100 100 -&gt; a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//小的计数器</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//先取出一个&#x27;1&#x27;,&#x27;0&#x27;</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动 匹配字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//b == null说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明 匹配到了</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;<span class="comment">//i 直接移动到count位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后list中就存放了所有的字符 i like like like java do you like a java</span></span><br><span class="line">        <span class="comment">//把list中 的数据放入byte数组并返回</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte转成一个二进制的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true，需要，false，不需要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> b 对应的二进制的字符串(注意是按补码返回)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用变量保存b,将b转换成int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        <span class="comment">//判断是正数则需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">            <span class="comment">//说明：按位与 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过赫夫曼编码处理后的字节数组（压缩后的数组）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node01&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建的赫夫曼树</span></span><br><span class="line">        <span class="type">Node01</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = &quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 &quot;1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//遍历bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(&quot;测试 stringBuilder~~~=&quot; + stringBuilder.toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 &quot;1010100010111111110...&quot; 转成 byte[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">        <span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1.将赫夫曼编码表存放在Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; 等等[形式]</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2.在生成赫夫曼编码表时，需要去拼接路径，定义一个StringBuilder，存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的Node节点的所有叶子节点的赫夫曼编码存放到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径：左子节点是0，右子节点是1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node01 node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code，加入到stringBuilder2中</span></span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前node,是叶子节点还是非叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder2);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是叶子节点</span></span><br><span class="line">                <span class="comment">//表示找到了某个叶子节点的最后</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node01 root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes bytes 接受字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是List形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node01&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个ArrayList</span></span><br><span class="line">        List&lt;Node01&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历list，统计每一个byte出现的次数 -&gt; map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(b);</span><br><span class="line">            <span class="comment">//Map还没有这个字符数据，第一次则执行如下</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//已经存在了执行如下</span></span><br><span class="line">                map.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入list集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node01</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过List创建赫夫曼树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node01 <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node01&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="comment">//取出第一棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二棵最小的二叉树</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点 没有data，只有权值</span></span><br><span class="line">            <span class="type">Node01</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node01</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将处理过的两颗二叉树从list中移除</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的二叉树加入到list集合中</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node01</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node01&gt; &#123;</span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node01 left;</span><br><span class="line">    Node01 right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node01</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node01 o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node[data = &quot;</span> + data + <span class="string">&quot; , weight = &quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="赫夫曼编码压缩文件注意事项"><a class="markdownIt-Anchor" href="#赫夫曼编码压缩文件注意事项">#</a> 赫夫曼编码压缩文件注意事项</h4>
<ol>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视频，ppt，等等文件</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件 (二进制，文本文件)</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显</li>
</ol>
<h3 id="二叉排序树"><a class="markdownIt-Anchor" href="#二叉排序树">#</a> 二叉排序树</h3>
<p><strong>先看一个需求</strong></p>
<p>给你一个数列 {7,3,10,12,5,1,9} ，要求能够高效的完成对数据的查询和添加。</p>
<p><strong>解决方案分析</strong></p>
<ol>
<li>
<p><strong>数组未排序</strong></p>
<ol>
<li>优点：直接在数组尾添加，速度快。</li>
<li>缺点：查找速度慢</li>
</ol>
</li>
<li>
<p><strong>数组排序</strong></p>
<ol>
<li>优点：可以使用二分查找，查找速度快</li>
<li>缺点：为了保证数组有序在添加新数据时，找到插入位置后，后面的数据需要整体移动，速度慢</li>
</ol>
</li>
<li>
<p><strong>使用链式存储 —— 链表</strong></p>
<p>不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动</p>
</li>
</ol>
<p><strong>二叉排序树介绍</strong></p>
<p>二叉排序树：<strong>BST：(Binary Sort(Search)Tree)</strong>，对于二叉排序树的任何一个<strong>非叶子结点</strong>，要求如下：</p>
<ul>
<li>左子节点的值比当前节点<sup>当前节点指的父节点</sup>的值小。</li>
<li>右子节点的值比当前节点 ^^ 的值大。</li>
</ul>
<p><mark>特别说明</mark>：如果有相同的值，可以将该节点放在左子节点或右子节点。</p>
<p>比如针对前面的数据 {7,3,10,12,5,1,9}，对应的二叉排序树为：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230707160016773.png" alt="image-20230707160016773"></p>
<ol>
<li>从根节点开始，发现比 7 小，直接往左子树查找，相当于直接折半了。</li>
<li>比 3 小，再次折半</li>
<li>比 1 大，直接挂在 1 的有节点</li>
</ol>
<h4 id="二叉排序树创建和遍历"><a class="markdownIt-Anchor" href="#二叉排序树创建和遍历">#</a> 二叉排序树<mark>创建</mark>和<mark>遍历</mark></h4>
<p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如：数组为 Array {7,3,10,12,5,1,9} ，创建成对应的二叉排序树为：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230707185816753.png" alt="image-20230707185816753"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/719:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySort</span> <span class="variable">binarySort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySort.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------中序遍历二叉排序树------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断root根节点如果为null则将传入的当前赋值为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用add方法添加传入的节点</span></span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果根节点不为null则开始中序遍历二叉排序树</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加传入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值是否小于当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的左子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空则将传入的节点赋值到左子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的右子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空将传入的节点赋值到当前节点的右子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉排序树中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉排序树的删除"><a class="markdownIt-Anchor" href="#二叉排序树的删除">#</a> 二叉排序树的<mark>删除</mark></h4>
<p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p>
<ol>
<li>删除<mark>叶子节点</mark> (比如：2,5,9,12)</li>
<li>删除<mark>只有一颗子树的节点</mark> (比如：1)</li>
<li>删除<mark>有两颗子树的节点</mark> (比如：7,3,10)</li>
</ol>
<p>​																								<strong>示意图</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230707193738478.png" alt="image-20230707193738478"></p>
<h4 id="删除叶子节点"><a class="markdownIt-Anchor" href="#删除叶子节点">#</a> 删除<mark>叶子节点</mark></h4>
<p>删除的节点是叶子节点，即该节点下没有左右子节点。</p>
<p><strong>思路分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种情况:</span><br><span class="line">删除叶子节点 (比如：2, 5, 9, 12)</span><br><span class="line">思路</span><br><span class="line">(1) 需求先去找到要删除的结点  targetNode</span><br><span class="line">(2)  找到targetNode 的 父结点 parent </span><br><span class="line">(3)  确定 targetNode 是 parent的左子结点 还是右子结点</span><br><span class="line">(4)  根据前面的情况来对应删除</span><br><span class="line">左子结点 parent.left = null</span><br><span class="line">右子结点 parent.right = null;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230707194108379.png" alt="image-20230707194108379"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/719:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySort</span> <span class="variable">binarySort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySort.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------中序遍历二叉排序树------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子节点</span></span><br><span class="line">        binarySort.delNode(<span class="number">10</span>);<span class="comment">//因为有子节点 所以删除无效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------删除节点后------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        binarySort.delNode(<span class="number">1</span>);<span class="comment">//因为没有子节点 所以删除成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------删除节点后------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断root根节点如果为null则将传入的当前赋值为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用add方法添加传入的节点</span></span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果根节点不为null则开始中序遍历二叉排序树</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的节点，targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">           <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个节点则删除即可</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//去查找targetNode的父节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//判断targetNode节点是父节点的左子节点还是右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value)<span class="comment">//是左子节点</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value)<span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的节点的值 [目标值]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的节点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除节点的父节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点就是要删除的节点的父节点则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value ||</span><br><span class="line">                <span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向左子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向右子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//没有找到父节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加传入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值是否小于当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的左子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空则将传入的节点赋值到左子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的右子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空将传入的节点赋值到当前节点的右子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉排序树中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除节点有一个子节点"><a class="markdownIt-Anchor" href="#删除节点有一个子节点">#</a> 删除<mark>节点有一个子节点</mark></h4>
<p>删除的节点有一个子节点，该节点有左子节点或者右子节点。比如这里的 1</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230709150143209.png" alt="image-20230709150143209"></p>
<p>思路分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第二种情况: 删除只有一颗子树的节点 比如 1</span><br><span class="line">思路</span><br><span class="line">(1) 需求先去找到要删除的结点  targetNode</span><br><span class="line">(2)  找到targetNode 的 父结点 parent </span><br><span class="line">(3) 确定targetNode 的子结点是左子结点还是右子结点</span><br><span class="line">(4) targetNode 是 parent 的左子结点还是右子结点</span><br><span class="line">(5) 如果targetNode 有左子结点</span><br><span class="line">5. 1 如果 targetNode 是 parent 的左子结点</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">5.2  如果 targetNode 是 parent 的右子结点</span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">(6) 如果targetNode 有右子结点</span><br><span class="line">6.1 如果 targetNode 是 parent 的左子结点</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">6.2 如果 targetNode 是 parent 的右子结点</span><br><span class="line">parent.right = targetNode.right</span><br></pre></td></tr></table></figure>
<p><img data-src="./images/image-20230707194108379-1688886389817-1.png" alt="image-20230707194108379"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/719:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySort</span> <span class="variable">binarySort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySort.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------中序遍历二叉排序树------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子节点</span></span><br><span class="line">        binarySort.delNode(<span class="number">1</span>);<span class="comment">//因为有子节点 所以删除无效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------删除节点后------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断root根节点如果为null则将传入的当前赋值为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用add方法添加传入的节点</span></span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果根节点不为null则开始中序遍历二叉排序树</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的节点，targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">           <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个节点则删除即可</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//去查找targetNode的父节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//判断targetNode节点是父节点的左子节点还是右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value)<span class="comment">//是左子节点</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value)<span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="comment">//删除只有一个叶子节点的子树节点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span>)<span class="comment">//如果要删除的节点有左节点</span></span><br><span class="line">                   <span class="keyword">if</span>(parent != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">if</span>(parent.left.value == value)<span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                           parent.left = targetNode.left;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           parent.right = targetNode.left;</span><br><span class="line">           				<span class="keyword">else</span> </span><br><span class="line">                          root = targetNode.left;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//如果要删除的节点有右子节点</span></span><br><span class="line">                   <span class="keyword">if</span>(parent != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                       <span class="keyword">if</span>(parent.left.value == value)</span><br><span class="line">                           parent.left = targetNode.right;</span><br><span class="line">                       <span class="keyword">else</span><span class="comment">//如果targetNode是parent的右子节点</span></span><br><span class="line">                           parent.right = targetNode.right;</span><br><span class="line">           			 <span class="keyword">else</span></span><br><span class="line">                       root = targetNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的节点的值 [目标值]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的节点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除节点的父节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点就是要删除的节点的父节点则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value ||</span><br><span class="line">                <span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向左子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向右子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//没有找到父节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加传入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值是否小于当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的左子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空则将传入的节点赋值到左子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的右子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空将传入的节点赋值到当前节点的右子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉排序树中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除节点有两个子节点"><a class="markdownIt-Anchor" href="#删除节点有两个子节点">#</a> 删除<mark>节点有两个子节点</mark></h4>
<p>删除的节点有两个子节点，即该节点有左子节点和右子节点。比如  7,3,10</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230709150453717.png" alt="image-20230709150453717"></p>
<p>思路分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )</span><br><span class="line">思路</span><br><span class="line">(1) 需求先去找到要删除的结点  targetNode</span><br><span class="line">(2)  找到targetNode 的 父结点 parent </span><br><span class="line">(3)  从targetNode 的右子树找到最小的结点</span><br><span class="line">(4) 用一个临时变量，将 最小结点的值保存 temp = 11</span><br><span class="line">(5)  删除该最小结点</span><br><span class="line">(6)  targetNode.value = temp</span><br></pre></td></tr></table></figure>
<p><img data-src="./images/image-20230707194108379-1688886398397-4.png" alt="image-20230707194108379"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/719:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">BinarySort</span> <span class="variable">binarySort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySort</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySort.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------中序遍历二叉排序树------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子节点</span></span><br><span class="line">        binarySort.delNode(<span class="number">1</span>);<span class="comment">//因为有子节点 所以删除无效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------删除节点后------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line"></span><br><span class="line">        binarySort.delNode(<span class="number">10</span>);<span class="comment">//因为有子节点 所以删除无效</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------删除节点后------------&quot;</span>);</span><br><span class="line">        binarySort.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断root根节点如果为null则将传入的当前赋值为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用add方法添加传入的节点</span></span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果根节点不为null则开始中序遍历二叉排序树</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的节点，targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">           <span class="comment">//如果没有找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果我们发现当前这个二叉排序树只有一个节点则删除即可</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//去查找targetNode的父节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//判断targetNode节点是父节点的左子节点还是右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value)<span class="comment">//是左子节点</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value)<span class="comment">//是右子节点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>)&#123;<span class="comment">//删除有两个叶子节点的子树</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = min;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="comment">//删除只有一个叶子节点的子树节点</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span>)<span class="comment">//如果要删除的节点有左节点</span></span><br><span class="line">                   <span class="keyword">if</span>(parent != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">if</span>(parent.left.value == value)<span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                           parent.left = targetNode.left;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           parent.right = targetNode.left;</span><br><span class="line">           			 <span class="keyword">else</span></span><br><span class="line">                       root = targetNode.left;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//如果要删除的节点有右子节点</span></span><br><span class="line">                   <span class="keyword">if</span>(parent != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">                       <span class="keyword">if</span>(parent.left.value == value)</span><br><span class="line">                           parent.left = targetNode.right;</span><br><span class="line">                       <span class="keyword">else</span><span class="comment">//如果targetNode是parent的右子节点</span></span><br><span class="line">                           parent.right = targetNode.right;</span><br><span class="line">           		     <span class="keyword">else</span></span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.返回 以Node为根节点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     * 2.删除node，为根节点的二叉排序树的最小节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的节点(当做二叉排序树的根节点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的以node 为根节点的二叉排序树的最小节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delRightTreeMin</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环左子节点到最底下就是最小值</span></span><br><span class="line">        <span class="keyword">while</span>(target.left != <span class="literal">null</span>)</span><br><span class="line">            target = target.left;</span><br><span class="line">       </span><br><span class="line">		 <span class="comment">//这时target就只指向了最小节点</span></span><br><span class="line">        <span class="comment">//删除最小节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的节点的值 [目标值]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 找到返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的节点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回要删除节点的父节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前节点就是要删除的节点的父节点则返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value ||</span><br><span class="line">                <span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向左子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//向右子树递归查找</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//没有找到父节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加传入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的节点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的节点的值是否小于当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的左子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空则将传入的节点赋值到左子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前节点的右子节点是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//为空将传入的节点赋值到当前节点的右子节点中</span></span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉排序树中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树avl树"><a class="markdownIt-Anchor" href="#平衡二叉树avl树">#</a> 平衡二叉树 (AVL 树)</h3>
<p>看一个案例 (<mark>说明二叉排序树可能的问题</mark>)</p>
<p>给你一个数列 {1,2,3,4,5,6}，要求创建一颗二叉排序树 (BST)，并分析问题所在。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230709181533895.png" alt="image-20230709181533895"></p>
<p><strong>左边 BST 存在的问题分析</strong>：</p>
<ol>
<li><mark>左子树全部为空</mark>，从形式上看，更像一个<mark>单链表</mark>。</li>
<li><mark>插入速度没有影响</mark>。</li>
<li><mark>查询速度明显降低</mark> (因为<mark>需要依次比较</mark>)，不能发挥 BST 的优势，因为<mark>每次还需要比较左子树</mark>，其<mark>查询速度比单链表还慢</mark></li>
<li>解决方案 ——<strong> 平衡二叉树 (AVL)</strong></li>
</ol>
<p><strong>基本介绍</strong></p>
<ol>
<li><strong>平衡二叉树</strong>也叫<mark>平衡二叉搜索树</mark> (<strong>Self-balancing binary search tree</strong>) 又被称为 <mark>AVL 树</mark>，可以<mark>保证查询效率较高</mark></li>
<li>具有以下<strong>特点</strong>：它是一颗<mark>空树</mark>或它的<mark>左右两个子树的高度差<strong style="color:red"><sup>只看高度不能看左右节点</sup></strong>的绝对值不超过 1 并且左右两个子树都是一颗平衡二叉树</mark>。平衡二叉树的常用实现方法有<mark>红黑树</mark>，<mark>AVL<strong style="color:red"><sup>指定是算法而不是树</sup></strong></mark>，<mark>替罪羊树</mark>，<mark>Treap</mark>，<mark>伸展树等</mark>。</li>
<li>举例说明，看看下面哪些是 AVL 树，为什么？</li>
</ol>
<p>​							<strong>图一</strong>									  				<strong>图二</strong>								 								<strong>图三</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230710150129892.png" alt="image-20230710150129892"></p>
<p><strong>分析</strong>：</p>
<p>图一：左子树高度：2，右子树高度：1 。差值：1</p>
<p>图二：左子树高度：2，右子树高度：2 。差值：0</p>
<p>图三：左子树高度：3，右子树高度：1 。差值：2</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230710151042079.png" alt="image-20230710151042079"></p>
<h4 id="单旋转左旋转"><a class="markdownIt-Anchor" href="#单旋转左旋转">#</a> 单旋转 (左旋转)</h4>
<p>如果是左旋转就属于是单旋转</p>
<p 4,3,6,5,7,8=""><strong>要求</strong>：给你一个数列，创建出对应的平衡二叉树，数列</p>
<p><strong>左旋转的目的</strong>：降低右子树的高度</p>
<p><strong>思路分析 (示意图)</strong></p>
<p>下图红线部分是调整流程。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230710153838284.png" alt="image-20230710153838284"></p>
<p>按照规则调整完成之后，形成了下面这样一棵树</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230710153954253.png" alt="image-20230710153954253"></p>
<p>完整流程如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230710154031528.png" alt="image-20230710154031528"></p>
<p>插入 8 时，发现左右子树高度相差大于 1，则进行左旋转；</p>
<ol>
<li>创建一个新的节点 <code>newNode</code> ，值等于当前 <strong>根节点</strong> 的值 (以 4 创建)</li>
<li>把新节点的 左子树 设置为当前节点的 <strong>左子树</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode.left = left;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>把新节点的 <strong>右子树</strong> 设置为<mark>当前节点</mark> <mark>右子树</mark>的<mark>左子树</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode.right = right.left;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>把 <mark>当前节点</mark> 的<mark>值换为</mark> <mark>右子节点 的值</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = right.value;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>把 <mark>当前节点</mark> 的<mark>右子树设置为</mark> <mark>右子树的右子树</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right = right.right;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>把 <mark>当前节点</mark> 的<mark>左子树设置为新节点</mark></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left = newNode;</span><br></pre></td></tr></table></figure>
<p><strong style="color:red">注</strong>：图左边是调整期，右边是调整后。注意调整期的 6 那个节点，<strong>调整之后，没有节点指向它了</strong>。也就是说，遍历的时候它是不可达的。那么将会自动的被垃圾回收掉。</p>
<h5 id="树高度计算"><a class="markdownIt-Anchor" href="#树高度计算">#</a> 树高度计算</h5>
<p>前面说过，平衡二叉树是为了解决二叉排序树中可能出现的查找效率问题，那么基本上的代码都可以在之前的二叉排序树上进行优化。那么下面只给出当前主题相关的代码，最后放出一份完整的代码。</p>
<p>树的高度计算，我们需要得到 3 个高度：</p>
<ol>
<li>这棵树的整体高度</li>
<li>左子树的高度</li>
<li>右子树的高度</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1015:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            tree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        tree.infixOrder();</span><br><span class="line">        System.out.printf(<span class="string">&quot;树高度：%d\n&quot;</span>, tree.root.height());<span class="comment">//4</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左树高度：%d\n&quot;</span>, tree.root.leftHeight());<span class="comment">//1</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右数高度：%d\n&quot;</span>, tree.root.rightHeight());<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            root = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度,以当前节点为跟节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用了递归：返回了左右子树，最高的那一个数值。</span></span><br><span class="line"><span class="comment">         * 递归原理： 第一个开始统计的时候，一定是一个叶子节点。</span></span><br><span class="line"><span class="comment">         *          根据这个逻辑：叶子节点的Math.max(0,0) = 0</span></span><br><span class="line"><span class="comment">         *          因为当前节点算一层，所以 +1;</span></span><br><span class="line"><span class="comment">         *          返回到上一层的时候，至少是这样：Math.max(1,0) = 1</span></span><br><span class="line"><span class="comment">         *          然后把自己本身的层+1.以此类推，返回到根节点的时候，就拿到了从包含根节点的树的高度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//+1；因为本身节点也要算上</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(),</span><br><span class="line">                right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点进行添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="旋转"><a class="markdownIt-Anchor" href="#旋转">#</a> 旋转</h5>
<p><strong>说下旋转的时机</strong>：也就是什么时候采取做旋转的操作</p>
<p><strong>当然是</strong>：当 <mark>右子树高度 - 左子树高度 &gt; 1</mark> 时，才执行左旋转。</p>
<p>这里就得到一些信息：</p>
<ol>
<li>
<p>每次添加完一个节点后，就需要检查树的高度</p>
</li>
<li>
<p>满足 <mark>右子树高度 - 左子树高度 &gt; 1</mark>，那么一定满足下面的条件：</p>
<ol>
<li>
<p>左子树高度为 1</p>
</li>
<li>
<p>右子树高度为 3</p>
<p>也就是符合以下这张图：</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711110051128.png" alt="image-20230711110051128"></p>
<p>也就是有如上的信息逻辑，在实现旋转的时候，只要按照思路分析写就可以了，不需要进行边界判断了。</p>
</li>
<li>
<p>代码实现：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1015:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            tree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        tree.infixOrder();</span><br><span class="line">        System.out.printf(<span class="string">&quot;树高度：%d\n&quot;</span>, tree.root.height());<span class="comment">//3</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左树高度：%d\n&quot;</span>, tree.root.leftHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右数高度：%d\n&quot;</span>, tree.root.rightHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前Root节点为: &quot;</span>+tree.getRoot());<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            root = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度,以当前节点为跟节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用了递归：返回了左右子树，最高的那一个数值。</span></span><br><span class="line"><span class="comment">         * 递归原理： 第一个开始统计的时候，一定是一个叶子节点。</span></span><br><span class="line"><span class="comment">         *          根据这个逻辑：叶子节点的Math.max(0,0) = 0</span></span><br><span class="line"><span class="comment">         *          因为当前节点算一层，所以 +1;</span></span><br><span class="line"><span class="comment">         *          返回到上一层的时候，至少是这样：Math.max(1,0) = 1</span></span><br><span class="line"><span class="comment">         *          然后把自己本身的层+1.以此类推，返回到根节点的时候，就拿到了从包含根节点的树的高度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//+1；因为本身节点也要算上</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(),</span><br><span class="line">                right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建左旋转方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个新的节点newNode(以4这个值创建),创建一个新的节点，值等于当前根节点的值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//2.把新节点的左子树设置为当前节点的左子树</span></span><br><span class="line">        newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">        <span class="comment">//3.把新节点的右子树设置为当前节点的右子树的左子树</span></span><br><span class="line">        newNode.right = <span class="built_in">this</span>.right.left;</span><br><span class="line">        <span class="comment">//4.把当前节点的值换为右子节点的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">        <span class="comment">//5.把当前节点的右子树设置为右子树的右子树</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">        <span class="comment">//6.把当前节点的左子树设置为新节点</span></span><br><span class="line">        <span class="built_in">this</span>.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点进行添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 旋转的时候有以下规则</span></span><br><span class="line"><span class="comment">         * 没添加一个节点后：检查树的高度是否平衡</span></span><br><span class="line"><span class="comment">         *         如果右子树高度 - 左子树高度 &gt; 1 ，则左旋转</span></span><br><span class="line"><span class="comment">         *         也就是说：每次旋转的层只涉及到4层(对照笔记上的图示理解)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>)</span><br><span class="line">            leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&#123;value=3&#125;</span><br><span class="line">Node&#123;value=4&#125;</span><br><span class="line">Node&#123;value=5&#125;</span><br><span class="line">Node&#123;value=6&#125;</span><br><span class="line">Node&#123;value=7&#125;</span><br><span class="line">Node&#123;value=8&#125;</span><br><span class="line">树高度：3</span><br><span class="line">左树高度：2</span><br><span class="line">右数高度：2</span><br><span class="line">当前Root节点为: Node&#123;value=6&#125;</span><br></pre></td></tr></table></figure>
<p>看完代码之后，它的旋转其实就是，将 root 节点，往下沉到了 root.right 节点下面。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711110535115.png" alt="image-20230711110535115"></p>
<p>看着上图，是否有想过，貌似根本就可以不用前面讲解的 6 个步骤来旋转：</p>
<ol>
<li>不用创建新节点</li>
<li>直接将 node 节点下沉</li>
<li>更改 node 的 right 节点为 right.left</li>
<li>更改 right.left = node</li>
</ol>
<p>其实就已经完成了旋转。但是你仔细想一想，旋转逻辑是写在 node 里面的，avlTree 中的引用如何改变？除非把旋转逻辑移动到 avlTree 中去，就可以省略掉新节点的步骤来完成。</p>
<h4 id="右旋转"><a class="markdownIt-Anchor" href="#右旋转">#</a> 右旋转</h4>
<ul>
<li>左旋转：右 - 左 &gt; 1 ，把右边的往左边旋转一层</li>
<li>右旋转：左 - 右 &gt; 1 ，把左边的往右边旋转一层</li>
</ul>
<p>它们是反着来得思路如下：</p>
<ol>
<li>创建一个新的节点 newNode，值等于当前 <strong>根节点</strong> 的值 (以 10 创建)</li>
<li>把新节点的  <strong>右子树</strong>  设置为当前节点的 <strong>右子树</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode.right = <span class="built_in">this</span>.right;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>把新节点的  <strong>左子树</strong>  设置为当前节点的  <strong>左子树的右子树</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode.left = <span class="built_in">this</span>.left.right;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>把 <strong>当前节点</strong> 的<strong>值</strong>换为  <strong>左子节点</strong>  的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>把  <strong>当前节点</strong> 的<strong>左子树</strong>设置为 <strong>左子树的左子树</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>把 <strong>当前节点</strong> 的<strong>右子树</strong>设置为<strong>新节点</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.right = newNode;</span><br></pre></td></tr></table></figure>
<p>上述步骤就是对应下图的描述：查看图示更清楚</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711114545279.png" alt="image-20230711114545279"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1015:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            tree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        tree.infixOrder();</span><br><span class="line">        System.out.printf(<span class="string">&quot;树高度：%d\n&quot;</span>, tree.root.height());<span class="comment">//3</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左树高度：%d\n&quot;</span>, tree.root.leftHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右数高度：%d\n&quot;</span>, tree.root.rightHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前Root节点为: &quot;</span>+tree.getRoot());<span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            root = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度,以当前节点为跟节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用了递归：返回了左右子树，最高的那一个数值。</span></span><br><span class="line"><span class="comment">         * 递归原理： 第一个开始统计的时候，一定是一个叶子节点。</span></span><br><span class="line"><span class="comment">         *          根据这个逻辑：叶子节点的Math.max(0,0) = 0</span></span><br><span class="line"><span class="comment">         *          因为当前节点算一层，所以 +1;</span></span><br><span class="line"><span class="comment">         *          返回到上一层的时候，至少是这样：Math.max(1,0) = 1</span></span><br><span class="line"><span class="comment">         *          然后把自己本身的层+1.以此类推，返回到根节点的时候，就拿到了从包含根节点的树的高度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//+1；因为本身节点也要算上</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(),</span><br><span class="line">                right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建右旋转方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个新的节点newNode(以10这个值创建)</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//2.把新节点的右子树设置为当前节点的右子树</span></span><br><span class="line">        newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">        <span class="comment">//3.把新节点的左子树设置为当前节点的左子树的右子树</span></span><br><span class="line">        newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">        <span class="comment">//4.把当前节点的值换为左子树的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br><span class="line">        <span class="comment">//5.把当前节点的左子树设置为左子树的左子树</span></span><br><span class="line">        <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">        <span class="comment">//6.把当前节点的右子树设置为新节点</span></span><br><span class="line">        <span class="built_in">this</span>.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建左旋转方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个新的节点newNode(以4这个值创建),创建一个新的节点，值等于当前根节点的值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//2.把新节点的左子树设置为当前节点的左子树</span></span><br><span class="line">        newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">        <span class="comment">//3.把新节点的右子树设置为当前节点的右子树的左子树</span></span><br><span class="line">        newNode.right = <span class="built_in">this</span>.right.left;</span><br><span class="line">        <span class="comment">//4.把当前节点的值换为右子节点的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">        <span class="comment">//5.把当前节点的右子树设置为右子树的右子树</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">        <span class="comment">//6.把当前节点的左子树设置为新节点</span></span><br><span class="line">        <span class="built_in">this</span>.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点进行添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 旋转的时候有以下规则</span></span><br><span class="line"><span class="comment">         * 没添加一个节点后：检查树的高度是否平衡</span></span><br><span class="line"><span class="comment">         *         如果右子树高度 - 左子树高度 &gt; 1 ，则左旋转</span></span><br><span class="line"><span class="comment">         *         也就是说：每次旋转的层只涉及到4层(对照笔记上的图示理解)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>)</span><br><span class="line">            leftRotate();</span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>)</span><br><span class="line">            rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&#123;value=6&#125;</span><br><span class="line">Node&#123;value=7&#125;</span><br><span class="line">Node&#123;value=8&#125;</span><br><span class="line">Node&#123;value=9&#125;</span><br><span class="line">Node&#123;value=10&#125;</span><br><span class="line">Node&#123;value=12&#125;</span><br><span class="line">树高度：3</span><br><span class="line">左树高度：2</span><br><span class="line">右数高度：2</span><br><span class="line">当前Root节点为: Node&#123;value=8&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单旋转的strong-stylecolorred注意事项strong"><a class="markdownIt-Anchor" href="#单旋转的strong-stylecolorred注意事项strong">#</a> <mark>单旋转</mark>的<strong style="color:red">注意事项</strong></h3>
<p>有些情况下，<strong style="color:red">单旋转不能完成平衡二叉树的转换如比数列</strong> {10,11,7,6,8,9} 或者 {2,1,6,5,7,3}; 运行原来的代码可以看到，并没有转成 AVL 树。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.png" alt="问题分析"></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711145636238.png" alt="image-20230711145636238"></p>
<p><strong>问题分析</strong>：</p>
<p>左侧这个树满足  <code>leftHeight - rightHeight &gt; 1</code> ，也就是满足右旋转，旋转之后，树结构变化了。但是还是一个非平衡二叉树</p>
<p>它的主要原因是：root 左子树的 左子树高度 小于 右子树的高度。即：节点 7 的左子树高度小于右子树的高度。</p>
<h3 id="解决办法双旋转"><a class="markdownIt-Anchor" href="#解决办法双旋转">#</a> 解决办法 —— 双旋转</h3>
<ol>
<li>先将 7 这个节点为 root 节点，进行左旋转</li>
<li>再将原始的 root 节点进行右旋转</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711145017212.png" alt="123"></p>
<p><strong>其实可以参考下面两个单旋转的例子，它有这样一个特点</strong>：</p>
<ol>
<li><strong>右旋转</strong>：
<ul>
<li>root 的 left 左子树高度 大于 右子树高度</li>
<li>右旋转的时候，会将 left.right 旋转到 right.left 节点上个</li>
</ul>
</li>
<li><strong>左旋转</strong>：
<ul>
<li>root 的 right 右子树高度 大于 左子树高度</li>
<li>左旋转的时候，会将 right.left 旋转到 left.right 上</li>
</ul>
</li>
</ol>
<p>如果不满足这个要求，在第二个操作的时候，就会导致 2 层的高度被旋转到 1 层的节点下面，导致不平衡了。</p>
<p><strong>解决代码如下</strong>：</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1015:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AVLTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;;</span></span><br><span class="line">       <span class="comment">//下面两个数组是导致单旋转失败的例子</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 11, 7, 6, 8, 9&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            tree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        tree.infixOrder();</span><br><span class="line">        System.out.printf(<span class="string">&quot;树高度：%d\n&quot;</span>, tree.root.height());<span class="comment">//3</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;左树高度：%d\n&quot;</span>, tree.root.leftHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;右数高度：%d\n&quot;</span>, tree.root.rightHeight());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前Root节点为: &quot;</span> + tree.getRoot());<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取root节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            root = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度,以当前节点为跟节点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里使用了递归：返回了左右子树，最高的那一个数值。</span></span><br><span class="line"><span class="comment">         * 递归原理： 第一个开始统计的时候，一定是一个叶子节点。</span></span><br><span class="line"><span class="comment">         *          根据这个逻辑：叶子节点的Math.max(0,0) = 0</span></span><br><span class="line"><span class="comment">         *          因为当前节点算一层，所以 +1;</span></span><br><span class="line"><span class="comment">         *          返回到上一层的时候，至少是这样：Math.max(1,0) = 1</span></span><br><span class="line"><span class="comment">         *          然后把自己本身的层+1.以此类推，返回到根节点的时候，就拿到了从包含根节点的树的高度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//+1；因为本身节点也要算上</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(),</span><br><span class="line">                right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建有旋转方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个新的节点newNode(以10这个值创建)</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//2.把新节点的右子树设置为当前节点的右子树</span></span><br><span class="line">        newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">        <span class="comment">//3.把新节点的左子树设置为当前节点的左子树的右子树</span></span><br><span class="line">        newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">        <span class="comment">//4.把当前节点的值换为左子树的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br><span class="line">        <span class="comment">//5.把当前节点的左子树设置为左子树的左子树</span></span><br><span class="line">        <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">        <span class="comment">//6.把当前节点的右子树设置为新节点</span></span><br><span class="line">        <span class="built_in">this</span>.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建左旋转方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个新的节点newNode(以4这个值创建),创建一个新的节点，值等于当前根节点的值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">//2.把新节点的左子树设置为当前节点的左子树</span></span><br><span class="line">        newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">        <span class="comment">//3.把新节点的右子树设置为当前节点的右子树的左子树</span></span><br><span class="line">        newNode.right = <span class="built_in">this</span>.right.left;</span><br><span class="line">        <span class="comment">//4.把当前节点的值换为右子节点的值</span></span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">        <span class="comment">//5.把当前节点的右子树设置为右子树的右子树</span></span><br><span class="line">        <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">        <span class="comment">//6.把当前节点的左子树设置为新节点</span></span><br><span class="line">        <span class="built_in">this</span>.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入要添加的节点进行添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">this</span>.right.add(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 旋转的时候有以下规则</span></span><br><span class="line"><span class="comment">         * 没添加一个节点后：检查树的高度是否平衡</span></span><br><span class="line"><span class="comment">         *         如果右子树高度 - 左子树高度 &gt; 1 ，则左旋转</span></span><br><span class="line"><span class="comment">         *         也就是说：每次旋转的层只涉及到4层(对照笔记上的图示理解)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对右子节点进行右旋转</span></span><br><span class="line">                right.rightRotate();</span><br><span class="line">                <span class="comment">//然后再对当前节点进行左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//直接进行左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            <span class="comment">//旋转好后阻止程序的向后执行否则就会产生错误的操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                <span class="comment">//先对当前节点的左节点(左子树) -&gt; 左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前节点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//直接进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历排序二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&#123;value=1&#125;</span><br><span class="line">Node&#123;value=2&#125;</span><br><span class="line">Node&#123;value=3&#125;</span><br><span class="line">Node&#123;value=5&#125;</span><br><span class="line">Node&#123;value=6&#125;</span><br><span class="line">Node&#123;value=7&#125;</span><br><span class="line">树高度：3</span><br><span class="line">左树高度：2</span><br><span class="line">右数高度：2</span><br><span class="line">当前Root节点为: Node&#123;value=5&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多路查找树"><a class="markdownIt-Anchor" href="#多路查找树">#</a> 多路查找树</h2>
<p><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8EB%E6%A0%91">二叉树与 B 树</a></p>
<p><a href="#%E6%A0%91">树</a></p>
<p>[B 树，B+ 树，B <code>*</code>  树](#B 树，B+ 树，B <code>*</code>  树)</p>
<hr>
<p>​																				  		<strong>钢达姆机器人</strong></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/%E9%92%A2%E8%BE%BE%E5%A7%86%E6%9C%BA%E5%99%A8%E4%BA%BA.png" alt="钢达姆机器人"></p>
<h3 id="二叉树与b树"><a class="markdownIt-Anchor" href="#二叉树与b树">#</a> 二叉树与 B 树</h3>
<p>二叉树的问题分析</p>
<p>二叉树的操作效率较高，但是也存在问题，请看下面的二叉树</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711154532431.png" alt="image-20230711154532431"></p>
<p>层数：5</p>
<p>节点数量：31</p>
<ul>
<li>计算方式：2 ^ 5<sup> 层数</sup> - 1 = 31</li>
</ul>
<ol>
<li><mark>二叉树需要加载到内存的</mark>，如果二叉树的<mark>节点少</mark>，<mark>没</mark>有<mark>什么问题</mark>，但是如果二叉树的<mark>节点很多</mark> (比如 1 亿)，就<mark>存在</mark>如下<mark>问题</mark>：</li>
<li><strong>问题 1</strong>：在<mark>构建二叉树时</mark>，需要<mark>多次进行  <code>i/o</code>  操作</mark> (海量数据存在<mark>数据库</mark>或<mark>文件</mark>中)，节点海量，<mark>构建二叉树时，速度有影响</mark>。</li>
<li><strong>问题 2</strong>：<mark>节点海量</mark>，也会造成二叉树的<mark>高度很大</mark>，会<mark>降低操作速度</mark>。</li>
</ol>
<h4 id="多叉树"><a class="markdownIt-Anchor" href="#多叉树">#</a> 多叉树</h4>
<ol>
<li>在<font style="color:red">二叉树中</font>，每个节点有<font style="color:red">数据项</font>，<font style="color:red">最多有两个子节点</font>。如果<mark>允许每个节点可以有更多的数据项</mark>和<mark>更多的子节点</mark>，就是<mark>多叉树</mark> (multiway tree)</li>
<li>后面讲解的 2 - 3 树，2 - 3 - 4 树就是多叉树，<mark>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</mark>。</li>
<li>举例说明 (下面 2 - 3 树就是一颗多叉树)</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711155922937.png" alt="image-20230711155922937"></p>
<p>多叉树中，如果一个节点中存在了三个分叉则称为 <mark>3 节点</mark>。如果是两个分叉则称为 <mark>2 节点</mark>。</p>
<h4 id="b树的基本介绍"><a class="markdownIt-Anchor" href="#b树的基本介绍">#</a> B 树的基本介绍</h4>
<p>B 树通过重新组织节点，降低树的高度，并减少  <code>i/o</code>  读写次数来提升效率。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711161106696.png" alt="image-20230711161106696"></p>
<p>上图说明：</p>
<ul>
<li>
<p>一个 <strong>○</strong> 代表一个数项</p>
</li>
<li>
<p>一整个 <strong>○ ○ ○</strong> 的集合代表一个节点</p>
</li>
</ul>
<p><strong>优点理解</strong>：</p>
<ul>
<li>
<p>降低树的高度：</p>
<p>可以看到，一个节点中有很多数据项，就能大大减少节点数量，从而降低树的高度</p>
</li>
<li>
<p>减少  <code>I/O</code>  读写次数</p>
<p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页 (页的大小通常为 4K)，这样每个节点只需要一次  <code>i/o</code>  就可以完全载入。</p>
<p>这样说，你可能没有概念，举个例子：将树的度 M 设置为 1024 ，在 600 亿个元素中最多只需要 4 次  <code>i/o</code>  操作就可以读取到想要的元素，B 树 (B+) 宽泛应用于文件存储系统以及数据库系统中。</p>
<p>什么是 <strong>度</strong>？</p>
</li>
<li>
<p>节点的度：</p>
<p>一个节点下的子树节点个数就是 节点的度。</p>
</li>
<li>
<p>树的度：</p>
<p>指一颗树中 ，节点的度最大的哪一个值。</p>
</li>
</ul>
<h3 id="树"><a class="markdownIt-Anchor" href="#树">#</a> 树</h3>
<h4 id="2-3-树基本介绍"><a class="markdownIt-Anchor" href="#2-3-树基本介绍">#</a> 2 - 3 树基本介绍</h4>
<p><strong>2 - 3 树 是最简单的 B 树结构，具有如下特点</strong>：</p>
<ol>
<li>
<p><mark>2 - 3 树的所有叶子节点都在同一层</mark> (<strong>只要是 B 树都满足这个条件，就是满树</strong>)</p>
</li>
<li>
<p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</p>
<p>不能只有一个节点，<mark>说得通俗点就是不能比父节点的节点还少</mark></p>
</li>
<li>
<p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>
<p>不能有二个子节点，一个子节点，<mark>说得通俗点就是不能比父节点的节点还少</mark></p>
</li>
<li>
<p><mark>2 - 3 树</mark>是<mark>由二节点</mark>和<mark>三节点构成的树</mark>。</p>
</li>
</ol>
<h5 id="2-3-树构建图解"><a class="markdownIt-Anchor" href="#2-3-树构建图解">#</a> 2-3 树构建图解</h5>
<p>对数列 {16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成一个 2-3 树，那么它构建的规则要满足前面说的特点。下面进行图解后，你就明白，上面的特点是如何限制的。</p>
<p>有几个额外的注意事项：</p>
<ol>
<li>一个节点中，最多只允许放 2 个数据。</li>
<li>构建的树必须是有序的，也就是按照二叉排序 (BST) 的要求构建有序的树</li>
</ol>
<p>下面是图解步骤：</p>
<ol>
<li>添加 16,24</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173129240.png" alt="image-20230711173129240"></p>
<p>添加 16 时，没有数据，直接新建一个节点，放进去。</p>
<p>添加 24 时，发现有一个节点了，并且比 16 大， 此时该节点中只有一个数据，则将 24 放在 16 的右边。</p>
<ol start="2">
<li>添加 12</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173239395.png" alt="image-20230711173239395"></p>
<p>此时会发现，12 比 16 小，本来应该放在  16 的左边。此时发现这个节点 <strong>已经有两个数据了</strong>，那么就只能放在 <strong>左子节点</strong>。</p>
<p>如果直接将 12 放到   <code>16 , 24</code>  的左节点，就会破坏 2-3 树的条件：2  节点 ，要么没有子节点，要么有两个节点。</p>
<p>那么此时就只能将  <code>16,24</code>   这个节点进行拆分。如上图： 24  变成 16 的右节点，12 变成  16  的左节点。</p>
<p>这时就满足了 2-3 树 的特性。</p>
<ol start="3">
<li>添加 32</li>
</ol>
<p>这个就简单了，以现在的树结构，可以直接添加到 24 的 右边 ，变成  <code>24,32</code></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173649665.png" alt="image-20230711173649665"></p>
<ol start="4">
<li>添加 14</li>
</ol>
<p>这个也简单，直接添加到 12 的右边，变成  <code>12,14</code></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173735064.png" alt="image-20230711173735064"></p>
<ol start="5">
<li>添加 26</li>
</ol>
<p>此时应该添加到  <code>24,32</code>  的中间，由于一个节点只能添加两个数据，那么就需要拆分。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173823070.png" alt="image-20230711173823070"></p>
<p>为了满足 B 树特点，发现上层的  <code>16</code>  只有一个数，那么就补足它。组成  <code>16,26</code> 。</p>
<p>因为此时  <code>24,32</code>  <strong>这个节点，不满足 BST 的排序了</strong>，24 是小于 26 的。只能 32 满足。</p>
<p><strong>拆完上层，再拆本层</strong>：由于 24 介于  <code>16,24</code>  之间，<strong>则将它安排在 3 节点中的中间节点</strong>，  <code>24,32</code>  把 24 拆分出去了，只剩下  <code>32</code>  ，此时完全满足 B 树的特点</p>
<ol start="6">
<li>添加 34</li>
</ol>
<p>此时就简单了，添加到  <code>32,34</code>  中。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174145067.png" alt="image-20230711174145067"></p>
<ol start="7">
<li>添加 10</li>
</ol>
<p>此时应该添加到  <code>12,14</code>  的左侧，但是不满足条件：一个节点最多只能装 2 个数据。</p>
<p>放到  <code>12,14</code>  的左节点，也不满足条件：所有叶子节点必须在同一层，也不满足 2-3 树 节点的 数量要求。</p>
<p>那么此时就需要拆分，先看它们上层  <code>16,26</code>  是满 的，如何做呢？看下图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174344071.png" alt="image-20230711174344071"></p>
<p>左侧的拆分图，上面我们分析过了，不满足 B 树要求，那么就需要拆分成右图这样：</p>
<ul>
<li></li>
</ul>
<ol>
<li>
<p>将  <code>12,14</code>  中的 14 拆分成 右子节点 ，10 挂在 左节点。</p>
</li>
<li>
<p>此时不满足 B 树要求的，则将  <code>16,26</code>  中的 26 拆分成 右子节点。</p>
</li>
<li>
<p><code>24</code>  这个节点由于上层被拆分了，不满足在中间节点了。调整它的位置</p>
</li>
<li>
<p>原来的  <code>32,34</code>  节点调整为  <code>16</code>  的有节点。</p>
</li>
<li>
<p>添加 8</p>
<p>此时很简单，组成  <code>8,10</code>  即可</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174809201.png" alt="image-20230711174809201"></p>
</li>
<li>
<p>添加 28</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174827823.png" alt="image-20230711174827823"></p>
<p>这里有个小问题，此时 28 不是应该加在  <code>26,28</code>  吗？难道说还有一个规则？</p>
<ul>
<li><strong>只有一个数据的节点</strong>，下面只允许 <strong>最多右 2 个节点，要么没有</strong></li>
<li><strong>有 2 个数据的节点</strong>，下面只允许 <strong>最多 3 个节点，要么没有</strong></li>
</ul>
<ol start="10">
<li>添加 38</li>
</ol>
<p>此时就简单，直接组成  <code>34,38</code></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711175119632.png" alt="image-20230711175119632"></p>
<ol start="11">
<li>添加 20</li>
</ol>
<p>这个也简单，直接组成  <code>20,24</code></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711175153140.png" alt="image-20230711175153140"></p>
<h5 id="2-3树添加规则总结"><a class="markdownIt-Anchor" href="#2-3树添加规则总结">#</a> 2-3 树添加规则总结</h5>
<p>满足如下特点：</p>
<ol>
<li>
<p>所有  <mark>叶子节点</mark>  都在同一层</p>
<p>只要是 B 树都满足这个条件，就是<mark>满树</mark>。</p>
</li>
<li>
<p>有两个子节点的节点 叫  <mark>二节点</mark></p>
<p>二节点要么  <mark>没有子节点</mark> ，要么  <mark>必须有两个子节点</mark>。</p>
</li>
<li>
<p>有三个子节点的节点叫  <mark>三节点</mark></p>
<p>三节点要么  <mark>没有子节点</mark>，要么  <mark>必须有三个子节点</mark>。</p>
</li>
<li>
<p>2-3 树 是由 <mark>二节点</mark>  和  <mark>三节点</mark> 构成的树</p>
</li>
<li>
<p>构建的树，要满足二叉排序树（BST）的顺序。</p>
</li>
<li>
<p><mark>一个节点中，最多只允许放 2  个数据</mark>。</p>
</li>
<li>
<p><mark>只有一个数据的节点</mark>，下面只允许 <mark>最多有 2 个节点，要么没有</mark></p>
</li>
<li>
<p><mark>有 2 个数据的节点</mark>，下面只允许 <mark>最多有 3 个节点，要么没有</mark></p>
</li>
</ol>
<p>其它说明</p>
<p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。如图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711190603750.png" alt="image-20230711190603750"></p>
<h3 id="b树b-树b树"><a class="markdownIt-Anchor" href="#b树b-树b树">#</a> B 树，B+ 树，B <code>*</code>  树</h3>
<h4 id="b树的介绍"><a class="markdownIt-Anchor" href="#b树的介绍">#</a> B 树的介绍</h4>
<p><strong>B-tree</strong> 树即 <mark>B 树</mark>，<strong>B</strong> 即<mark> Balanced</mark>，平衡的意思。有人把 B-tree 翻译成 B - 树，容易让人产生<mark>误解</mark>。会以为 B - 树是一种树，而 B 树又是另一种树。实际上，<mark>B-tree 就是指的 B 树</mark>。</p>
<p>前面已经介绍了 2-3 树 和 2-3-4 树，它们就是 B 树 (英语: B-tree 也写成 B - 树)，这里我们再做一个说明，我们在学习 MySQL 时，经常听到说某种类型的索引是基于 B 树或者 B + 树的，如图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711191024778.png" alt="image-20230711191024778"></p>
<p><strong>B 树的说明</strong>:</p>
<ol>
<li>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>
<li>B - 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据.</li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<h4 id="b树的介绍-2"><a class="markdownIt-Anchor" href="#b树的介绍-2">#</a> B + 树的介绍</h4>
<p>B + 树是 B 树的变体，也是一种多路搜索树。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711194503904.png" alt="image-20230711194503904"></p>
<p><strong>B + 树的说明</strong>:</p>
<ol>
<li>B + 树的搜索与 B 树也基本相同，区别是 B + 树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>
<li>所有<strong>关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字 (数据) 恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B 树和 B + 树各有自己的应用场景，不能说 B + 树<strong>完全比</strong> B 树好，反之亦然.</li>
</ol>
<h4 id="b树的介绍-3"><a class="markdownIt-Anchor" href="#b树的介绍-3">#</a> B 树的介绍</h4>
<p>B * 树是 B + 树的变体，在 B + 树的非根和非叶子结点再增加指向兄弟的指针。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711195028517.png" alt="image-20230711195028517"></p>
<p><strong>B 树的说明</strong>:</p>
<ol>
<li>B * 树定义了非叶子结点关键字个数至少为 (2/3)*M，即块的最低使用率为 2/3，而 B + 树的块的最低使用率为 B + 树的 1/2。</li>
<li>从第 1 个特点我们可以看出，B * 树分配新结点的概率比 B + 树要低，空间使用率更高</li>
</ol>
<h2 id="图"><a class="markdownIt-Anchor" href="#图">#</a> 图</h2>
<p><strong>为什么要有图</strong></p>
<ol>
<li>前面我们学了线性表 和 树</li>
<li>线性表局限于一个直接前驱和一个直接后继的关系</li>
<li>树也只能有一个直接前驱也就是父节点</li>
<li>当我们需要表示多对多的关系时，这里我们就用到了图</li>
</ol>
<h3 id="图的举例说明"><a class="markdownIt-Anchor" href="#图的举例说明">#</a> 图的举例说明</h3>
<p>图是一种<mark>数据结构</mark>，其中节点可以具有<mark>零</mark>个或<mark>多</mark>个<mark>相邻元素</mark>。两个节点之间的连接称为 <mark>边</mark>。节点也可以称为<mark>顶点</mark>。如图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711200325089.png" alt="image-20230711200325089"></p>
<h3 id="图常用的概念"><a class="markdownIt-Anchor" href="#图常用的概念">#</a> 图常用的概念</h3>
<ol>
<li>顶点 (vertex)</li>
<li>边 (edge)</li>
<li>路径</li>
<li>无向图 (下图)</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711200430332.png" alt="image-20230711200430332"></p>
<ul>
<li>
<p><strong>无向图</strong>：顶点之间的连接<mark>没有方向</mark>，比如 A - B，既可以是 A - B 也可以 B - A</p>
</li>
<li>
<p><strong>路径</strong>：比如从 D - C 的路径有</p>
</li>
</ul>
<ol>
<li>
<p>D - B - C</p>
</li>
<li>
<p>D - A - B - C</p>
</li>
<li>
<p>有向图 (下图)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711200958618.png" alt="image-20230711200958618"></p>
<ul>
<li><strong>有向图</strong>：顶点之间的连接<mark>有方向</mark>，比如 A - B ， 只能是 A -&gt; B 不能是 B -&gt; A。</li>
</ul>
</li>
<li>
<p>带权图</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711201041513.png" alt="image-20230711201041513"></p>
<ul>
<li><strong>带权图</strong>：这种边带权值的图也叫<mark>网</mark>。</li>
</ul>
<h3 id="图的表示方式"><a class="markdownIt-Anchor" href="#图的表示方式">#</a> 图的表示方式</h3>
<p><strong>图的表示方式有两种</strong>：</p>
<ul>
<li>
<p><strong><mark>二维数组</mark>表示</strong> (邻接矩阵)；</p>
</li>
<li>
<p><strong><mark>链表</mark>表示</strong> (邻接表)；</p>
</li>
</ul>
<h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵">#</a> 邻接矩阵</h4>
<p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是 row 和 col 表示的是 1…n 个点。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711202214098.png" alt="image-20230711202214098"></p>
<h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表">#</a> 邻接表</h4>
<ol>
<li>邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在的，会造成空间的一定损失。</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组 + 链表组成</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711202425883.png" alt="image-20230711202425883"></p>
<p><strong>说明</strong>：</p>
<ol>
<li>标号为 0 的节点的相关联的节点为 1  2  3  4</li>
<li>标号为 1 的节点的相关联节点为 0  4</li>
<li>标号为  2  的节点的相关联节点为 0  4  5</li>
<li>…</li>
</ol>
<h4 id="图的快速入门案例"><a class="markdownIt-Anchor" href="#图的快速入门案例">#</a> 图的快速入门案例</h4>
<p>1 <strong>要求</strong>：代码实现如下图结构</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711211516098.png" alt="image-20230711211516098"></p>
<p>2 <strong>思路分析</strong></p>
<ol>
<li>每一个<mark>顶点</mark>需要用一个<mark>容器来装</mark>，这里使用简单的 <mark>String 类型来表示</mark> A,B … 等<mark>节点</mark></li>
<li>这些所有的<mark>顶点</mark>，我们用一个<mark> List 来存储</mark></li>
<li>它对应的<mark>矩阵使用</mark>一个<mark>二维数组</mark>来<mark>表示</mark>，<mark>节点之间的关系</mark></li>
</ol>
<p>3 <strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1120:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumEdges</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点i对应下标的值 (0 -&gt; &quot;A&quot;) (1 -&gt; &quot;B&quot;) (2 -&gt; &quot;C&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getVertexByIndex</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] temp:edges)</span><br><span class="line">            System.err.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标,即是第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String[] vertexValue = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span>(String value:vertexValue)</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0]</span><br><span class="line">[1, 0, 1, 1, 1]</span><br><span class="line">[1, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先遍历介绍"><a class="markdownIt-Anchor" href="#图的深度优先遍历介绍">#</a> 图的深度优先遍历介绍</h3>
<h4 id="图遍历介绍"><a class="markdownIt-Anchor" href="#图遍历介绍">#</a> 图遍历介绍</h4>
<p>所谓图的遍历，即是对节点的访问。一个图有那么多个节点，如何遍历这些节点，需要特定策略，一般有两种访问策略：</p>
<ol>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ol>
<h4 id="深度优先遍历基本思想"><a class="markdownIt-Anchor" href="#深度优先遍历基本思想">#</a> 深度优先遍历基本思想</h4>
<p><strong>图的深度优先搜索</strong> (Depth First Search)</p>
<ol>
<li>深度优先遍历，从初始访问节点出发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点，可以这样理解：每次都在访问完<mark>当前节点</mark>后首先访问<mark>当前节点的第一个邻接节点</mark>。</li>
<li>我们可以看到，这样的访问策略是优先往<mark>纵向挖掘深入</mark>，而不是对一个节点的所有邻接节点进行横向访问。</li>
<li>显然，深度优先搜索是一个<mark>递归的过程</mark>。</li>
</ol>
<h5 id="深度优先遍历算法步骤"><a class="markdownIt-Anchor" href="#深度优先遍历算法步骤">#</a> 深度优先遍历算法步骤</h5>
<ol>
<li>访问初始节点 v，并标记节点 v 为已访问。</li>
<li>查找节点 v 的第一个邻接节点 w。</li>
<li>若 w 存在，则继续执行第 4 步，如果 w 不存在，则回到第 1 步，将从 v 的下一个节点继续。</li>
<li>若 w 未被访问，对 w 进行深度优先遍历递归 (即把 w 当做另一个 v，然后进行步骤 123)。</li>
<li>查找节点 v 的 w 邻接节点的下一个邻接节点，转到步骤 3。</li>
</ol>
<p><strong>看一个具体案例分析</strong>：</p>
<p><strong>要求</strong>：对下图进行深度优先搜索，从 A 开始遍历</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711220409405.png" alt="image-20230711220409405"></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230712165116264.png" alt="image-20230712165116264"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1120:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//记录某个节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i         第一次就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//首先我们访问该节点，输出</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//将节点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行一个重载，遍历我们所有的节点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有的节点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; getNumOfVertex();i ++)</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i])</span><br><span class="line">                dfs(isVisited,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumEdges</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点i对应下标的值 (0 -&gt; &quot;A&quot;) (1 -&gt; &quot;B&quot;) (2 -&gt; &quot;C&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp : edges)</span><br><span class="line">            System.err.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标,即是第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String[] vertexValue = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexValue)</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------深度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0]</span><br><span class="line">[1, 0, 1, 1, 1]</span><br><span class="line">[1, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br><span class="line">-----------------深度遍历-----------------</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<h3 id="图的广度优先遍历"><a class="markdownIt-Anchor" href="#图的广度优先遍历">#</a> 图的广度优先遍历</h3>
<h5 id="广度优先遍基本思想"><a class="markdownIt-Anchor" href="#广度优先遍基本思想">#</a> 广度优先遍基本思想</h5>
<p>图的广度优先搜索 (Broad First Search)。</p>
<p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的节点的顺序，以便按这个顺序来访问这些节点的邻接节点。</p>
<h5 id="广度优先遍历算法步骤"><a class="markdownIt-Anchor" href="#广度优先遍历算法步骤">#</a> 广度优先遍历算法步骤</h5>
<ol>
<li>访问初始节点 v 并标记节点 v 为已访问。</li>
<li>节点 v 入队列</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得对头节点 u。</li>
<li>查找节点 u 的第一个邻接节点 w。</li>
<li>若节点 u 的邻接节点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤
<ol>
<li>若节点 w 尚未被访问，则访问节点 w 并标记为已访问。</li>
<li>节点 w 入队列</li>
<li>查找节点 u 的继 w 邻接节点后的下一个邻接节点 w，转到步骤 6。</li>
</ol>
</li>
</ol>
<h5 id="广度优先遍历举例说明"><a class="markdownIt-Anchor" href="#广度优先遍历举例说明">#</a> 广度优先遍历举例说明</h5>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711221219958.png" alt="image-20230711221219958"></p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230712171034456.png" alt="image-20230712171034456"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1120:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[],记录某个节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="comment">//+1 略过自己(不算自己)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个节点进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//表示队列头节点对应的下标</span></span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="comment">//邻接节点w</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="comment">//队列，记录节点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问节点，输出节点的信息</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入到队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列头节点下标</span></span><br><span class="line">            u = (<span class="type">int</span>) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接节点的下标w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.println(getValueByIndex(w));</span><br><span class="line">                    <span class="comment">//标记已访问</span></span><br><span class="line">                    isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//加入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱节点找w后面的下一个邻接节点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有节点，都进行广度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++)</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumEdges</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点i对应下标的值 (0 -&gt; &quot;A&quot;) (1 -&gt; &quot;B&quot;) (2 -&gt; &quot;C&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp : edges)</span><br><span class="line">            System.err.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标,即是第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String[] vertexValue = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexValue)</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------广度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0]</span><br><span class="line">[1, 0, 1, 1, 1]</span><br><span class="line">[1, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0]</span><br><span class="line">-----------------广度遍历-----------------</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1120:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[],记录某个节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="comment">//+1 略过自己(不算自己)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i         第一次就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//首先我们访问该节点，输出</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//将节点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行一个重载，遍历我们所有的节点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的节点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++)</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个节点进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//表示队列头节点对应的下标</span></span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="comment">//邻接节点w</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="comment">//队列，记录节点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问节点，输出节点的信息</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入到队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列头节点下标</span></span><br><span class="line">            u = (<span class="type">int</span>) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接节点的下标w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.println(getValueByIndex(w));</span><br><span class="line">                    <span class="comment">//标记已访问</span></span><br><span class="line">                    isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//加入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱节点找w后面的下一个邻接节点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有节点，都进行广度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++)</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumEdges</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点i对应下标的值 (0 -&gt; &quot;A&quot;) (1 -&gt; &quot;B&quot;) (2 -&gt; &quot;C&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp : edges)</span><br><span class="line">            System.err.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标,即是第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        String[] vertexValue = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexValue)</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------深度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------广度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">[1, 0, 1, 1, 1, 0, 0, 0]</span><br><span class="line">[1, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">-----------------深度遍历-----------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">-----------------广度遍历-----------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="图的深度优先strong-stylecolorred-vs-strong广度优先"><a class="markdownIt-Anchor" href="#图的深度优先strong-stylecolorred-vs-strong广度优先">#</a> 图的<mark>深度优先</mark><strong style="color:red"> VS </strong><mark>广度优先</mark></h3>
<p>由于前面讲解的顶点较少，恰好输出顺序一致，现在来对比下多一点的顶点，如下图：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230712174413248.png" alt="image-20230712174413248"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">graph.insertEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><mark>深度优先遍历</mark>顺序为  <code>1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7</code></li>
<li><mark>广度优先遍历</mark>顺序为： <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</code></li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 窦凯欣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * @2023/7/1120:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@comment</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;<span class="comment">//存储图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;<span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="comment">//定义给数组boolean[],记录某个节点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标 w</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="comment">//+1 略过自己(不算自己)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i         第一次就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//首先我们访问该节点，输出</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//将节点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点w</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs进行一个重载，遍历我们所有的节点，并进行dfs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的节点，进行dfs[回溯]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++)</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个节点进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] isVisited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//表示队列头节点对应的下标</span></span><br><span class="line">        <span class="type">int</span> u;</span><br><span class="line">        <span class="comment">//邻接节点w</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="comment">//队列，记录节点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问节点，输出节点的信息</span></span><br><span class="line">        System.out.println(getValueByIndex(i));</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将节点加入到队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列头节点下标</span></span><br><span class="line">            u = (<span class="type">int</span>) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接节点的下标w</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.println(getValueByIndex(w));</span><br><span class="line">                    <span class="comment">//标记已访问</span></span><br><span class="line">                    isVisited[w] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//加入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱节点找w后面的下一个邻接节点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有节点，都进行广度优先搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getNumOfVertex(); i++)</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图中常用的方法</span></span><br><span class="line">    <span class="comment">//返回节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumEdges</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回节点i对应下标的值 (0 -&gt; &quot;A&quot;) (1 -&gt; &quot;B&quot;) (2 -&gt; &quot;C&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示图对应的矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp : edges)</span><br><span class="line">            System.err.println(Arrays.toString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标,即是第几个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 表示关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        String[] vertexValue = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//循环的添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexValue)</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------深度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------广度遍历-----------------&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：</p>
<ul>
<li>深度优先遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 1, 1, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 0, 0, 1, 1, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 0, 1, 0, 0, 0, 1, 0]</span><br><span class="line">[0, 0, 1, 0, 0, 1, 0, 0]</span><br><span class="line">[0, 0, 0, 1, 1, 0, 0, 0]</span><br><span class="line">-----------------深度遍历-----------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<ul>
<li>广度优先遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 1, 1, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 0, 0, 1, 1, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 1, 0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 0, 1, 0, 0, 0, 1, 0]</span><br><span class="line">[0, 0, 1, 0, 0, 1, 0, 0]</span><br><span class="line">[0, 0, 0, 1, 1, 0, 0, 0]</span><br><span class="line">-----------------广度遍历-----------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="程序员常用的10中算法"><a class="markdownIt-Anchor" href="#程序员常用的10中算法">#</a> 程序员常用的 10 中算法</h2>
<h3 id="二分查找非递归"><a class="markdownIt-Anchor" href="#二分查找非递归">#</a> 二分查找 (非递归)</h3>
<h4 id="二分查找非递归介绍"><a class="markdownIt-Anchor" href="#二分查找非递归介绍">#</a> 二分查找 (非递归) 介绍</h4>
<p>前面我们讲过了二分查找算法，是使用递归的方式 (非递归也写了因为会所以提前写了)。下面我们讲解二分查找算法的非递归方式。</p>
<p>二分查找法只适用于从有序的数列中进行查找 (比如数组和字母等)，将数列排序后再进行查找。</p>
<p>二分查找法的运行时间为对数数据 O (log<sub>2</sub>N)，即查找到需要的目标位置最多只需要 log<sub>2</sub>N 步，假设从 [0,99] 的队列 (100 个数，即 n=100) 中寻到目标数 30，则需要查找步数为 log<sub>2</sub>100，即最多需要查找 7 次 (2^6 &lt; 100 &lt; 2 ^ 7)</p>
<h4 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h4>
<p>数组 {1,3, 8, 10, 11, 67, 100}，编程实现二分查找，要求使用非递归的方式完成。</p>
<p>思路分析：</p>
<p>判断中间值 mid 来进行折半查找操作</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307141539864.png" alt="image-20230714153923559"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchNoRecur</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> searchErFen(arr,<span class="number">3</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找的非递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 目标数组,数组有序且升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回目标值的下表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchErFen</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//起始指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//末尾指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= last)&#123;</span><br><span class="line">            <span class="comment">//每次执行折半处理 计算出 数列的中间位置进行查找目标值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + last) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//判断中间的值是否小于目标值</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; value)</span><br><span class="line">                <span class="comment">//如果中间值小于目标值则将指针向前移动</span></span><br><span class="line">                last = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//判断中间值是否大于目标值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; value)</span><br><span class="line">                <span class="comment">//如果中间值大于了目标值则将指针向后移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//两者都没有执行则说明找到了目标值直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治算法"><a class="markdownIt-Anchor" href="#分治算法">#</a> 分治算法</h3>
<h4 id="分治算法介绍"><a class="markdownIt-Anchor" href="#分治算法介绍">#</a> 分治算法介绍</h4>
<p>分治法是一种很重要的算法。字面上的解释是 &quot;分而治之&quot;，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题 … 直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法 (<font style="color:blue">快速排序</font>，<font style="color:blue">归并排序</font>)，傅里叶变换 (快速傅里叶变化)…</p>
<h4 id="分治算法的基本步骤"><a class="markdownIt-Anchor" href="#分治算法的基本步骤">#</a> 分治算法的基本步骤</h4>
<p><strong>分治法在每一层递归上都有三个步骤</strong>：</p>
<ol>
<li><mark>分解</mark>：将原问题分解为若干个规模较小，相互独立。与原问题形式相同的子问题。</li>
<li><mark>解决</mark>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。</li>
<li><mark>合并</mark>：将各个子问题的解合并为原问题的解。</li>
</ol>
<p><strong>分治 (Divide-and-Conquer§) 算法设计模式如下</strong>：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307141559273.png" alt="image-20230714155912742"></p>
<p>其中 |P| 表示问题 P 的规模；n0 为一阈值，表示当问题 p 的规模不超过 n0 时，问题已容易直接接触，不必再继续分解。ADHOC§ 是该分治法中的基本子算法，用于直接解小规模的问题 p，因此，当 p 的规模不超过 n0 时直接用算法 ADHOC§ 求解。算法 MERGE (y1,y2…,yk) 是该分治法中的合并子算法，用于将 p 的子问题 p1,p2,…pk 的相应的解 y1,y2,…yk 合并为 p 的解。</p>
<h4 id="分治算法最佳实践汉诺塔"><a class="markdownIt-Anchor" href="#分治算法最佳实践汉诺塔">#</a> 分治算法最佳实践 —— 汉诺塔</h4>
<p><strong>汉诺塔的传说</strong></p>
<p>汉诺塔：汉诺塔 (又称河内塔) 问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摆着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始大小顺序重新摆放在另一跟柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p>加入每秒钟一次，共需多长时间呢？移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。直的超过了 5845.54 亿年，地球上的一切生命，连同梵塔，届宇等，都早已经灰飞烟灭。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hanoitower</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉诺塔移动的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从 &quot;</span> + a + <span class="string">&quot; --&gt;&gt; &quot;</span> + c);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有n &gt;= 2情况，我们总是可以看做是两个盘</span></span><br><span class="line">            <span class="comment">//1.最下边的一个盘</span></span><br><span class="line">            <span class="comment">//2.上面的所有盘</span></span><br><span class="line">            <span class="comment">//一,先吧，最上面的所有盘 A-&gt;B,移动过程中会使用到c</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//二,吧最下面的盘 A -&gt; C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘从 &quot;</span> + a + <span class="string">&quot; --&gt;&gt; &quot;</span> + c);</span><br><span class="line">            <span class="comment">//三,吧B塔的所有盘 从 B -&gt; C,移动过程使用到A塔</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划算法"><a class="markdownIt-Anchor" href="#动态规划算法">#</a> 动态规划算法</h3>
<p>应用场景 —— 背包问题</p>
<p>背包问题：有一个背包，容量为 4 磅，现有如下物品。</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>吉他 (G)</td>
<td>1</td>
<td>1500</td>
</tr>
<tr>
<td>音响 (S)</td>
<td>4</td>
<td>3000</td>
</tr>
<tr>
<td>电脑 (L)</td>
<td>3</td>
<td>2000</td>
</tr>
</tbody>
</table>
<ol>
<li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>要求装入的物品不能重复</li>
</ol>
<h4 id="动态规划算法介绍"><a class="markdownIt-Anchor" href="#动态规划算法介绍">#</a> 动态规划算法介绍</h4>
<p>1 动态规划 (Dynamic Programming) 算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解决的处理算法</p>
<p>2 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成诺干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>3 与分治法不同的是，<mark>适合用于动态规划求解的问题，经分解得到子问题往往不是相互独立的</mark>。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</p>
<p>4 动态规划可以通过<mark>填表的方式</mark>来逐步推进，得到最优解。</p>
<h4 id="动态规划算法最佳实践背包问题"><a class="markdownIt-Anchor" href="#动态规划算法最佳实践背包问题">#</a> 动态规划算法最佳实践 —— 背包问题</h4>
<p><strong>思路分析和图解</strong></p>
<ul>
<li>
<p>背包问题主要是指一个给定容量的背包，若干具有一定价值和重量的物品，如何选择物品放入背包使用物品的价值最大。其中又分 01 背包<sup>每件物品都不可重复</sup> 和 完全背包 (完全背包指的是：每种物品都有无限件可用)</p>
</li>
<li>
<p>这里的问题属于 01 背包 ，即每一个物品最多放一个。而<mark>无限背包可以转化为 01 背包</mark>。</p>
</li>
<li>
<p>算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w [i] 和 v [i] 来确定是否需要将物品放入背包中。即对于给定的 n 个物品，设 v [i]，w [i] 分别为第 i 个物品的价值和重量，C 为背包的容量。再令 <code>v[i][j]</code>  表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：</p>
</li>
</ul>
<p><strong>图解示意图</strong>：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307141959508.png" alt="image-20230714195929888"></p>
<p>1  <code>v[i][0] = v[0][j] = 0;</code>  表示 填入表 第一行 和 第一列 是 0</p>
<p>2 当  <code>w[i - 1] &gt; j</code>  时 -&gt;： <code>v[i][j] = v[i - 1][j]</code>  当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略 i - 1 是因为程序中 i 是从 1 开始的数组下标从 0 开始。</p>
<p>3 当  <code>j &gt;= w[i]</code>  时： <code>v[i][j] = max &#123;v[i - 1][j],v[i - 1][j - w[i]]&#125;</code></p>
<p>当准备加入的新增的商品的容量大小等于当前背包 的容量，转入的方式如下：</p>
<p><code>v[i - 1][j]</code> ：就是上一个单元格的装入的最大值</p>
<p><code>val[i]</code> ：表示当前商品的价值</p>
<p><code>v[i - 1][j - w[i]]</code> ：装入 i - 1 商品，到剩余空间 j - w [i] 的最大值</p>
<p>当 <code>j &gt;= w[i]</code>  时： <code>v[i][j] = max &#123;v[i - 1][j],val[i] + v[i - 1][j - w[i]]&#125;</code> ;</p>
<p>解释 <code>j &gt;= w[i]</code>  公式的含义：如果新的商品装不进去那么就采用原先的 <code>v[i][j] = v[i - 1][j]</code>  装入策略。如果商品可以装进去那么就要看哪一个更大 <code>v[i][j] = max&#123;v[i - 1][j],val[i] + v[i - 1][j - w[i]]&#125;</code>  是 <code>v[i - 1][j]</code>  更大呢还是 <code>val[i] + v[i - 1][j - w[i]]</code>  把新加的商品加入以后再去加上剩余空间对应的最大值两个的和看哪个更大，取最大的</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">        <span class="type">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;<span class="comment">//物品的价格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> val.length;<span class="comment">//物品的个数</span></span><br><span class="line">        <span class="comment">//n+1因为第一行中都是0不算第一行,m+1因为第一列都是0不算第一列</span></span><br><span class="line">        <span class="comment">//v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] v = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的 情况，我们定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] path = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行和第一列，这里在本程序中，可以不去处理，因为默认是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v.length; i++)</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//将第一列设置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++)</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>;<span class="comment">//将第一行设置0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据前面得到的公式来动态规划处理i,从1 开始因为第一行不做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; v.length; i++)<span class="comment">//i +1 第一行不做处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//j +1 第一列不做处理</span></span><br><span class="line">                <span class="comment">//公式</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j)<span class="comment">//因为程序是i,是从1开始的，因此原来公式中的w[i] 修改成w[i - 1]</span></span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明：</span></span><br><span class="line">                    <span class="comment">//因为i从1开始的，因此公式需要调整成</span></span><br><span class="line">                    <span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">                    <span class="comment">//为了记录商品存放到背包的情况，不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//吧当前的情况记录到path数组中</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出查看情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; v[i].length; j++)</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">        <span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; path[i].length; j++)</span></span><br><span class="line"><span class="comment">//                if (path[i][j] == 1)</span></span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;第%d个商品放入到背包&quot;, i);</span></span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> path.length - <span class="number">1</span>;<span class="comment">//行的最大下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> path[<span class="number">0</span>].length - <span class="number">1</span>;<span class="comment">//列的最大小标</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)&#123;<span class="comment">//从path的最后开始找</span></span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第&gt;&gt; %d &lt;&lt;个商品放入到背包\n&quot;</span>, i);</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 </span><br><span class="line">0 1500 1500 1500 1500 </span><br><span class="line">0 1500 1500 1500 3000 </span><br><span class="line">0 1500 1500 2000 3500 </span><br><span class="line">================================</span><br><span class="line">第&gt;&gt; 3 &lt;&lt;个商品放入到背包</span><br><span class="line">第&gt;&gt; 1 &lt;&lt;个商品放入到背包</span><br></pre></td></tr></table></figure>
<p>先看代码，如果看了一会儿还是不太懂就看下图：对代码的图解</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307151050040.png" alt="image-20230715105010336"></p>
<h3 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法">#</a> KMP 算法</h3>
<h4 id="应用场景字符串匹配问题"><a class="markdownIt-Anchor" href="#应用场景字符串匹配问题">#</a> 应用场景 —— 字符串匹配问题</h4>
<p><strong>字符串匹配问题</strong>：</p>
<ol>
<li>有一个字符串 str = “硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅谷你好” , 和一个子串 str2 = “尚硅谷你尚硅谷你”</li>
<li><strong>现在要判断 str1 是否包含有 str2</strong> ，如果存在，就返回第一次出现的位置，如果没有则返回 -1</li>
</ol>
<h4 id="暴力匹配算法"><a class="markdownIt-Anchor" href="#暴力匹配算法">#</a> 暴力匹配算法</h4>
<p>如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有：</p>
<ol>
<li>如果当前字符匹配成功 (即 str1 [i] == str2 [j])，则 i++，j++，继续匹配下一个字符</li>
<li>如果匹配失败 (即 str1 [i] != str2 [j])，令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0</li>
<li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行！)</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">       						↓ i = 10</span><br><span class="line">str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;      尚硅谷你尚硅你&quot;</span></span><br><span class="line">								↑ j = 6</span><br><span class="line">发现 空格≠你，则 i 被回溯：i = i - (j-1) : </span><br><span class="line">i = 10 - (6-1) = 10 - 5 = 5</span><br><span class="line">					 ↓ 回溯到这里，i=5		</span><br><span class="line">str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;        尚硅谷你尚硅你&quot;</span></span><br><span class="line">				    ↑ j = 0</span><br><span class="line"></span><br><span class="line">为什么要回溯到 5 的位置？当 i=4 时，直到 i=10，才不匹配</span><br><span class="line">i 回溯时，相当于匹配失败，只前进 1 个字符串，然后再重新匹配。</span><br><span class="line"></span><br><span class="line">================= 如果不回溯 ========================</span><br><span class="line">如果失败的时候不回溯到最前面，直接从失败的地方开始匹配</span><br><span class="line">       						           ↓ i = 17</span><br><span class="line">str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;                 尚硅谷你尚硅你&quot;</span></span><br><span class="line">								           ↑ j = 6</span><br><span class="line">那么下一次再继续匹配，则从 18 开始了，就永远都匹配不上：</span><br><span class="line">       						             ↓ i = 18</span><br><span class="line">str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;                             尚硅谷你尚硅你&quot;</span></span><br><span class="line">								            			  ↑ j = 6</span><br><span class="line"></span><br><span class="line">================= 回溯匹配 - 成功 ========================</span><br><span class="line">       						        ↓ i = 15</span><br><span class="line">str1 = <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;                        尚硅谷你尚硅你&quot;</span></span><br><span class="line">														↑ j = 6</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>可以看到</strong>：暴力方法解决会有 <mark>大量的回溯</mark> ，每次只移动一位，若是不匹配，移动到下一位接着判断匹配，浪费了大量的时间。</p>
<p><strong>暴力匹配算法实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolenceMath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷你尚硅你&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> violenceMath(str1,str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配算法实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMath</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1Len</span> <span class="operator">=</span> s1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s2Len</span> <span class="operator">=</span> s2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//i索引指向s1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//j索引指向s2</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">//保证匹配时，不越界</span></span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;<span class="comment">//匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有匹配成功</span></span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == s2Len)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = 15</span><br></pre></td></tr></table></figure>
<h4 id="kmp算法介绍"><a class="markdownIt-Anchor" href="#kmp算法介绍">#</a> KMP 算法介绍</h4>
<p>1 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。</p>
<p>2 knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用与在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald knuth，Vaughan Pratt，James H. Morris 三人于 1977 年联发表，故取这三人的姓氏命名此算法。</p>
<p>3 MKP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</p>
<p>4 参考文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWnVvQW5kRnV0dXJlR2lybC9wLzkwMjgyODcuaHRtbA==">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</span></p>
<h4 id="kmp算法最佳应用字符串匹配问题"><a class="markdownIt-Anchor" href="#kmp算法最佳应用字符串匹配问题">#</a> KMP 算法最佳应用 —— 字符串匹配问题</h4>
<p><strong>字符串匹配问题</strong>：</p>
<p>1 有一个字符串 str1 = “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2 = “ABCDABD”</p>
<p>2 现在要判断 str1 是否包含有 str2，如果存在，就返回第一次出现的位置，如果没有则返回 - 1</p>
<p>3 要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法</p>
<p><strong>思路分析图解</strong></p>
<p>​											部分匹配值表的图解</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307151600018.png" alt="image-20230715160040538"></p>
<p>​												kmp 搜索算法图解</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307151602724.png" alt="image-20230715160200447"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMPAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ABCDABCD&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] next = kmpNext(str2);<span class="comment">//[0, 0, 0, 0, 1, 2, 0]</span></span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span> + index);<span class="comment">//index = 15</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kmp搜索算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 原字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表,子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是 -1说明没有匹配到，否则返回第一个匹配到的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i) != str2.charAt(j)，去调整j的大小</span></span><br><span class="line">            <span class="comment">//Kmp算法核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length())</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//如果字符串长度为1,部分匹配值就是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) == dest.charAt(j) 我们需要从next[j - 1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j))</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是 +1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j))</span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 0, 0, 1, 2, 3, 4]</span><br><span class="line">index = 11</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法">#</a> 贪心算法</h3>
<h4 id="应用场景集合覆盖问题"><a class="markdownIt-Anchor" href="#应用场景集合覆盖问题">#</a> 应用场景 —— 集合覆盖问题</h4>
<p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。</p>
<p><strong>如何选择最少的广播台</strong>，让所有的地区都可以接收到信号？</p>
<table>
<thead>
<tr>
<th>广播台</th>
<th>覆盖地区</th>
</tr>
</thead>
<tbody>
<tr>
<td>K1</td>
<td>“北京”, “上海”, “天津”</td>
</tr>
<tr>
<td>K2</td>
<td>“广州”, “北京”, “深圳”</td>
</tr>
<tr>
<td>K3</td>
<td>“成都”, “上海”, “杭州”</td>
</tr>
<tr>
<td>K4</td>
<td>“上海”, “天津”</td>
</tr>
<tr>
<td>K5</td>
<td>“杭州”, “大连”</td>
</tr>
</tbody>
</table>
<h4 id="贪心算法介绍"><a class="markdownIt-Anchor" href="#贪心算法介绍">#</a> 贪心算法介绍</h4>
<p>1 贪心算法 (贪婪算法) 是指在对问题进行求解时，在每一步选择中都采取最好或者最优 (即最有利) 的选择，从而希望能够导致结果是最好或者最优的算法。</p>
<p>2 贪心算法所得到的结果<mark>不一定是最优的结果</mark> (有时候会是最优解)，但是都是相对近似 (接近) 最优解的结果。</p>
<h4 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析">#</a> 思路分析：</h4>
<p>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现，列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共有 2<sup>n</sup>-1 个，假设每秒可以计算 10 个子集，如图：</p>
<table>
<thead>
<tr>
<th>广播台数量 n</th>
<th>子集总数 2ⁿ</th>
<th>需要的时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>32</td>
<td>3.2 秒</td>
</tr>
<tr>
<td>10</td>
<td>1024</td>
<td>102.4 秒</td>
</tr>
<tr>
<td>32</td>
<td>4294967296</td>
<td>13.6 年</td>
</tr>
<tr>
<td>100</td>
<td>1.26*100³º</td>
<td>4x10²³ 年</td>
</tr>
</tbody>
</table>
<p><strong>由此可见</strong>：在进行组合的场景下，使用组合效率是很低的。</p>
<h4 id="使用贪心算法效率高"><a class="markdownIt-Anchor" href="#使用贪心算法效率高">#</a> 使用贪心算法，效率高：</h4>
<p>目前并没有算法可以快速计算得到准备的值，使用贪心算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合：</p>
<ol>
<li>遍历所有的广播电台，找到一个覆盖了最多<font style="color:red">未覆盖的地区</font>的电台 (此电台可能包含一些已覆盖的地区，但没有关系)</li>
<li>将这个电台加入到一个集合中 (比如 ArrayList)，想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第 1 步直到覆盖了全部的地区。</li>
</ol>
<p>图解：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307152217484.png" alt="image-20230715221702246"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建广播电台，放入到HashMap</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line">        <span class="comment">//将所有电台加入到Map集合中</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(allAreas, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个ArrayList存放选择的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义临时集合保存在遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义maxKey保存在一次遍历过程中，能够覆盖的最多位覆盖的地区对应的电台的Key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果maxKey不为null则加入到selects中</span></span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;<span class="comment">//如果allAreas不为0,则表示还没有覆盖到所有的地区</span></span><br><span class="line">            maxKey = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出tempSet和allAreas集合的交集,交集会赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                <span class="comment">//如果当前集合包含的未覆盖地区的数量比maxKey指向的集合未覆盖的地区还要多</span></span><br><span class="line">                <span class="comment">//就需要重置maxKey</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp; (maxKey == <span class="literal">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size()))</span><br><span class="line">                    maxKey = key;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//maxKey != null，就应该将maxKey加入selects</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="literal">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey指向的广播电台覆盖的地区，从allAreas去掉</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的选择结果是: &quot;</span> + selects);<span class="comment">//[k1,k2,k3,k5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="贪心算法注意事项和细节"><a class="markdownIt-Anchor" href="#贪心算法注意事项和细节">#</a> 贪心算法注意事项和细节</h4>
<p>1 贪心算法所得到的结果不一定是最优的结果 (有时候会是最优解)，但是都是相对近似 (接近) 最优解的结果。</p>
<p>2 比如上题的算法选出的是 K1，K2，K3，K5，符合覆盖了全部的地区但是我们发现 K2，K3，K4，K5，也可以覆盖全部地区，如果 K2 的使用成本低于 K1 那么上题的 K1，K2，K3，K5，虽然满足条件，但并不是最优解。</p>
<h3 id="普利姆算法"><a class="markdownIt-Anchor" href="#普利姆算法">#</a> 普利姆算法</h3>
<p>应用场景和问题：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307160930413.png" alt="image-20230716093030683"></p>
<p>1 有胜利乡有 7 个村庄 (A,B,C,D,E,F,G)，现在需要修路把 7 个村庄连通。</p>
<p>2 各个村庄的距离用边线表示 (权)，比如 A - B 距离 5 公里。</p>
<p>3 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短？</p>
<p><strong>思路</strong>：</p>
<p>​	将 10 条边，链接即可，但是总的里程数不是最小。</p>
<p><strong>正确的思路</strong>：</p>
<p>​	就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少。</p>
<h4 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树">#</a> 最小生成树</h4>
<p>修路问题本质就是最小生成树问题，先介绍一下何为最小生成树 (Minimum Cost Spanning Tree)，简称 MST。</p>
<p>1 给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树</p>
<p>2 N 个顶点，一定有 N-1 条边</p>
<p>3 包含全部顶点</p>
<p>4 N-1 条边都在图中</p>
<p>5 举例说明 (如图)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307160934701.png" alt="image-20230716093418628"></p>
<p>6 求最小生成树的算法主要是<mark>普利姆算法</mark>和<mark>克鲁斯卡尔算法</mark></p>
<h4 id="普利姆算法介绍"><a class="markdownIt-Anchor" href="#普利姆算法介绍">#</a> 普利姆算法介绍</h4>
<p>1 普利姆 (Prim) 算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的<mark>极小连通子图</mark></p>
<p>2 普利姆的算法如下：</p>
<ol>
<li>设 G=(V,E) 是连通网。T=(U,D) 是最小生成树。V,U 是顶点集合。E,D 是边的集合。</li>
<li>若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited [u] = 1</li>
<li>若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边 (ui,vj) 加入集合 D 中，标记 visited [vj] = 1</li>
<li>重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边</li>
<li><mark>提示</mark>：单独看步骤很难理解，我们通过代码来讲解，比较好理解。</li>
</ol>
<h4 id="普利姆算法图解"><a class="markdownIt-Anchor" href="#普利姆算法图解">#</a> 普利姆算法图解</h4>
<p>上面的文字描述很难理解，下面是图解分析</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307161023485.png" alt="image-20230716102343503"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试图是否创建成功</span></span><br><span class="line">        <span class="type">char</span>[] data = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vertx</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示，10000这个大数，表示两个点不连通</span></span><br><span class="line">        <span class="type">int</span>[][] weight = &#123;&#123;<span class="number">10000</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10000</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        <span class="type">MGraph</span> <span class="variable">mGraph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MGraph</span>(vertx);</span><br><span class="line">        <span class="comment">//创建一个MiniTree对象</span></span><br><span class="line">        <span class="type">MiniTree</span> <span class="variable">minTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MiniTree</span>();</span><br><span class="line">        minTree.createGraph(mGraph, vertx, data, weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(mGraph);</span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(mGraph,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建最小生成树</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MiniTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertx  图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(MGraph graph, <span class="type">int</span> vertx, <span class="type">char</span>[] data, <span class="type">int</span>[][] weight)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertx; i++) &#123;<span class="comment">//顶点</span></span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertx; j++)</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">(MGraph graph)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] itemp : graph.weight)</span><br><span class="line">            System.out.println(Arrays.toString(itemp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写prim算法，得到最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     表示从图的第几个顶点开始生成 &#x27;A&#x27; -&gt; 0 , &#x27;B&#x27; -&gt; 1 ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(MGraph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="comment">//标记节点(顶点)是否被访问过</span></span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[graph.vertx];</span><br><span class="line">        <span class="comment">//visited[] 默认元素的值都是0，表示没有访问过,Java中默认为0所以不能特意进行次操作</span></span><br><span class="line">        <span class="comment">//for(int i = 0;i &lt; graph.vertx;i ++)</span></span><br><span class="line">        <span class="comment">//visited[i] = 0;</span></span><br><span class="line">        <span class="comment">//把当前节点标记为已访问</span></span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//h1,h2记录两个顶点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将miniweight初始成一个大数，后面在遍历过程中，会被替换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">miniWeight</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为有graph.vertx顶点，普利姆算法结束后，有graph.vertx - 1 边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; graph.vertx; k++) &#123;</span><br><span class="line">            <span class="comment">//遍历当前顶点可连通的所有的顶点</span></span><br><span class="line">            <span class="comment">//确定每一次生成的子图，和哪个节点的距离最近</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.vertx; i++)<span class="comment">//i节点表示被访问过的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.vertx; j++)<span class="comment">//j节点表示没有被访问过的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; miniWeight) &#123;</span><br><span class="line">                        <span class="comment">//替换miniweight(寻找已经访问过的节点和为访问过的节点间的权值最小的边)</span></span><br><span class="line">                        miniWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="comment">//找到一条边是最小</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边 &lt;&quot;</span> + graph.data[h1] + <span class="string">&quot;,&quot;</span> + graph.data[h2] + <span class="string">&quot;&gt; 权值: &quot;</span> + miniWeight);</span><br><span class="line">            <span class="comment">//将当前这个节点标记为已访问过</span></span><br><span class="line">            visited[h2] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将 miniWeight 重新设置为 最大值</span></span><br><span class="line">            miniWeight = <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertx;<span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="type">char</span>[] data;<span class="comment">//存放节点数据</span></span><br><span class="line">    <span class="type">int</span>[][] weight;<span class="comment">//存放边，就是邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MGraph</span><span class="params">(<span class="type">int</span> vertx)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertx = vertx;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">char</span>[vertx];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="title class_">int</span>[vertx][vertx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[10000, 5, 7, 10000, 10000, 10000, 2]</span><br><span class="line">[5, 10000, 10000, 9, 10000, 10000, 3]</span><br><span class="line">[7, 10000, 10000, 10000, 8, 10000, 10000]</span><br><span class="line">[10000, 9, 10000, 10000, 10000, 4, 10000]</span><br><span class="line">[10000, 10000, 8, 10000, 10000, 5, 4]</span><br><span class="line">[10000, 10000, 10000, 4, 5, 10000, 6]</span><br><span class="line">[2, 3, 10000, 10000, 4, 6, 10000]</span><br><span class="line">边 &lt;A,G&gt; 权值: 2</span><br><span class="line">边 &lt;G,B&gt; 权值: 3</span><br><span class="line">边 &lt;G,E&gt; 权值: 4</span><br><span class="line">边 &lt;E,F&gt; 权值: 5</span><br><span class="line">边 &lt;F,D&gt; 权值: 4</span><br><span class="line">边 &lt;A,C&gt; 权值: 7</span><br></pre></td></tr></table></figure>
<h3 id="克鲁斯卡尔算法"><a class="markdownIt-Anchor" href="#克鲁斯卡尔算法">#</a> 克鲁斯卡尔算法</h3>
<p><strong>公交站问题</strong>：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307161125011.png" alt="image-20230716112527142"></p>
<p>1 某城市新增 7 个站点 (A,B,C,D,E,F,G)，现在需要修路把 7 个站点连通</p>
<p>2 各个站点的距离用边线表示 (权)，比如 A-B 距离 12 公里</p>
<p>3 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短？</p>
<h4 id="克鲁斯卡尔介绍"><a class="markdownIt-Anchor" href="#克鲁斯卡尔介绍">#</a> 克鲁斯卡尔介绍</h4>
<ol>
<li>克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。</li>
<li><strong>基本思想</strong>：
<ul>
<li>按照权值从小到大的顺序选择 n-1 条边，并保证 n-1 条边不构成回路</li>
</ul>
</li>
<li><strong>具体做法</strong>：
<ul>
<li>首先构造一个只含 n 个顶点的森林，然后依权值从小到大连通网中选择边加入到森林中，并使森林中不产生回路，直至森森变成一颗树为止。</li>
</ul>
</li>
</ol>
<p>在含有 n 个顶点的连通图中选择 n-1 条边，构成一颗极小连通子图，并使该连通子图中 n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307161339514.png" alt="image-20230716133935680"></p>
<p>例如，对于如上图 G4 所示的联通网可以有多颗权值总和不相同的生成树。</p>
<h4 id="克鲁斯卡尔算法图解"><a class="markdownIt-Anchor" href="#克鲁斯卡尔算法图解">#</a> 克鲁斯卡尔算法图解</h4>
<p>以上图 G4 为例，来对克鲁斯卡尔进行演示 (假设，用数组 R 保存最小生成树结果)</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307161342469.png" alt="image-20230716134223900"></p>
<p>第 1 步：将边 &lt;E,F&gt; 加入 R 中</p>
<ul>
<li>边 &lt;E,F&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
<p>第 2 步：将边 &lt;C,D&gt; 加入 R 中</p>
<ul>
<li>上一步操作后，边 &lt;C,D&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
<p>第 3 步：将边 &lt;D,E&gt; 加入 R 中</p>
<ul>
<li>上一步操作后，边 &lt;D,E&gt; 的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
<p>第 4 步：将边 &lt;B,F&gt; 加入 R 中</p>
<ul>
<li>上一步操作后，边 &lt;C,E&gt; 的权值最小，但 &lt; C,E &gt; 会和已有的边构成回路；因此，跳过 &lt; C,E&gt;。同理，跳过边 &lt; C,F&gt;。将边 &lt; B,F &gt; 加入到最小生成树结果 R 中。</li>
</ul>
<p>第 5 步：将边 &lt;E,G&gt; 加入 R 中</p>
<ul>
<li>上一步操作后，边 &lt;E,G&gt; 的权值最小，因此将它加入到最小生成树结果 R 中</li>
</ul>
<p>第 6 步：将边 &lt;A,B&gt; 加入 R 中</p>
<ul>
<li>上一步操作后，边 &lt;F,G&gt; 的权值最小，但 &lt; F,G &gt; 会和已有的边构成回路；因此，跳过边 &lt; F,G&gt;。同理，跳过边 &lt; F,G&gt;。同理，跳过边 &lt; B,C&gt;。将边 &lt; A,B &gt; 加入到最小生成树结果 R 中。</li>
</ul>
<p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</p>
<h4 id="克鲁斯卡尔算法分析"><a class="markdownIt-Anchor" href="#克鲁斯卡尔算法分析">#</a> 克鲁斯卡尔算法分析</h4>
<p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：</p>
<p><strong>问题一</strong>：对图的所有边按照权值大小进行排序</p>
<p><strong>问题二</strong>：将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>
<p>问题一很好解决，采用排序算法进行排序即可。</p>
<p>问题二，处理方式是：记录顶点在 &quot;最小生成树&quot; 中的终点，顶点的终点是 &quot;在最小生成树中与它连通的最大顶点&quot;。然后每次需要将一条边添加到最小生成树时，判断该边的两个顶点的重点是否重合，重合的 话则会构成回路。</p>
<h4 id="如何判断是否构成回路举例说明如图"><a class="markdownIt-Anchor" href="#如何判断是否构成回路举例说明如图">#</a> 如何判断是否构成回路 —— 举例说明 (如图)</h4>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307161513317.png" alt="image-20230716151306831"></p>
<p>在将 &lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; 加入到最小生成树 R 中之后，这几条边的顶点就都有了终点：</p>
<ol>
<li>C 的终点是 F</li>
<li>D 的终点是 F</li>
<li>E 的终点是 F</li>
<li>F 的终点是 F</li>
</ol>
<p>关于终点的说明：</p>
<ol>
<li>这就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是 &quot;与它连通的最大顶点&quot;。</li>
<li>因此，接下来，虽然 &lt;C,E&gt; 是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将 &lt; C,E &gt; 加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，<strong>我们加入的<font style="color:blue">边</font>的<font style="color:blue">两个顶点</font>不能<font style="color:red">都指向同一个终点</font>，否则将构成回路</strong>。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> edgeNum;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertexs;<span class="comment">//顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//使用INF表示两个顶点不能连通</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">char</span>[] vertexs, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化定点数和边的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vlen</span> <span class="operator">=</span> vertexs.length;</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="built_in">this</span>.vertexs = <span class="keyword">new</span> <span class="title class_">char</span>[vlen];</span><br><span class="line">        <span class="comment">//拷贝的方式，使得构造函数中的vertexs和成员字段vertexs互不影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++)</span><br><span class="line">            <span class="built_in">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        <span class="comment">//初始化边</span></span><br><span class="line">        <span class="built_in">this</span>.matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexs.length; j++)</span><br><span class="line">                <span class="built_in">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">        <span class="comment">//统计边的条数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; vlen; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.matrix[i][j] != INF)</span><br><span class="line">                    edgeNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存&quot;已有最小生成树&quot;中的每个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="comment">//创建结果数组，保存最后的最小生成树</span></span><br><span class="line">        EData[] rets = <span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line">        <span class="comment">//获取图中 所有的边的集合，一共有12边</span></span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(<span class="string">&quot;图的边的集合= &quot;</span> + Arrays.toString(edges) + <span class="string">&quot; 共 &quot;</span> + edges.length);<span class="comment">//12</span></span><br><span class="line">        <span class="comment">//按照边的权值大小进行排序(从小到大)</span></span><br><span class="line">        sortEdges(edges);</span><br><span class="line">        <span class="comment">//遍历edges数组，将边添加到最小生成树中时，判断是准备加入的边是否形成了回路，如果没有，就加入rets，否则不能加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到第i条边的第一个顶点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(edges[i].start);</span><br><span class="line">            <span class="comment">//获取到第i条边的第二个顶点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(edges[i].end);</span><br><span class="line">            <span class="comment">//获取p1这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getEnd(ends, p1);</span><br><span class="line">            <span class="comment">//获取p2这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getEnd(ends, p2);</span><br><span class="line">            <span class="comment">//是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m != n)&#123;</span><br><span class="line">                <span class="comment">//设置m在 &quot;已有最小生成树&quot; 中的终点</span></span><br><span class="line">                ends[m] = n;</span><br><span class="line">                <span class="comment">//有一条边加入到rets数组中</span></span><br><span class="line">                rets[index ++] = edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------最小生成树为----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; index;i ++)</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵为\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexs.length; j++)</span><br><span class="line">                System.out.printf(<span class="string">&quot;%12d&quot;</span>, matrix[i][j]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对边进行排序处理，冒泡排序处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sortEdges</span><span class="params">(EData[] edges)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++)</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    <span class="type">EData</span> <span class="variable">temp</span> <span class="operator">=</span> edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值,比如&#x27;A&#x27;,&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch顶点对应的下标, 如果找不到返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (vertexs[i] == ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * comment: 获取图中边,放到EData[]数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     * 是通过matrix邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EData形式 [[&#x27;A&#x27;,&#x27;B&#x27;,12],[&#x27;B&#x27;,&#x27;F&#x27;,7],...]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> <span class="title class_">EData</span>[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexs.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; vertexs.length; j++)</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != INF)</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> <span class="title class_">EData</span>(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * comment: 获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中，逐步形成的(不是一次形成的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是 下标为i的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>)</span><br><span class="line">            i = ends[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//克鲁斯卡尔算法的邻接矩阵</span></span><br><span class="line">        <span class="type">int</span> matrix[][] = &#123;</span><br><span class="line">                <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span> &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/*B*/</span> &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span> &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*D*/</span> &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/*E*/</span> &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/*F*/</span> &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/*G*/</span> &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Kruskal</span> <span class="variable">krusKal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kruskal</span>(vertexs, matrix);</span><br><span class="line">        krusKal.print();</span><br><span class="line">        krusKal.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">//创建一个类EData,它的对象实力就表示一条边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EData</span> &#123;</span><br><span class="line">    <span class="type">char</span> start;<span class="comment">//边的一个点</span></span><br><span class="line">    <span class="type">char</span> end;<span class="comment">//边的另外一个点</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EData</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EData&#123;&quot;</span> +</span><br><span class="line">                 <span class="string">&quot;&lt;&quot;</span> + start +</span><br><span class="line">                <span class="string">&quot; , &quot;</span> + end + <span class="string">&quot;&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot; , weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵为</span><br><span class="line"></span><br><span class="line">           0          12  2147483647  2147483647  2147483647          16          14</span><br><span class="line">          12           0          10  2147483647  2147483647           7  2147483647</span><br><span class="line">  2147483647          10           0           3           5           6  2147483647</span><br><span class="line">  2147483647  2147483647           3           0           4  2147483647  2147483647</span><br><span class="line">  2147483647  2147483647           5           4           0           2           8</span><br><span class="line">          16           7           6  2147483647           2           0           9</span><br><span class="line">          14  2147483647  2147483647  2147483647           8           9           0</span><br><span class="line">图的边的集合= [EData&#123;&lt;A , B&gt; , weight=12&#125;, EData&#123;&lt;A , F&gt; , weight=16&#125;, EData&#123;&lt;A , G&gt; , weight=14&#125;, EData&#123;&lt;B , C&gt; , weight=10&#125;, EData&#123;&lt;B , F&gt; , weight=7&#125;, EData&#123;&lt;C , D&gt; , weight=3&#125;, EData&#123;&lt;C , E&gt; , weight=5&#125;, EData&#123;&lt;C , F&gt; , weight=6&#125;, EData&#123;&lt;D , E&gt; , weight=4&#125;, EData&#123;&lt;E , F&gt; , weight=2&#125;, EData&#123;&lt;E , G&gt; , weight=8&#125;, EData&#123;&lt;F , G&gt; , weight=9&#125;] 共 12</span><br><span class="line">----------------最小生成树为----------------</span><br><span class="line">EData&#123;&lt;E , F&gt; , weight=2&#125;</span><br><span class="line">EData&#123;&lt;C , D&gt; , weight=3&#125;</span><br><span class="line">EData&#123;&lt;D , E&gt; , weight=4&#125;</span><br><span class="line">EData&#123;&lt;B , F&gt; , weight=7&#125;</span><br><span class="line">EData&#123;&lt;E , G&gt; , weight=8&#125;</span><br><span class="line">EData&#123;&lt;A , B&gt; , weight=12&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迪杰斯特拉算法"><a class="markdownIt-Anchor" href="#迪杰斯特拉算法">#</a> 迪杰斯特拉算法</h3>
<p>应用场景问题：</p>
<p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202307162057769.png" alt="image-20230716205732320"></p>
<ol>
<li>战争时期，胜利乡有 7 个村庄 (A,B,C,D,E,F,G)，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A,B,C,D,E,F 六个村庄</li>
<li>各个村庄的距离用边线表示 (权)，比如 A-B 距离 5 公里</li>
<li>问：如何计算出 G 村庄到 其它各个村庄的最短距离？</li>
<li>如果从其它点出发到各个点的最短距离又是多少？</li>
</ol>
<h4 id="迪杰斯特拉dijkstra算法介绍"><a class="markdownIt-Anchor" href="#迪杰斯特拉dijkstra算法介绍">#</a> 迪杰斯特拉 (Dijkstra) 算法介绍</h4>
<p>迪杰斯特拉 (Dijkstra) 算法是<strong>典型的最短路径算法</strong>，用于计算一个节点到其它节点的最短路径。它的主要特点是以起始点为中心向外层层扩展 (<mark>广度优先搜索思想</mark>)，直到扩展到终点为止。</p>
<h4 id="迪杰斯特拉dijkstra算法过程"><a class="markdownIt-Anchor" href="#迪杰斯特拉dijkstra算法过程">#</a> 迪杰斯特拉 (Dijkstra) 算法过程</h4>
<p>设置出发顶点为 v，顶点集合 V {v1,v2,vi,…}，v 到 V 中各个顶点的距离构成距离集合 Dis，Dis {d1,d2,di,…}，Dis 集合记录着 v 到图中各个顶点的距离 (到自身可以看作 0，v 到 vi 距离对应为 di)</p>
<p>1 从 Dis 中选择值最小的 di 并移除 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即位最短路径</p>
<p>2 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个 (同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)</p>
<p>3 重复执行两步骤，直到最短路径顶点为目标顶点即可结束。</p>
<p>​</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-12-30 16:20:22" itemprop="dateModified" datetime="2023-12-30T16:20:22+08:00">2023-12-30</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="Dkx 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="Dkx 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="Dkx 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Dkx <i class="ic i-at"><em>@</em></i>Dkx の Java 小窝
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://pigpigletsgo.github.io/2023/12/30/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构与算法">https://pigpigletsgo.github.io/2023/12/30/computer-science/java/data-structures-and-algorithms/数据结构和算法/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
    </div>
    <div class="item right">
      

  <a href="/2023/12/30/computer-science/java/web/%E7%BA%AFJava%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9FHttp%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;5651daf17bf5de77514e658264d7cccc.jpg" title="纯java仿写http服务器">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> web</span>
  <h3>纯java仿写http服务器</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#toc"><span class="toc-number">1.</span> <span class="toc-text"> [toc]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text"> 数据结构和算法的重要性🎄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text"> 数据结构和算法的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text"> 线性结构和非线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text"> 线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text"> 非线性结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text"> 数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text"> 稀疏数组和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text"> 稀疏 sparsearray 数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text"> 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text"> 数组模拟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text"> 数组模拟环形队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text"> 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%96%B0%E6%B5%AA-%E7%99%BE%E5%BA%A6-%E8%85%BE%E8%AE%AF"><span class="toc-number">3.1.</span> <span class="toc-text"> 单链表面试题 (新浪、百度、腾讯)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text"> 双向链表应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text"> 单向环形链表应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text"> 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text"> 栈实现综合计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80-%E4%B8%AD%E7%BC%80-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text"> 前缀、中缀、后缀表达式 (逆波兰表达式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 前缀表达式 (波兰表达式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 中缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 后缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text"> 中缀转后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text"> 逆波兰计算器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">5.</span> <span class="toc-text"> 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text"> 递归 - 迷宫问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text"> 递归 - 八皇后问题 (回溯算法)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text"> 排序算法的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text"> 算法的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">6.2.</span> <span class="toc-text"> 算法的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text"> 选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">6.6.</span> <span class="toc-text"> 希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.7.</span> <span class="toc-text"> 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.</span> <span class="toc-text"> 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">6.9.</span> <span class="toc-text"> 基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="toc-number">6.10.</span> <span class="toc-text"> 常用排序算法总结和对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text"> 查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text"> 线性查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text"> 二分查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text"> 插值查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E6%B3%95%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text"> 斐波那契 (黄金分割法) 查找算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">9.</span> <span class="toc-text"> 树结构基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.1.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-number">9.1.1.</span> <span class="toc-text"> 树的常用术语：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F"><span class="toc-number">9.1.2.</span> <span class="toc-text"> 二叉树遍历应用实例 (前序，中序，后序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9"><span class="toc-number">9.1.3.</span> <span class="toc-text"> 二叉树 - 查找指定节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">9.1.4.</span> <span class="toc-text"> 二叉树 - 删除节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.2.</span> <span class="toc-text"> 顺序存储二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.3.</span> <span class="toc-text"> 线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.4.</span> <span class="toc-text"> 遍历线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.5.</span> <span class="toc-text"> 前序遍历线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.6.</span> <span class="toc-text"> 中序遍历线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.7.</span> <span class="toc-text"> 后序遍历线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">9.8.</span> <span class="toc-text"> 完整代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text"> 树结构实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.</span> <span class="toc-text"> 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">10.1.1.</span> <span class="toc-text"> 大顶堆举例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">10.1.2.</span> <span class="toc-text"> 小顶堆举例说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">10.2.</span> <span class="toc-text"> 赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 赫夫曼编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 最佳实践 - 数据压缩 (创建赫夫曼树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E7%94%9F%E6%88%90%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">10.2.3.</span> <span class="toc-text"> 最佳实践 - 数据压缩 (生成赫夫曼编码和赫夫曼编码后的数据)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%8E%8B%E4%BD%BF%E7%94%A8%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">10.2.4.</span> <span class="toc-text"> 最佳实践 - 数据解压 (使用赫夫曼编码解码)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"><span class="toc-number">10.2.5.</span> <span class="toc-text"> 最佳实践 - 文件压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D"><span class="toc-number">10.2.6.</span> <span class="toc-text"> 最佳实践 —— 文件解压 (文件恢复)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.2.7.</span> <span class="toc-text"> 赫夫曼编码压缩文件注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text"> 二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">10.3.1.</span> <span class="toc-text"> 二叉排序树创建和遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">10.3.2.</span> <span class="toc-text"> 二叉排序树的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">10.3.3.</span> <span class="toc-text"> 删除叶子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">10.3.4.</span> <span class="toc-text"> 删除节点有一个子节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9"><span class="toc-number">10.3.5.</span> <span class="toc-text"> 删除节点有两个子节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E6%A0%91"><span class="toc-number">10.4.</span> <span class="toc-text"> 平衡二叉树 (AVL 树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%97%8B%E8%BD%AC%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">10.4.1.</span> <span class="toc-text"> 单旋转 (左旋转)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">10.4.1.1.</span> <span class="toc-text"> 树高度计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">10.4.1.2.</span> <span class="toc-text"> 旋转</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">10.4.2.</span> <span class="toc-text"> 右旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%97%8B%E8%BD%AC%E7%9A%84strong-stylecolorred%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9strong"><span class="toc-number">10.5.</span> <span class="toc-text"> 单旋转的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">10.6.</span> <span class="toc-text"> 解决办法 —— 双旋转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text"> 多路查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8Eb%E6%A0%91"><span class="toc-number">11.1.</span> <span class="toc-text"> 二叉树与 B 树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-number">11.1.1.</span> <span class="toc-text"> 多叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.2.</span> <span class="toc-text"> B 树的基本介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">11.2.</span> <span class="toc-text"> 树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.2.1.</span> <span class="toc-text"> 2 - 3 树基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E6%A0%91%E6%9E%84%E5%BB%BA%E5%9B%BE%E8%A7%A3"><span class="toc-number">11.2.1.1.</span> <span class="toc-text"> 2-3 树构建图解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="toc-number">11.2.1.2.</span> <span class="toc-text"> 2-3 树添加规则总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E6%A0%91b-%E6%A0%91b%E6%A0%91"><span class="toc-number">11.3.</span> <span class="toc-text"> B 树，B+ 树，B *  树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.3.1.</span> <span class="toc-text"> B 树的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">11.3.2.</span> <span class="toc-text"> B + 树的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">11.3.3.</span> <span class="toc-text"> B 树的介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">12.</span> <span class="toc-text"> 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">12.1.</span> <span class="toc-text"> 图的举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">12.2.</span> <span class="toc-text"> 图常用的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">12.3.</span> <span class="toc-text"> 图的表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">12.3.1.</span> <span class="toc-text"> 邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">12.3.2.</span> <span class="toc-text"> 邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">12.3.3.</span> <span class="toc-text"> 图的快速入门案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.4.</span> <span class="toc-text"> 图的深度优先遍历介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E9%81%8D%E5%8E%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.4.1.</span> <span class="toc-text"> 图遍历介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">12.4.2.</span> <span class="toc-text"> 深度优先遍历基本思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.4.2.1.</span> <span class="toc-text"> 深度优先遍历算法步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">12.5.</span> <span class="toc-text"> 图的广度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">12.5.0.1.</span> <span class="toc-text"> 广度优先遍基本思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.5.0.2.</span> <span class="toc-text"> 广度优先遍历算法步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">12.5.0.3.</span> <span class="toc-text"> 广度优先遍历举例说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88strong-stylecolorred-vs-strong%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">12.6.</span> <span class="toc-text"> 图的深度优先 VS 广度优先</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A8%E7%9A%8410%E4%B8%AD%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text"> 程序员常用的 10 中算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-number">13.1.</span> <span class="toc-text"> 二分查找 (非递归)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%9D%9E%E9%80%92%E5%BD%92%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.1.1.</span> <span class="toc-text"> 二分查找 (非递归) 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.1.2.</span> <span class="toc-text"> 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text"> 分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.2.1.</span> <span class="toc-text"> 分治算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.2.2.</span> <span class="toc-text"> 分治算法的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="toc-number">13.2.3.</span> <span class="toc-text"> 分治算法最佳实践 —— 汉诺塔</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text"> 动态规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.3.1.</span> <span class="toc-text"> 动态规划算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">13.3.2.</span> <span class="toc-text"> 动态规划算法最佳实践 —— 背包问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text"> KMP 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">13.4.1.</span> <span class="toc-text"> 应用场景 —— 字符串匹配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">13.4.2.</span> <span class="toc-text"> 暴力匹配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.4.3.</span> <span class="toc-text"> KMP 算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95%E6%9C%80%E4%BD%B3%E5%BA%94%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">13.4.4.</span> <span class="toc-text"> KMP 算法最佳应用 —— 字符串匹配问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">13.5.</span> <span class="toc-text"> 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">13.5.1.</span> <span class="toc-text"> 应用场景 —— 集合覆盖问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.5.2.</span> <span class="toc-text"> 贪心算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">13.5.3.</span> <span class="toc-text"> 思路分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">13.5.4.</span> <span class="toc-text"> 使用贪心算法，效率高：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">13.5.5.</span> <span class="toc-text"> 贪心算法注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">13.6.</span> <span class="toc-text"> 普利姆算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">13.6.1.</span> <span class="toc-text"> 最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.6.2.</span> <span class="toc-text"> 普利姆算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3"><span class="toc-number">13.6.3.</span> <span class="toc-text"> 普利姆算法图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">13.7.</span> <span class="toc-text"> 克鲁斯卡尔算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.7.1.</span> <span class="toc-text"> 克鲁斯卡尔介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3"><span class="toc-number">13.7.2.</span> <span class="toc-text"> 克鲁斯卡尔算法图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">13.7.3.</span> <span class="toc-text"> 克鲁斯卡尔算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9E%84%E6%88%90%E5%9B%9E%E8%B7%AF%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%A6%82%E5%9B%BE"><span class="toc-number">13.7.4.</span> <span class="toc-text"> 如何判断是否构成回路 —— 举例说明 (如图)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">13.8.</span> <span class="toc-text"> 迪杰斯特拉算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89dijkstra%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.8.1.</span> <span class="toc-text"> 迪杰斯特拉 (Dijkstra) 算法介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89dijkstra%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">13.8.2.</span> <span class="toc-text"> 迪杰斯特拉 (Dijkstra) 算法过程</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/2023/12/30/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="bookmark" title="数据结构与算法">数据结构与算法</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Dkx"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Dkx</p>
  <div class="description" itemprop="description">欢迎来我的博客空间</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">3</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">5</span>
        <span class="name">分类</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BpZ1BpZ0xldHNHbw==" title="https:&#x2F;&#x2F;github.com&#x2F;PigPigLetsGo"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9Ea3gxMjE5" title="https:&#x2F;&#x2F;twitter.com&#x2F;Dkx1219"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS96dWktaG91LXllLWJlaS1sdWUtc2hh" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zui-hou-ye-bei-lue-sha"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU3NjUxMDQ1OQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;576510459"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93d3cud2VpYm8uY29tL3UvNTk5OTU0OTg0MQ==" title="https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;5999549841"><i class="ic i-weibo"></i></span>
      <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3Byb2ZpbGUucGhwP2lkPTEwMDA5NDA4Nzc0ODIwMQ==" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100094087748201"><i class="ic i-facebook"></i></span>
      <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vQERreC12djdsbQ==" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;@Dkx-vv7lm"><i class="ic i-youtube"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9kb3Vka3g/aWdzaD1PR1E1WkRjMk9EazJaQSUzRCUzRCZ1dG1fc291cmNlPXFy" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;doudkx?igsh&#x3D;OGQ5ZDc2ODk2ZA%3D%3D&amp;utm_source&#x3D;qr"><i class="ic i-instagram"></i></span>
      <span class="exturl item telegram" data-url="aHR0cHM6Ly90Lm1lL2RvdTAxMDg=" title="https:&#x2F;&#x2F;t.me&#x2F;dou0108"><i class="ic i-twitter"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web/" title="分类于 web">web</a>
</div>

    <span><a href="/2023/12/30/HTML5+CSS3/" title="HTML5+CSS3">HTML5+CSS3</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/java/web/" title="分类于 web">web</a>
</div>

    <span><a href="/2023/12/30/computer-science/java/web/%E7%BA%AFJava%E7%BC%96%E5%86%99%E4%BB%BF%E7%9C%9FHttp%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="纯java仿写http服务器">纯java仿写http服务器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/data-structures-and-algorithms/" title="分类于 数据结构与算法">数据结构与算法</a>
<i class="ic i-angle-right"></i>
<a href="/categories/data-structures-and-algorithms/java/" title="分类于 Java">Java</a>
</div>

    <span><a href="/2023/12/30/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a></span>
  </li>

  </ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Dkx @ Dou的个人博客</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">387k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">5:52</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/12/30/computer-science/java/data-structures-and-algorithms/数据结构和算法/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
