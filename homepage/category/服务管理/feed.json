{
    "version": "https://jsonfeed.org/version/1",
    "title": "homepage • All posts by \"服务管理\" category",
    "description": "欢迎来我的博客空间",
    "home_page_url": "https://pigpigletsgo.github.io/homepage",
    "items": [
        {
            "id": "https://pigpigletsgo.github.io/homepage/2024/02/08/computer-science/linux/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%861/",
            "url": "https://pigpigletsgo.github.io/homepage/2024/02/08/computer-science/linux/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/Linux%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%861/",
            "title": "linux服务管理",
            "date_published": "2024-02-08T04:46:22.701Z",
            "content_html": "<blockquote>\n<p>介绍</p>\n</blockquote>\n<p>服务 (service) 本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其它程序的请求，比如 (mysqld,sshd, 防火墙等等), 因此我们又成为守护进程，是 Linux 中非常重要的知识点</p>\n<blockquote>\n<p>service 管理指令</p>\n</blockquote>\n<ol>\n<li>\n<p>service 服务名 [start|stop|restart|reload|status]</p>\n</li>\n<li>\n<p>在 CentOS7.0 后 &lt;font color='red'&gt; 很多服务不再使用 service&lt;/font&gt;, 而是 &lt; font color='red'&gt;systemctl&lt;/font&gt;</p>\n</li>\n<li>\n<p>service 指令管理的服务在 <code>/etc/init.d</code>  查看</p>\n</li>\n</ol>\n<p><code>ls -l /etc/init.d/</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image_2023-01-06-15-37-26.png\" alt=\"image_2023-01-06-15-37-26\" /></p>\n<blockquote>\n<p>查看全部系统服务</p>\n</blockquote>\n<p><code>setup</code></p>\n<p>如果提示不存在则进行安装 <code>sudo yum -y install setuptool</code></p>\n<p>安装完成后即可执行命令:setup</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20240208124524934.png\" alt=\"image-20240208124524934\" /></p>\n<blockquote>\n<p>服务的运行级别 (runlevel)</p>\n</blockquote>\n<p>Linux 系统有 7 种运行级别 (runlevel):&lt;font color='red'&gt; 常用的是级别 3 和 5&lt;/font&gt;</p>\n<ul>\n<li>\n<p>运行级别 0: 系统停机状态，系统默认运行级别不能设为 0, 否则不能正常启动</p>\n</li>\n<li>\n<p>运行级别 1: 单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p>\n</li>\n<li>\n<p>运行级别 2: 多用户状态 (没有 NFS), 不持支网络</p>\n</li>\n<li>\n<p>运行级别 3: 完全的多用户状态 (有 NFS), 登录后进入控制台命令行模式</p>\n</li>\n<li>\n<p>运行级别 4: 系统未使用，保留</p>\n</li>\n<li>\n<p>运行级别 5:X11 控制台，登录后进入图形 GUI 模式</p>\n</li>\n<li>\n<p>运行级别 6: 系统正常关闭并重启，默认运行级别不能设为 6, 否则不能正常启动</p>\n</li>\n</ul>\n<p>开机的流程说明:</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20240208124539115.png\" alt=\"image-20240208124539115\" /></p>\n<p>CentOS7 后台运行级别说明</p>\n<p>在 <code>/etc/initab</code></p>\n<p>进行了简化，如下</p>\n<p>multi-user.target:analogous to runlevel 3</p>\n<p>graphical.target:analogous to runlevel 5</p>\n<blockquote>\n<p>chkconfig</p>\n</blockquote>\n<ol>\n<li>\n<p>通过 chkconfig 命令可以给服务的各个运行级别设置自 启动 / 关闭</p>\n</li>\n<li>\n<p>chkconfig 指令管理的服务在 <code>/etc/initab.d</code>  查看</p>\n</li>\n<li>\n<p>注意：CentOS7.0 后，很多服务使用 &lt;font color='red'&gt;systemctl&lt;/font &gt; 管理</p>\n</li>\n</ol>\n<p>chkconfig 基本语法:</p>\n<p>查看服务:chkconfig  --list [|grep xxx]</p>\n<p>chkconfig   服务名  --list</p>\n<p>chkconfig   --level 5   服务名  on/off</p>\n<blockquote>\n<p>使用细节</p>\n</blockquote>\n<p>chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image_2023-01-06-17-29-29.png\" alt=\"image_2023-01-06-17-29-29\" /></p>\n<p>比如将 network 服务在指定的运行级别下让其关闭的则执行下面命令:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">chkconfig</span> <span class=\"token parameter variable\">--level</span> <span class=\"token number\">5</span> network off</pre></td></tr></table></figure><blockquote>\n<p>Systemctl 管理指令</p>\n</blockquote>\n<ol>\n<li>\n<p>基本语法:systemctl [start|stop|restart|status] 服务名</p>\n</li>\n<li>\n<p>systemctl 指令管理的服务在 <code>/usr/lib/systemd/system</code>  查看</p>\n</li>\n</ol>\n<blockquote>\n<p>systemctl 设置服务的自启动状态</p>\n</blockquote>\n<ol>\n<li>\n<p>systemctl list-unit-files [|grep 服务名] (查看服务开机启动状态，grep 可以进行过滤)</p>\n</li>\n<li>\n<p>systemctl enable 服务名 (设置服务开机启动)</p>\n</li>\n<li>\n<p>systemctl disable 服务名 (关闭服务开机启动)</p>\n</li>\n<li>\n<p>systemctl is-enabled 服务名 (查询某个服务是否是自启动的)</p>\n</li>\n<li>\n<p>systemctl status 服务名 (查看服务的状态)</p>\n</li>\n<li>\n<p>systemctl daemon reload (重新加载系统服务)</p>\n</li>\n</ol>\n<ul>\n<li>细节讨论</li>\n</ul>\n<ol>\n<li>关闭或者启用防火墙后，立即生效 [telnet 测试，某个端口即可]</li>\n</ol>\n<p>telnet 命令为 Windows 中的命令详细查看 Windows 中笔记<a href=\"......%5CTyporanote%5CWindows%5C%E5%BC%80%E5%90%AFtelnet%E5%8A%9F%E8%83%BD.md\"> Windows:Telnet 开启</a></p>\n<p>如果开启了防火墙而且没有将端口开放则外部主机访问不到</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20240208124554601.png\" alt=\"image-20240208124554601\" /></p>\n<ol start=\"2\">\n<li>\n<p>这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置</p>\n</li>\n<li>\n<p>如果希望设置某个服务自启动或关闭永久生效，要使用 systemctl [enable|disable] 服务名</p>\n</li>\n</ol>\n<blockquote>\n<p>打开或者关闭指定端口</p>\n</blockquote>\n<p>在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯，这时，需要打开指定的端口，比如 80,22,8080 等</p>\n<blockquote>\n<p>firewall 指令</p>\n</blockquote>\n<p>打开端口:firewall-cmd --permanent --add-port = 端口号 / 协议</p>\n<p>关闭端口:firewall-cmd --permanent --remove-port = 端口号 / 协议</p>\n<p>重新载入，才能生效:firewall-cmd --reload</p>\n<p>查询端口是否开放:firewall-cmd --query-port = 端口 / 协议</p>\n<p>查看所有开放端口:firewall-cmd --list-ports</p>\n<p>查看端口号:netstat -ntlp|grep [端口号]</p>\n<p>查看防火墙配置规则:iptables -nL</p>\n<p>对其它主机开放指定端口:firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot;source address port protocol=&quot;tcp&quot;port=&quot;8080&quot;accept&quot;</p>\n<p><strong>开放指定端口</strong>: firewall-cmd --permanent --zone=public --add-port=8080/tcp</p>\n<ul>\n<li>⚠️<strong>注意</strong>：执行操作后执行重载:firewall-cmd --reload</li>\n</ul>\n",
            "tags": [
                "linux",
                "计算机学科"
            ]
        }
    ]
}