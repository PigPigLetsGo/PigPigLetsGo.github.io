{
    "version": "https://jsonfeed.org/version/1",
    "title": "homepage • All posts by \"git\" category",
    "description": "欢迎来我的博客空间",
    "home_page_url": "https://pigpigletsgo.github.io/homepage",
    "items": [
        {
            "id": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/git/Git/",
            "url": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/git/Git/",
            "title": "Git版本控制系统",
            "date_published": "2024-04-02T06:23:30.183Z",
            "content_html": "<h2 id=\"git版本控制系统\"><a class=\"markdownIt-Anchor\" href=\"#git版本控制系统\">#</a> Git 版本控制系统</h2>\n<h5 id=\"git初始\"><a class=\"markdownIt-Anchor\" href=\"#git初始\">#</a> git 初始</h5>\n<blockquote>\n<p><span alt='solid'>概念</span>：</p>\n<p>一个免费开源，分布式的<font title='red'>代码版本</font>控制系统， 帮助开发团队维护代码</p>\n<p><span alt='solid'>作用</span>：</p>\n<p><font title='red'>记录</font>代码内容，<font title='red'>切换</font>代码版本，多人开发时高效<font title='red'>合并</font>代码内容</p>\n</blockquote>\n<p><span alt='solid'>如何学</span>：</p>\n<p><strong>个人本机使用</strong>：git 基础命令和概念</p>\n<p><strong>多人共享使用</strong>：团队开发同一个项目的代码版本管理</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308162135287.png\" alt=\"image-20230816213516967\"></p>\n<h3 id=\"git配置用户信息\"><a class=\"markdownIt-Anchor\" href=\"#git配置用户信息\">#</a> Git 配置用户信息</h3>\n<p><strong>配置</strong>：用户名和邮箱，应用在每次提交代码版本时<mark>表明自己身份</mark>.</p>\n<p><strong>命令</strong>：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> user.name <span class=\"token string\">'用户名'</span></pre></td></tr></table></figure><figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> user.email <span class=\"token string\">'邮箱'</span></pre></td></tr></table></figure><blockquote>\n<p>总结：</p>\n<ol>\n<li>为何学习 Git ?\n<ul>\n<li><font title='red'>管理代码版本</font>，记录，切换，合并代码</li>\n</ul>\n</li>\n<li>Git 学习\n<ul>\n<li>现在本机自己使用</li>\n<li>再学习多人共享使用</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"掌握git仓库\"><a class=\"markdownIt-Anchor\" href=\"#掌握git仓库\">#</a> 掌握 Git 仓库</h3>\n<p>Git 仓库 (repository) ：记录文件<font title='red'>状态</font>内容的地方，存储着修改的<font title='red'>历史记录</font>。</p>\n<p><strong>创建</strong>：</p>\n<ol>\n<li>\n<p>把本地文件夹<font title='red'>转换</font>成 Git 仓库：命令：<font title='red'>git init</font>.</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171148966.png\" alt=\"image-20230817114756556\"></p>\n</li>\n<li>\n<p>从其它服务器上<font title='red'>克隆 </font>Git 仓库</p>\n</li>\n</ol>\n<p>需求：创建一个空白的 Git 仓库</p>\n<p>打开 GitBash 到项目目录下，执行命令：git init</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171230894.png\" alt=\"image-20230817123047004\"></p>\n<p>查看项目目录下的变化</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171231139.png\" alt=\"image-20230817123104694\"></p>\n<blockquote>\n<p><span alt='solid'>总结</span>：</p>\n<ol>\n<li>什么是 Git 仓库？\n<ul>\n<li>记录文件状态内容和<font title='red'>历史记录</font>的地方 (.git 文件夹)</li>\n</ul>\n</li>\n<li>如何创建 Git 仓库？\n<ul>\n<li>把本地文件夹转换成 Git 仓库：命令 <font title='red'>git init</font></li>\n<li>从其它服务器上克隆 Git 仓库</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"git的三个区域\"><a class=\"markdownIt-Anchor\" href=\"#git的三个区域\">#</a> Git 的三个区域</h3>\n<p><strong>Git 使用时</strong>：</p>\n<p><span alt='solid'>工作区</span>：实际<font title='red'>开发</font>时操作的文件夹</p>\n<p><span alt='solid'>暂存区</span>：保存之前的<font title='red'>准备区域</font> (暂存改动过的文件)</p>\n<p><span alt='solid'>版本库</span>：提交并<font title='red'>保存</font>暂存区中的内容，产生一个版本快照</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git add 文件名</td>\n<td>暂存指定文件</td>\n</tr>\n<tr>\n<td>git add .</td>\n<td>暂存所有改动的文件</td>\n</tr>\n<tr>\n<td>git commit -m ‘注释说明’</td>\n<td>提交并保存，产生版本快照</td>\n</tr>\n<tr>\n<td>git ls-files</td>\n<td>查看当前暂存区记录了哪些文件</td>\n</tr>\n<tr>\n<td><code>git log --oneline</code></td>\n<td>查看版本库历史日志</td>\n</tr>\n<tr>\n<td><code>git reflog --online</code></td>\n<td>查看完整的版本库历史日志</td>\n</tr>\n<tr>\n<td><code>git rm --cached 路径/文件名</code></td>\n<td>从暂存区中移除指定文件</td>\n</tr>\n</tbody>\n</table>\n<blockquote alt='danger'>\n\t<div>\n      <p>\n         <span><font title=red>注意</font>：图中的 git_study 也就是自己的当前项目路面</span>\n      </p>\n   </div>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171340651.png\" alt=\"image-20230817134010660\"></p>\n<p><strong>需求</strong>：把登录页面新增后，暂存并提交</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171353405.png\" alt=\"image-20230817135326555\"></p>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>Git 使用时有哪些区域？\n<ul>\n<li>工作区，暂存区，版本库</li>\n</ul>\n</li>\n<li>工作区的内容，最终要如何保存在版本库中？\n<ul>\n<li><font title='red'>git add</font> 添加到暂存区</li>\n<li>等待时机后 <font title='red'>git commit</font> 提交保存到版本库，产生一次版本快照记录</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"git-文件状态\"><a class=\"markdownIt-Anchor\" href=\"#git-文件状态\">#</a> Git 文件状态</h3>\n<p>Git 文件 2 种状态：</p>\n<ul>\n<li>未跟踪：新文件，从未被 Git 管理过</li>\n<li>已跟踪：Git 已经知道和管理的文件</li>\n</ul>\n<p><strong>使用</strong>：修改文件，暂存，提交保存记录，如此反复</p>\n<p><strong>需求</strong>：新增 css 文件，并使用 <font title='red'>git status -s</font> 查看文件状态，并最终提交</p>\n<table>\n<thead>\n<tr>\n<th>文件状态</th>\n<th>概念</th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>未跟踪 (U)</td>\n<td>从未被 Git 管理过</td>\n<td>新文件</td>\n</tr>\n<tr>\n<td>新添加 (A)</td>\n<td>第一次被 Git 暂存</td>\n<td>之前版本记录无此文件</td>\n</tr>\n<tr>\n<td>未修改 (‘ ’)</td>\n<td>三个区域统一</td>\n<td>提交保存后</td>\n</tr>\n<tr>\n<td>已修改 (M)</td>\n<td>工作内容变化</td>\n<td>修改了内容产生</td>\n</tr>\n</tbody>\n</table>\n<p>其它的状态：</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>D</td>\n<td>你本地删除的文件 (服务器上还在)</td>\n</tr>\n<tr>\n<td>R</td>\n<td>文件名被修改</td>\n</tr>\n<tr>\n<td>T</td>\n<td>文件的类型被修改</td>\n</tr>\n<tr>\n<td>X</td>\n<td>未知状态</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171406687.png\" alt=\"image-20230817140620456\"></p>\n<p>第一列是暂存区状态</p>\n<p>第二列是工作区状态</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171407660.png\" alt=\"image-20230817140706529\"></p>\n<p><strong>演示</strong>：</p>\n<h4 id=\"1-新增一个css文件\"><a class=\"markdownIt-Anchor\" href=\"#1-新增一个css文件\">#</a> 1 新增一个 css 文件</h4>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171410453.png\" alt=\"image-20230817141012331\"></p>\n<h4 id=\"2-执行git-add\"><a class=\"markdownIt-Anchor\" href=\"#2-执行git-add\">#</a> 2 执行：git add .</h4>\n<p>将所有文件添加到暂存区，然后 git status -s 查看状态</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171411783.png\" alt=\"image-20230817141140352\"></p>\n<p>css 文件处于 新添加状态 (A)</p>\n<h4 id=\"3-改动css内容\"><a class=\"markdownIt-Anchor\" href=\"#3-改动css内容\">#</a> 3 改动 css 内容</h4>\n<p>如果改动一下 css 文件的内容，然后执行命令：git status -s 查看状态</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171414244.png\" alt=\"image-20230817141443339\"></p>\n<p>后面就会跟着一个 M 已修改状态 (M)  被修改过的文件。</p>\n<h4 id=\"4-改动内容同步到暂存区\"><a class=\"markdownIt-Anchor\" href=\"#4-改动内容同步到暂存区\">#</a> 4 改动内容同步到暂存区</h4>\n<p>如果想让工作区里的改动同步到暂存区则需要再重复执行命令：git add .</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171417881.png\" alt=\"image-20230817141704591\"></p>\n<p>工作区里面就是最新的了</p>\n<h4 id=\"5-将暂存区的文件提交到版本库\"><a class=\"markdownIt-Anchor\" href=\"#5-将暂存区的文件提交到版本库\">#</a> 5 将暂存区的文件提交到版本库</h4>\n<p>执行命令：git commit -m ‘备注’ ，再执行 git status -s 后 可以看到当前没有任何变化的文件了，现在就是未修改状态了 (‘’) 三个区域统一。</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171420856.png\" alt=\"image-20230817142029345\"></p>\n<p>如果再对 css 文件进行内容的更改就有 处于 已修改状态了 (M)</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171423614.png\" alt=\"image-20230817142323012\"></p>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>Git 文件状态分为哪 2 种？\n<ul>\n<li>未跟踪和已跟踪 (新添加，未修改，已修改)</li>\n</ul>\n</li>\n<li>如何查看暂存区和工作区文件状态？\n<ul>\n<li>git status -s</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"git-暂存区使用\"><a class=\"markdownIt-Anchor\" href=\"#git-暂存区使用\">#</a> Git 暂存区使用</h3>\n<p>暂<strong>存区</strong>：暂时存储，可以临时恢复代码内容，与版本库解耦</p>\n<p>暂存区 -》 覆盖 -》 工作区 ，<strong>命令</strong>：git restore 目标文件 (<span alt='solid'>注意</span>：<font title='red'>完全确认覆盖时使用</font>)</p>\n<p>从暂存区移除文件，<strong>命令</strong>： <code>git rm --cached</code>  目标文件</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171430065.png\" alt=\"image-20230817143038646\"></p>\n<p><strong>演示</strong>：</p>\n<h4 id=\"演示-git-restore\"><a class=\"markdownIt-Anchor\" href=\"#演示-git-restore\">#</a> 演示 git restore</h4>\n<p>查看暂存区的文件列表：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171433851.png\" alt=\"image-20230817143328392\"></p>\n<p>暂存区中有两个代码文件，我想重写一个 html 文件的代码</p>\n<p>原本的代码内容：里面是经过 webpack 打包压缩的 不过没关系 照改</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171435559.png\" alt=\"image-20230817143518094\"></p>\n<p>更改后的代码内容：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171436138.png\" alt=\"image-20230817143625820\"></p>\n<p>查看页面样式</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171436381.png\" alt=\"image-20230817143653837\"></p>\n<p>我有觉得太丑了没有之前那个写的好，但是那么多代码和思路 ， 总不能完美复刻上一次的代码把。怎么办呢？</p>\n<p>git 中执行命令：git restore 将 index.html 在暂存区中的那个代码文件覆盖工作区的这个 index.html</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171439985.png\" alt=\"image-20230817143945385\"></p>\n<p>查看 index.html 文件的内容，可以看到之前的代码就回来了</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171439980.png\" alt=\"image-20230817143917985\"></p>\n<h4 id=\"演示-git-rm-cached\"><a class=\"markdownIt-Anchor\" href=\"#演示-git-rm-cached\">#</a> 演示  <code>git rm --cached</code></h4>\n<p>执行命令：git ls-files 查看暂存区中的文件</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171442503.png\" alt=\"image-20230817144237248\"></p>\n<p>将 index.css 从暂存区中移除，执行命令： <code>git rm --cached [目标文件]</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171443352.png\" alt=\"image-20230817144355199\"></p>\n<h3 id=\"练习登录页面\"><a class=\"markdownIt-Anchor\" href=\"#练习登录页面\">#</a> 练习 — 登录页面</h3>\n<p><strong>需求</strong>：新增 JS 代码并暂存提交产生新的版本快照</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>新增 JS 文件和内容</li>\n<li>临时存放在暂存区</li>\n<li>提交保存到版本库</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171454405.png\" alt=\"image-20230817145450013\"></p>\n<p>将登录页面的项目代码拷贝到 git 仓库的目录下</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171516124.png\" alt=\"image-20230817151633818\"></p>\n<p>使用命令将项目所有代码都添加到暂存区里面</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171517420.png\" alt=\"image-20230817151732684\"></p>\n<p>提交到版本库中</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171518156.png\" alt=\"image-20230817151804855\"></p>\n<p>查看提交的历史记录</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171518633.png\" alt=\"image-20230817151835956\"></p>\n<blockquote>\n<p>上图其中的 HEAD 表示本次提交分支，它指向了 主线 (主仓库) ，最前面的 字符串序列 是版本序列号</p>\n</blockquote>\n<h3 id=\"git-回退版本\"><a class=\"markdownIt-Anchor\" href=\"#git-回退版本\">#</a> Git 回退版本</h3>\n<blockquote>\n<p>概念：把版本库某个版本对应的内容快照，恢复到工作区 / 暂存区</p>\n</blockquote>\n<p>查看提交历史： <code>git log --oneline</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171523118.png\" alt=\"image-20230817152320802\"></p>\n<p><strong>回退命令</strong>：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171536327.png\" alt=\"image-20230817153622766\"></p>\n<h6 id=\"第一种模式\"><a class=\"markdownIt-Anchor\" href=\"#第一种模式\">#</a> 第一种模式</h6>\n<p><code>git reset --soft 版本号</code>  (其它文件未跟踪)</p>\n<p>执行命令后，会将对应<font title='red'>版本库</font>的序列号的文件以及内容<span alt='wavy'>恢复</span>到 <font title='red'>暂存区</font> 和 <font title='red'>工作区</font><sup>覆盖原有文件的内容</sup> 尽可能<span alt='wavy'>保留 工作区 和 暂存区 里面的文件</span> ，但是这些<span alt='wavy'>保留的文件会变为 未被跟踪状态 </span>(U)</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171535610.png\" alt=\"image-20230817153547119\"></p>\n<h6 id=\"第二种模式\"><a class=\"markdownIt-Anchor\" href=\"#第二种模式\">#</a> 第二种模式</h6>\n<p><code>git reset --hard 版本号</code></p>\n<p>执行命令后，<font title='red'>暂存区</font>就<span alt='wavy'>只有版本库中对应的文件以及内容了其它的都会被</span><font title='red'>清除掉</font>而且<font title='red'>工作区</font>也是<span alt='wavy'>同样的效果</span>。这种模式<span alt='solid'>比较彻底</span>.</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171536906.png\" alt=\"image-20230817153610464\"></p>\n<h6 id=\"第三种模式\"><a class=\"markdownIt-Anchor\" href=\"#第三种模式\">#</a> 第三种模式</h6>\n<p><code>git reset --mixed 版本号</code>  (与 git reset 等价)</p>\n<p>执行命令后，<font title='red'>暂存区</font>里面的文件以及内容<span alt='wavy'>被版本库对应的文件覆盖</span>，但是在<font title='red'>工作区</font>中<span alt='wavy'>保留它原有的文件以及内容</span>.</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171536075.png\" alt=\"image-20230817153648781\"></p>\n<blockquote alt='danger'>\n\t<div>\n      <p>\n         <span><font title=red>注意1</font>：只有记录在版本库的提交记录才能恢复</span>\n      </p>\n      <p>\n         <span><font title=red>注意2</font>：回退后，继续修改 -> 暂存 -> 提交操作即可 (产生新的提交记录过程)</span>\n      </p>\n   </div>\n</blockquote>\n<h4 id=\"演示\"><a class=\"markdownIt-Anchor\" href=\"#演示\">#</a> 演示</h4>\n<h5 id=\"第三种模式-2\"><a class=\"markdownIt-Anchor\" href=\"#第三种模式-2\">#</a> 第三种模式</h5>\n<p>执行命令查看暂存区中的文件：git ls-files</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171550533.png\" alt=\"image-20230817155035750\"></p>\n<p>查看所有版本库对应的序列号，对应序列号进行回退</p>\n<p>执行命令：</p>\n<p><code>git log --oneline</code></p>\n<p><code>git reset --mixed 90d394d</code></p>\n<p>然后查看暂存区中的文件以及内容：git ls-files 可以看到里面的文件以及内容被对应序列号版本库里面的文件以及内容覆盖了，其它的被清除掉了，但是并不会清除 工作区的文件以及内容</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171550378.png\" alt=\"image-20230817155053525\"></p>\n<p>查看工作区的情况</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171553373.png\" alt=\"image-20230817155331841\"></p>\n<h5 id=\"第二种模式-2\"><a class=\"markdownIt-Anchor\" href=\"#第二种模式-2\">#</a> 第二种模式</h5>\n<p>执行命令进行回退： <code>git reset --hard 90d394d</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171555624.png\" alt=\"image-20230817155536935\"></p>\n<p>查看工作区的情况</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171556134.png\" alt=\"image-20230817155624192\"></p>\n<p>工作区没有被覆盖，但是上面说，暂存区 和 工作区 都会被覆盖 并 清除其它的文件以及内容的啊。</p>\n<p><strong>解释</strong>：</p>\n<p>因为在上面使用第三种模式回退时。暂存区 与 对应版本库 文件以及内容一致 是 未修改状态 (‘’) ，而且清除了其它的文件以及内容。而工作区 只是覆盖了 对应版本库 的文件以及内容 ，其它的文件变成了 未跟踪状态了 (U) 。所以 工作区 再执行 回退 那些 未跟踪的 文件以及 内容也不会发生任何事情。</p>\n<p>它也是从右向左进行 对照 影响的。</p>\n<p><strong>解决</strong>：</p>\n<p>执行命令：git add . 让 工作区 与 暂存区 的文件以及内容一致 然后在进行回退</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171601944.png\" alt=\"image-20230817160110680\"></p>\n<p>查看工作区情况</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171601270.png\" alt=\"image-20230817160131858\"></p>\n<p>回退之后再进行查看版本库的历史版本</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171604957.png\" alt=\"image-20230817160430318\"></p>\n<h4 id=\"查看完整版本库历史日志\"><a class=\"markdownIt-Anchor\" href=\"#查看完整版本库历史日志\">#</a> 查看完整版本库历史日志</h4>\n<p>因为回退到了对应的版本后之后的版本都不见了，怎么办呢？</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171607163.png\" alt=\"image-20230817160720559\"></p>\n<p><strong>解决</strong>：</p>\n<p>使用完整查看 版本库历史 日志的命令： <code>git reflog --online</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171607640.png\" alt=\"image-20230817160742375\"></p>\n<p>再次回退到 最新的版本库 ，也就是：登录页面 - 开发完毕 的这个</p>\n<p>执行命令： <code>git reset --hard 16babbc</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171609122.png\" alt=\"image-20230817160921582\"></p>\n<p>查看回退之后的暂存区和工作区的情况</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171610890.png\" alt=\"image-20230817161045206\"></p>\n<blockquote>\n<p><span alt='solid'>总结</span>：</p>\n<ol>\n<li>什么是 Git 回退版本？\n<ul>\n<li>把版本库某个对应的内容快照，恢复到工作区 / 暂存区</li>\n</ul>\n</li>\n<li>强制覆盖暂存区和工作区的命令？\n<ul>\n<li><code>git reset --hard 版本号</code></li>\n</ul>\n</li>\n<li>如何查看提交历史？\n<ul>\n<li><code>git log --oneline</code></li>\n<li>查看完整的： <code>git reflog --oneline</code></li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"删除文件\"><a class=\"markdownIt-Anchor\" href=\"#删除文件\">#</a> 删除文件</h3>\n<p><strong>需求</strong>：删除 editor.js 文件，并产生一次版本记录</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>手动删除 工作区 文件</li>\n<li>暂存变更 / 手动删除暂存区文件造成变更\n<ul>\n<li><code>git add .</code></li>\n<li><code>rm -f --cached 路径/文件名</code></li>\n</ul>\n</li>\n<li>提交保存</li>\n</ol>\n<blockquote>\n<p><span alt='solid'>总结</span>：</p>\n<p>工作区只要改变，都可以暂存提交产生新记录</p>\n</blockquote>\n<h3 id=\"忽略文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略文件\">#</a> 忽略文件</h3>\n<blockquote>\n<p>概念： <code>.gitignore</code>  配置文件可以让 git 彻底 <font title='red'>忽略跟踪</font> 指定文件</p>\n</blockquote>\n<p><strong>目的</strong>：让 git 仓库更小更快，避免重复无意义的文件管理</p>\n<p><strong>例如</strong>：</p>\n<ol>\n<li>系统或软件自动生成的文件</li>\n<li>编译产生的结果文件</li>\n<li>运行时生成的日志文件，缓存文件，临时文件等</li>\n<li>涉密文件，密码，密钥等文件</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171629450.png\" alt=\"image-20230817162932902\"></p>\n<p><strong>创建</strong>：</p>\n<ol>\n<li>项目根目录新建 <code>.gitignore</code>  文件</li>\n<li>填入相应配置来忽略指定文件</li>\n<li>不用管要忽略的文件在哪个位置直接写它的名字就行</li>\n</ol>\n<blockquote alt='danger'>\n\t<div>\n      <p>\n         <span><font title=red>注意</font>：如果文件已经被暂存区跟踪过，可以从暂存区移除即可</span>\n      </p>\n   </div>\n</blockquote>\n<p>演示：</p>\n<p>项目根目录创建 <code>.gitignore</code>  忽略配置文件 里面配置 忽略 叫 password.txt 的文件</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171635902.png\" alt=\"image-20230817163519830\"></p>\n<p>在项目的 tuils 目录中有一个 password.txt 文件</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171636948.png\" alt=\"image-20230817163600805\"></p>\n<p>之前的时候 将项目添加到暂存区的时候是有 password.txt 文件的并且 添加到了暂存区</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171637426.png\" alt=\"image-20230817163700550\"></p>\n<p>将 password.txt 文件从暂存区中移除</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171638717.png\" alt=\"image-20230817163837250\"></p>\n<p>然后再将工作区的代码 添加到暂存区 这时候是有 忽略配置文件的。</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171641922.png\" alt=\"image-20230817164138303\"></p>\n<p>这样 password.txt 指定要被忽略的文件就被忽略了</p>\n<h3 id=\"分支\"><a class=\"markdownIt-Anchor\" href=\"#分支\">#</a> 分支</h3>\n<blockquote>\n<p>概念：本质上是指向 <font title='red'>提交节点</font> 的可变 <font title='red'>指针</font>，默认名字是 master</p>\n</blockquote>\n<blockquote alt='danger'>\n\t<div>\n      <p>\n         <span><font title=red>注意</font>：<span alt='solid'>HEAD指针</span></span>影响工作区/暂存区的代码状态</span>\n      </p>\n   </div>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171644086.png\" alt=\"image-20230817164441779\"></p>\n<p><strong>场景</strong>：开发<font title='red'>新需求 / 修复 BUG</font>，保证主线代码随时可用，多人协同开发提高效率</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171656807.png\" alt=\"image-20230817164853276\"></p>\n<p>假如说公司招了一个前端新人，我想让它接着我的项目代码接着写。但是我不想让它影响到我现在已经开发完的主线代码。怎么办呢？</p>\n<p>这就需要用到分支概念了</p>\n<p><strong>例如</strong>：在现有代码上创建新分支完成内容列表业务</p>\n<p>所以可以让在现有的分支基础上创建一个 content 分支，让这个分支下来实现内容列表业务的开发</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171656679.png\" alt=\"image-20230817165128330\"></p>\n<p>这样就不会影响我 master 默认主分支的代码了。</p>\n<p>也就是说 content 分支下暂存提交产生的版本记录不会影响 master 分支下看到的代码，开发完成后再合并回到 master 主分支下</p>\n<hr>\n<p>突然需要紧急修复 BUG— 单独创建分支解决 BUG</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171655189.png\" alt=\"image-20230817165556763\"></p>\n<h4 id=\"创建分支\"><a class=\"markdownIt-Anchor\" href=\"#创建分支\">#</a> 创建分支</h4>\n<p><strong>需求</strong>：创建内容列表 content 分支，并产生 3 次提交记录</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>\n<p>创建分支命令： <code>git branch 分支名</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171658414.png\" alt=\"image-20230817165818460\"></p>\n<blockquote alt='danger'>\n   <div>\n      <P>\n         <span>创建分支以当前HEAD指针，指向的提交记录作为起点。将新的分支指向HEAD指向的提交记录</span>\n      </P>\n   </div>\n</blockquote>\n</li>\n<li>\n<p>切换分支命令： <code>git checkout 分支名</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171701078.png\" alt=\"image-20230817170110799\"></p>\n<p>让 HEAD 指针指向新创建的分支，HEAD 会影响 工作区和暂存区 的代码。</p>\n</li>\n<li>\n<p>工作区 准备 代码 并暂存提交，重复 3 次</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171703585.png\" alt=\"image-20230817170330021\"></p>\n<p>命令： <code>git branch</code>  查看当前 git 仓库当中有哪些分支</p>\n<p><img src=\"./Git.assets/image-20230817170607707.png\" alt=\"image-20230817170607707\"></p>\n<p>提交三次版本库代码</p>\n<p><img src=\"./Git.assets/image-20230817172211736.png\" alt=\"image-20230817172211736\"></p>\n<p>查看提交记录</p>\n<p><img src=\"./Git.assets/image-20230817172259808-1692264248011-5.png\" alt=\"image-20230817172259808\"></p>\n<p>content 分支 新增加的代码内容</p>\n<p><img src=\"./Git.assets/image-20230817172420105.png\" alt=\"image-20230817172420105\"></p>\n<p>切换到 master 主分支，切换后 content 分支创建的项目就没有了</p>\n<p><img src=\"./Git.assets/image-20230817172500666.png\" alt=\"image-20230817172500666\"></p>\n</li>\n</ol>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>什么是 Git 分支？\n<ul>\n<li>指针，指向提交记录</li>\n</ul>\n</li>\n<li>HEAD 指针的作用？\n<ul>\n<li>影响暂存区和工作区的代码</li>\n</ul>\n</li>\n<li>如何创建和切换指针？\n<ul>\n<li>git branch 分支名</li>\n<li>git checkout 分支名</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"练习登录bug修复\"><a class=\"markdownIt-Anchor\" href=\"#练习登录bug修复\">#</a> 练习 — 登录 BUG 修复</h3>\n<p>需求：新建 login-bug 分支，做 2 次提交记录 (对手机号长度，验证码长度做判断)</p>\n<p>步骤：</p>\n<ol>\n<li>切回到主分支：git checkout master</li>\n<li>创建新分支：git branch login-bug</li>\n<li>切换新分支：git checkout login-bug</li>\n<li>修改代码，暂存，提交产生版本记录</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171732512.png\" alt=\"image-20230817173236845\"></p>\n<p>修复点代码后添加到暂存区然后提交到版本库中</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171740320.png\" alt=\"image-20230817174037592\"></p>\n<h3 id=\"分支合并与删除\"><a class=\"markdownIt-Anchor\" href=\"#分支合并与删除\">#</a> 分支 — 合并与删除</h3>\n<p><strong>需求</strong>：把 login-bug 合并回到 master 分支并删除 login-bug 分支</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>切回到合入的分支上：git checkout master</li>\n<li>合并其它分支过来：git merge login-bug</li>\n<li>删除合并后的分支指针：git branch -d login-bug</li>\n</ol>\n<p>合并分支：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171749315.png\" alt=\"image-20230817174655075\"></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171749622.png\" alt=\"image-20230817174748472\"></p>\n<p>分支合并后 master 就拿到了 login-bug 修复 bug 后的代码了那么它的任务也就完成了。</p>\n<h4 id=\"移除分支git-branch-d-分支名\"><a class=\"markdownIt-Anchor\" href=\"#移除分支git-branch-d-分支名\">#</a> 移除分支：git branch -d 分支名</h4>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171749922.png\" alt=\"image-20230817174944702\"></p>\n<h3 id=\"分支合并与提交\"><a class=\"markdownIt-Anchor\" href=\"#分支合并与提交\">#</a> 分支 — 合并与提交</h3>\n<p><strong>合并提交</strong>：发生于 <font title='red'>原分支</font> 产生了<font title='red'> 新的提交</font> 记录后，再<font title='red'>合并</font>回去时发生，自动使用多个快照记录合并后产生一次新的提交</p>\n<p>步骤：</p>\n<ol>\n<li>切回到要合入的分支上：git checkout master</li>\n<li>合并其它分支过来：git merge content</li>\n<li>删除合并后的分支：git branch -d content</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171758341.png\" alt=\"image-20230817175358515\"></p>\n<p>最后合并回到主分支上时，提交记录流程图：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171758112.png\" alt=\"image-20230817175811579\"></p>\n<blockquote alt='danger'>\n   <div>\n      <P>\n         <span><font title='red'>注意</font>：提交记录的顺序按照产生的先后顺序排列，而非合并后的先后顺序</span>\n      </P>\n   </div>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171924499.png\" alt=\"image-20230817180223745\"></p>\n<p>合并后发现，content 分支还在指向它原来的分支，在 HEAD 指向的 master 分支下，及拥有 login-bug 分支的代码，又拥有 content 提交的最新代码，它将这两个分支的代码进行了 ort 的策略的合并提交</p>\n<p>合并后 content 分支就没有用处了，将其移除。</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171927001.png\" alt=\"image-20230817192727577\"></p>\n<h3 id=\"分支合并冲突\"><a class=\"markdownIt-Anchor\" href=\"#分支合并冲突\">#</a> 分支 — 合并冲突</h3>\n<p>需求 1：基于 master 新建 publish 分支，完成发布文章业务，然后修改内容页面的 html 文件的 title 标签内容，并提交一次。</p>\n<p>需求 2：切换到 master，也在修改内容页面的 html 文件的 title 标签修改内容，并提交一次。</p>\n<p>冲突：把 publish 分支合并到 master 回来，产生合并冲突</p>\n<p>概念：<font title='red'>不同分支中</font>，对于<font title='red'>同一个文件</font>的<font title='red'>同一部分修改</font>，Git 无法干净的合并，产生合并冲突</p>\n<p>解决：</p>\n<ol>\n<li>找到冲突文件并手动解决</li>\n<li>解决后需要提交一次记录</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171939278.png\" alt=\"image-20230817193939951\"></p>\n<p>演示</p>\n<p>在 publish 分支中，在项目中创建一个 publish 目录并将黑马头条中的 publish 模块代码放入</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308171954472.png\" alt=\"image-20230817195427952\"></p>\n<p>在 publish 分支下修改 content/index.html 页面的 titile 标签内容</p>\n<p><img src=\"./Git.assets/image-20230817195602595.png\" alt=\"image-20230817195602595\"></p>\n<p>提交记录</p>\n<p><img src=\"./Git.assets/202308171942914.png\" alt=\"image-20230817194212620\"></p>\n<p>切换到 master 分支，并修改 content/index.html 的 title 标签的内容。</p>\n<p><img src=\"./Git.assets/image-20230817195730476.png\" alt=\"image-20230817195730476\"></p>\n<p><img src=\"./Git.assets/image-20230817195757409.png\" alt=\"image-20230817195757409\"></p>\n<p>提交记录</p>\n<p><img src=\"./Git.assets/image-20230817195855697.png\" alt=\"image-20230817195855697\"></p>\n<p>将 publish 分支进行合并</p>\n<p><img src=\"./Git.assets/image-20230817200320155.png\" alt=\"image-20230817200320155\"></p>\n<p>此时就产生了合并冲突</p>\n<h3 id=\"git常用命令\"><a class=\"markdownIt-Anchor\" href=\"#git常用命令\">#</a> Git 常用命令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git -v</td>\n<td>查看 git 版本</td>\n<td></td>\n</tr>\n<tr>\n<td>git init</td>\n<td>初始化 git 仓库</td>\n<td></td>\n</tr>\n<tr>\n<td>git add 路径 / 文件名</td>\n<td>暂存某个文件</td>\n<td>文件标识以终端为起始的相对路径</td>\n</tr>\n<tr>\n<td>git add .</td>\n<td>暂存所有文件</td>\n<td></td>\n</tr>\n<tr>\n<td>git commit -m ‘’</td>\n<td>提交产生版本记录</td>\n<td>每次提交，把暂存区内容快照一份</td>\n</tr>\n<tr>\n<td>git status</td>\n<td>查看文件状态 - 详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td>git status -s</td>\n<td>查看文件状态 - 简略信息</td>\n<td>第一列是暂存区状态，第二列是工作区状态</td>\n</tr>\n<tr>\n<td>git ls-files</td>\n<td>查看暂存区文件列表</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git restore 路径/文件名</code></td>\n<td>从暂存区恢复到工作区</td>\n<td>如果文件标识为。则恢复所有文件</td>\n</tr>\n<tr>\n<td><code>git rm --cached 路径 /文件名</code></td>\n<td>从暂存区移除文件</td>\n<td>不让 git 跟踪文件变化</td>\n</tr>\n<tr>\n<td><code>git log</code></td>\n<td>查看提交记录 - 详细信息</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git log --oneline</code></td>\n<td>查看提交记录 - 简略信息</td>\n<td>版本号 分支指针 提交时说明注释</td>\n</tr>\n<tr>\n<td><code>git reflog --oneline</code></td>\n<td>查看完整历史 - 简略信息</td>\n<td>包括提交， 切换，回退等所有记录</td>\n</tr>\n<tr>\n<td><code>git reset --hard 版本号</code>  (常用)</td>\n<td>切换版本代码到暂存区和工作区</td>\n<td><code>--soft</code>  模式保留暂存区和工作区原本内容<br /> <code>--hard</code>  模式不保留暂存区和工作区原本内容<br /> <code>--mixed</code>  模式不保留暂存区，工作区保留 (默认)<br />先覆盖到暂存区，再用暂存区对比覆盖工作区</td>\n</tr>\n<tr>\n<td><code>git branch 分支名</code></td>\n<td>创建分支</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git  branch</code></td>\n<td>查看本地分支</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git branch -d 分支名</code></td>\n<td>删除分支</td>\n<td>请确保记录已经合并到别的分支下，再删除分支</td>\n</tr>\n<tr>\n<td><code>git checkout 分支名</code></td>\n<td>切换分支</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git checkout -b 分支名</code></td>\n<td>创建并立刻切换分支</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git merge 分支名</code></td>\n<td>把分支提交历史记录合并到当前所在分支</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git branch -D 分支名</code></td>\n<td>强制删除分支</td>\n<td>一般不建议使用</td>\n</tr>\n<tr>\n<td><code>git branch -m 分支命名</code></td>\n<td>修改分支的名称</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>当拉去最新远程仓库代码到本地时出现：refusing to merge unrelated histories 解决办法如下：</p>\n<p><code>git pull origin master --allow-unrelated-histories</code>  标志来允许合并不相关的历史记录</p>\n<h3 id=\"git-远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#git-远程仓库\">#</a> Git 远程仓库</h3>\n<p><strong>概念</strong>：托管在因特网或其它网络中的你的项目的<font title='red'>版本库</font>.</p>\n<p><strong>作用</strong>：保存版本库的历史记录，多人协作</p>\n<p><strong>创建</strong>：公司自己服务器 / 第三方托管平台 (Gitee，GitLab，GitHub …)</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172031783.png\" alt=\"image-20230817203135688\"></p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>\n<p>新建仓库得到远程仓库 Git 地址</p>\n</li>\n<li>\n<p>本地 Git 仓库添加远程仓库原点地址</p>\n<p>命令： <code>git remote add 远程仓库别名 远程仓库地址</code></p>\n<p>例如： <code>git remotea add origin https://xxx.xxx.git</code></p>\n</li>\n<li>\n<p>本地 Git 仓库推送版本记录到远程仓库</p>\n<p>命令： <code>git push -u 远程仓库别名 本地和远程分支名</code></p>\n<p>例如： <code>git push -u origin master</code></p>\n<p>完整写法： <code>git push --set-upstream origin master:master</code></p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172037228.png\" alt=\"image-20230817203743706\"></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172057840.png\" alt=\"image-20230817204421000\"></p>\n<p>命令：git remote -v 查看本地 git 仓库中都有哪些远程仓库的地址</p>\n<p>fetch：从哪个远程仓库取来对应版本库的内容</p>\n<p>push：往哪个远程仓库版本库里面推送</p>\n<p>如果远程仓库的地址填错了，想要换一个不能直接再添加一次而是移除后再添加如下：</p>\n<p>移除远程仓库的地址： <code>git remote remove origin</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172057018.png\" alt=\"image-20230817204740674\"></p>\n<p>推送代码到 gitee 上</p>\n<p>执行命令： <code>git push -u origin master</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172057935.png\" alt=\"image-20230817205150194\"></p>\n<p>查看 gitee 对应的仓库的变化</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172100506.png\" alt=\"image-20230817210012892\"></p>\n<p>第一次使用 git 的时候，它会弹出 gitee 的一个登录器，让你用账号密码登录才能推送代码，使用 https 开头的协议它需要账号，密码进行连接。如果要是换了 gitee 账号 那怎么办呢？</p>\n<p><span alt='solid'>解决如下</span>：</p>\n<p>在 windows 上打开控制面板，进入到 凭据管理器，点击 windows 凭据 中看到有一个 git:gitee 的网址 点击展开，将其删除。我们再使用 https 开头的地址它就会再次让我们输入对应新的账号，密码了。</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172058682.png\" alt=\"image-20230817205535447\"></p>\n<blockquote>\n<p>总结：</p>\n<ol>\n<li>远程版本库的作用？\n<ul>\n<li>保存提交历史记录，多人共享</li>\n</ul>\n</li>\n<li>远程版本库使用步骤？\n<ul>\n<li>创建远程版本库 (自己服务器 / 第三方托管平台)</li>\n<li>本地版本库设置远程地址</li>\n<li>推送本地版本库到远程</li>\n</ul>\n</li>\n<li>推送的命令？\n<ul>\n<li><code>git push -u origin master</code></li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"git-远程仓库克隆\"><a class=\"markdownIt-Anchor\" href=\"#git-远程仓库克隆\">#</a> Git 远程仓库 — 克隆</h3>\n<p><strong>克隆</strong>：拷贝一个 Git 仓库到本地，进行使用</p>\n<blockquote>\n<p><span alt='solid'>得到一个 Git 仓库有两种方式</span>：</p>\n<ol>\n<li>使用 <code>git init</code>  自己在本地转换</li>\n<li>克隆仓库到本地使用</li>\n</ol>\n</blockquote>\n<p><strong>命令</strong>：<font title='red'>git clone 远程仓库地址</font>，例如： <code>git clone https://xxx.xxx.git</code></p>\n<p><strong>效果</strong>：在运行命令所在文件夹，生成 work 项目文件夹 (包含版本库，并映射到暂存区和工作区)</p>\n<blockquote alt='danger'>\n\t<div>\n      <P>\n         <span><font title='red'>注意1</font>：Git 本地仓库已经建立好和远程仓库的链接</span>\n      </P>\n      <P>\n         <span><font title='red'>注意2</font>：仓库公开随意克隆，推送需要身为仓库团队成员</span>\n      </P>\n   </div>\n</blockquote>\n<p>演示：</p>\n<p>终端 cd 到指定的目录下执行命令： <code>git clone https://xxx.xxx.git</code></p>\n<p>复制要克隆的地址</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172132553.png\" alt=\"image-20230817213248571\"></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172138708.png\" alt=\"image-20230817213640684\"></p>\n<p>克隆之后进入目录中，里面有一个.git 隐藏文件表示是一个仓库</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172138542.png\" alt=\"image-20230817213722667\"></p>\n<p>执行命令查看提交的历史记录： <code>git log --oneline</code></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202308172138187.png\" alt=\"image-20230817213836924\"></p>\n<h3 id=\"多人协同开发\"><a class=\"markdownIt-Anchor\" href=\"#多人协同开发\">#</a> 多人协同开发</h3>\n<p>需求：小传新代码共享给小智</p>\n<p>步骤：</p>\n<ol>\n<li>小传开发代码  -&gt; 工作区 -&gt; 暂存区 -&gt; 提交 -&gt; 拉取 (可选) -&gt; 推送</li>\n<li>小智 -&gt; 拉取 (后续也可以开发代码 -&gt; … -&gt; 推送)</li>\n<li>想要看别人同步上去的最新内容： <code>git pull origin master</code>  等价于\n<ol>\n<li><code>git fetch origin master:master</code>  (获取远程分支记录到本地，未合并)</li>\n<li><code>git merge origin/master</code>  (把远程分支记录合并到所在分支下)</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"git-命令总结\"><a class=\"markdownIt-Anchor\" href=\"#git-命令总结\">#</a> Git 命令总结</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n<th>注意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>git remote add 远程仓库别名 远程仓库地址</code></td>\n<td>添加远程仓库地址</td>\n<td>别名唯一，地址是.git 结尾的网址</td>\n</tr>\n<tr>\n<td><code>git remote -v</code></td>\n<td>查看远程仓库地址</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git remote remove 远程仓库别名</code></td>\n<td>删除远程仓库地址</td>\n<td></td>\n</tr>\n<tr>\n<td><code>git pull 远程仓库别名 分支名</code></td>\n<td>拉取</td>\n<td>完整写法： <code>git pull</code>  远程仓库别名 远程分支名：本地分支名<br />等价于： <code>git fetch</code>  和 <code>git merge</code></td>\n</tr>\n<tr>\n<td><code>git push 远程仓库别名 分支名</code></td>\n<td>推送</td>\n<td>完整写法： <code>git push</code>  远程仓库别名 本地分支名：远程分支名 -u: 建立通道以后可以简写 git push</td>\n</tr>\n<tr>\n<td><code>git pull --rebase 远程仓库别名 分支名</code></td>\n<td>拉取合并</td>\n<td>合并没有关系的记录</td>\n</tr>\n<tr>\n<td><code>git clone 远程仓库地址</code></td>\n<td>克隆</td>\n<td>从 0 得到一个远程的 Git 仓库到本地使用</td>\n</tr>\n<tr>\n<td><code>git push -u -f 远程仓库别名 分支名</code></td>\n<td>强制推送</td>\n<td>会覆盖原有的内容 慎用</td>\n</tr>\n<tr>\n<td><code>git clone -b [分支名] 远程仓库地址</code></td>\n<td>拉取指定的分支项目</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"推送超出文件大小范围的解决方式\"><a class=\"markdownIt-Anchor\" href=\"#推送超出文件大小范围的解决方式\">#</a> 推送超出文件大小范围的解决方式</h3>\n<p>打开当前初始化.git 的文件里面的 config 配置文件 配置如下</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>http<span class=\"token punctuation\">]</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>postBuffer <span class=\"token operator\">=</span> <span class=\"token number\">924288000</span></pre></td></tr></table></figure>",
            "tags": [
                "基础",
                "git"
            ]
        }
    ]
}