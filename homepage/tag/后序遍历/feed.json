{
    "version": "https://jsonfeed.org/version/1",
    "title": "homepage • All posts by \"后序遍历\" tag",
    "description": "欢迎来我的博客空间",
    "home_page_url": "https://pigpigletsgo.github.io/homepage",
    "items": [
        {
            "id": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/java/programming-questions/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0/",
            "url": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/java/programming-questions/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0/",
            "title": "二叉树最大深度-使用非递归后序遍历求解",
            "date_published": "2024-04-02T06:23:30.497Z",
            "content_html": "<h1 id=\"二叉树最大深度-使用非递归后序遍历实现\"><a class=\"markdownIt-Anchor\" href=\"#二叉树最大深度-使用非递归后序遍历实现\">#</a> 二叉树最大深度 - 使用非递归后序遍历实现</h1>\n<p>给定一个二叉树  <code>root</code>  ，返回其最大深度。</p>\n<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/tmp-tree.jpg\" alt=\"img\"></p>\n<pre><code>输入：root = [3,9,20,null,null,15,7]\n输出：3\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：root = [1,null,2]\n输出：2\n</code></pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数量在  <code>[0, 104]</code>  区间内。</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"思路分析\"><a class=\"markdownIt-Anchor\" href=\"#思路分析\">#</a> 思路分析：</h2>\n<p>使用非递归 的 后序遍历 我们需要使用到 栈 将经过的 节点 压入栈中</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20240128220924192.png\" alt=\"image-20240128220924192\"></p>\n<p>我们先是 向左走到走并且 将 经过的所有节点都压入栈 中，当回去的时候再不断的将 栈中的元素 弹出</p>\n<p>但是我们可以注意一下，从 1 走到 4 走到头了，那么这时栈中元素的个数 就代表着 树 从 1 到 4 它的深度</p>\n<p>当然这不是最大深度，如果接下来是从 1 到 7 ，走到 7 可能会是如下图所示的样子：</p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20240128221252821.png\" alt=\"image-20240128221252821\"></p>\n<p>那么这时我们就需要 将 最大深度 更新一下。</p>\n<p>每次如果有更大的值，那么就更新 最大深度的值，等到所有节点都遍历过一遍之后，记录的 最大深度的值 就是 这棵树的最大深度</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现：</h2>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// 先实现 非递归的后序遍历代码</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token class-name\">TreeNode</span> cur <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token comment\">// 记录 最近弹出元素</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">TreeNode</span> pop <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">// 记录 最大深度的值</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token comment\">// 非递归后序遍历我们需要使用到 栈来存储 回去的路</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">></span></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">// 如果 cur 不为 null 并且 stack 不为空 就循环</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token comment\">// 判断 cur 不为 null 就将 当前 cur 存储到 栈中 记录来时的路</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token comment\">// 判断 最大深度的值 每次更新 max 的值</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>max <span class=\"token operator\">&lt;</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                    max <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token comment\">// 向左不断走</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                cur <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                <span class=\"token comment\">// 拿一下 栈顶元素</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token class-name\">TreeNode</span> peek <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>                <span class=\"token comment\">// 判断 来时的上一个元素 的右边是否有节点 并 判断 来时的路的 右边节点是否走过了，走过就不走了不然会死循环 到这</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>peek<span class=\"token punctuation\">.</span>right <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> peek<span class=\"token punctuation\">.</span>right <span class=\"token operator\">==</span> pop<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                    <span class=\"token comment\">// 没路可走了 并且 右边的孩子也处理过了那么就弹出来时的路回到 上一步 继续下一轮循环</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                    pop <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                    <span class=\"token comment\">// 向右不断走</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                    cur <span class=\"token operator\">=</span> peek<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token comment\">// 返回最大深度的值</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "java",
                "编程题",
                "二叉树",
                "后序遍历"
            ]
        },
        {
            "id": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/java/programming-questions/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B1%82%E8%A7%A3/",
            "url": "https://pigpigletsgo.github.io/homepage/2024/04/02/computer-science/java/programming-questions/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B1%82%E8%A7%A3/",
            "title": "二叉树最大深度-使用递归后序遍历求解",
            "date_published": "2024-04-02T06:23:30.494Z",
            "content_html": "<h1 id=\"二叉树最大深度-使用递归实现后序遍历求解\"><a class=\"markdownIt-Anchor\" href=\"#二叉树最大深度-使用递归实现后序遍历求解\">#</a> 二叉树最大深度 - 使用递归实现后序遍历求解</h1>\n<p>给定一个二叉树  <code>root</code>  ，返回其最大深度。</p>\n<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/tmp-tree.jpg\" alt=\"img\"></p>\n<pre><code>输入：root = [3,9,20,null,null,15,7]\n输出：3\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：root = [1,null,2]\n输出：2\n</code></pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数量在  <code>[0, 104]</code>  区间内。</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<h2 id=\"思路分析\"><a class=\"markdownIt-Anchor\" href=\"#思路分析\">#</a> 思路分析：</h2>\n<ol>\n<li>\n<p>得到左子树深度，得到右子树深度，二者最大者加一，就是本节点深度</p>\n</li>\n<li>\n<p>因为需要先得到左右子树深度，很显然是后序遍历典型应用</p>\n</li>\n<li>\n<p><strong>关于深度的定义</strong>：从根出发，离根最远的节点总边数</p>\n<p>注意：力扣里的深度定义要多一</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现：</h2>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HeroNode</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token comment\">// 当前节点为 null 结束当前递归</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token comment\">// 看当前节点的 左边是否还有节点 (d1 只记录 左边 节点数量)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token keyword\">int</span> d1 <span class=\"token operator\">=</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span><span class=\"token function\">getLeft</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token comment\">// 看当前节点的 右边是否还有节点 (d2 只记录 右边 节点数量)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token keyword\">int</span> d2 <span class=\"token operator\">=</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span><span class=\"token function\">getRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   <span class=\"token comment\">// 选择最长的 分支 + 1 = 答案 (最深长度)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token keyword\">return</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>d1<span class=\"token punctuation\">,</span> d2<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure>",
            "tags": [
                "java",
                "编程题",
                "二叉树",
                "后序遍历"
            ]
        }
    ]
}