{
    "version": "https://jsonfeed.org/version/1",
    "title": "homepage • All posts by \"多路查找树\" tag",
    "description": "欢迎来我的博客空间",
    "home_page_url": "https://pigpigletsgo.github.io/homepage",
    "items": [
        {
            "id": "https://pigpigletsgo.github.io/homepage/2024/01/24/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/",
            "url": "https://pigpigletsgo.github.io/homepage/2024/01/24/computer-science/java/data-structures-and-algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/",
            "title": "数据结构与算法-多路查找树",
            "date_published": "2024-01-24T10:48:45.799Z",
            "content_html": "<h2 id=\"多路查找树\"><a class=\"anchor\" href=\"#多路查找树\">#</a> 多路查找树</h2>\n<p><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8EB%E6%A0%91\">二叉树与 B 树</a></p>\n<p><a href=\"#%E6%A0%91\">树</a></p>\n<p>[B 树，B+ 树，B <code>*</code>  树](#B 树，B+ 树，B <code>*</code>  树)</p>\n<hr />\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t<strong>钢达姆机器人</strong></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/%E9%92%A2%E8%BE%BE%E5%A7%86%E6%9C%BA%E5%99%A8%E4%BA%BA.png\" alt=\"钢达姆机器人\" /></p>\n<h3 id=\"二叉树与b树\"><a class=\"anchor\" href=\"#二叉树与b树\">#</a> 二叉树与 B 树</h3>\n<p>二叉树的问题分析</p>\n<p>二叉树的操作效率较高，但是也存在问题，请看下面的二叉树</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711154532431.png\" alt=\"image-20230711154532431\" /></p>\n<p>层数：5</p>\n<p>节点数量：31</p>\n<ul>\n<li>计算方式：2 ^ 5<sup> 层数</sup> - 1 = 31</li>\n</ul>\n<ol>\n<li><mark>二叉树需要加载到内存的</mark>，如果二叉树的<mark>节点少</mark>，<mark>没</mark>有<mark>什么问题</mark>，但是如果二叉树的<mark>节点很多</mark> (比如 1 亿)，就<mark>存在</mark>如下<mark>问题</mark>：</li>\n<li><strong>问题 1</strong>：在<mark>构建二叉树时</mark>，需要<mark>多次进行  <code>i/o</code>  操作</mark> (海量数据存在<mark>数据库</mark>或<mark>文件</mark>中)，节点海量，<mark>构建二叉树时，速度有影响</mark>。</li>\n<li><strong>问题 2</strong>：<mark>节点海量</mark>，也会造成二叉树的<mark>高度很大</mark>，会<mark>降低操作速度</mark>。</li>\n</ol>\n<h4 id=\"多叉树\"><a class=\"anchor\" href=\"#多叉树\">#</a> 多叉树</h4>\n<ol>\n<li>在 &lt;font style=&quot;color:red&quot;&gt; 二叉树中 &lt;/font&gt;，每个节点有 &lt; font style=&quot;color:red&quot;&gt; 数据项 &lt;/font&gt;，&lt;font style=&quot;color:red&quot;&gt; 最多有两个子节点 &lt;/font&gt;。如果<mark>允许每个节点可以有更多的数据项</mark>和<mark>更多的子节点</mark>，就是<mark>多叉树</mark> (multiway tree)</li>\n<li>后面讲解的 2 - 3 树，2 - 3 - 4 树就是多叉树，<mark>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</mark>。</li>\n<li>举例说明 (下面 2 - 3 树就是一颗多叉树)</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711155922937.png\" alt=\"image-20230711155922937\" /></p>\n<p>多叉树中，如果一个节点中存在了三个分叉则称为 <mark>3 节点</mark>。如果是两个分叉则称为 <mark>2 节点</mark>。</p>\n<h4 id=\"b树的基本介绍\"><a class=\"anchor\" href=\"#b树的基本介绍\">#</a> B 树的基本介绍</h4>\n<p>B 树通过重新组织节点，降低树的高度，并减少  <code>i/o</code>  读写次数来提升效率。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711161106696.png\" alt=\"image-20230711161106696\" /></p>\n<p>上图说明：</p>\n<ul>\n<li>\n<p>一个 <strong>○</strong> 代表一个数项</p>\n</li>\n<li>\n<p>一整个 <strong>○ ○ ○</strong> 的集合代表一个节点</p>\n</li>\n</ul>\n<p><strong>优点理解</strong>：</p>\n<ul>\n<li>\n<p>降低树的高度：</p>\n<p>可以看到，一个节点中有很多数据项，就能大大减少节点数量，从而降低树的高度</p>\n</li>\n<li>\n<p>减少  <code>I/O</code>  读写次数</p>\n<p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页 (页的大小通常为 4K)，这样每个节点只需要一次  <code>i/o</code>  就可以完全载入。</p>\n<p>这样说，你可能没有概念，举个例子：将树的度 M 设置为 1024 ，在 600 亿个元素中最多只需要 4 次  <code>i/o</code>  操作就可以读取到想要的元素，B 树 (B+) 宽泛应用于文件存储系统以及数据库系统中。</p>\n<p>什么是 <strong>度</strong>？</p>\n</li>\n<li>\n<p>节点的度：</p>\n<p>一个节点下的子树节点个数就是 节点的度。</p>\n</li>\n<li>\n<p>树的度：</p>\n<p>指一颗树中 ，节点的度最大的哪一个值。</p>\n</li>\n</ul>\n<h3 id=\"树\"><a class=\"anchor\" href=\"#树\">#</a> 树</h3>\n<h4 id=\"2-3-树基本介绍\"><a class=\"anchor\" href=\"#2-3-树基本介绍\">#</a> 2 - 3 树基本介绍</h4>\n<p><strong>2 - 3 树 是最简单的 B 树结构，具有如下特点</strong>：</p>\n<ol>\n<li>\n<p><mark>2 - 3 树的所有叶子节点都在同一层</mark> (<strong>只要是 B 树都满足这个条件，就是满树</strong>)</p>\n</li>\n<li>\n<p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</p>\n<p>不能只有一个节点，<mark>说得通俗点就是不能比父节点的节点还少</mark></p>\n</li>\n<li>\n<p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p>\n<p>不能有二个子节点，一个子节点，<mark>说得通俗点就是不能比父节点的节点还少</mark></p>\n</li>\n<li>\n<p><mark>2 - 3 树</mark>是<mark>由二节点</mark>和<mark>三节点构成的树</mark>。</p>\n</li>\n</ol>\n<h5 id=\"2-3-树构建图解\"><a class=\"anchor\" href=\"#2-3-树构建图解\">#</a> 2-3 树构建图解</h5>\n<p>对数列 {16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成一个 2-3 树，那么它构建的规则要满足前面说的特点。下面进行图解后，你就明白，上面的特点是如何限制的。</p>\n<p>有几个额外的注意事项：</p>\n<ol>\n<li>一个节点中，最多只允许放 2 个数据。</li>\n<li>构建的树必须是有序的，也就是按照二叉排序 (BST) 的要求构建有序的树</li>\n</ol>\n<p>下面是图解步骤：</p>\n<ol>\n<li>添加 16,24</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173129240.png\" alt=\"image-20230711173129240\" /></p>\n<p>添加 16 时，没有数据，直接新建一个节点，放进去。</p>\n<p>添加 24 时，发现有一个节点了，并且比 16 大， 此时该节点中只有一个数据，则将 24 放在 16 的右边。</p>\n<ol start=\"2\">\n<li>添加 12</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173239395.png\" alt=\"image-20230711173239395\" /></p>\n<p>此时会发现，12 比 16 小，本来应该放在  16 的左边。此时发现这个节点 <strong>已经有两个数据了</strong>，那么就只能放在 <strong>左子节点</strong>。</p>\n<p>如果直接将 12 放到   <code>16 , 24</code>  的左节点，就会破坏 2-3 树的条件：2  节点 ，要么没有子节点，要么有两个节点。</p>\n<p>那么此时就只能将  <code>16,24</code>   这个节点进行拆分。如上图： 24  变成 16 的右节点，12 变成  16  的左节点。</p>\n<p>这时就满足了 2-3 树 的特性。</p>\n<ol start=\"3\">\n<li>添加 32</li>\n</ol>\n<p>这个就简单了，以现在的树结构，可以直接添加到 24 的 右边 ，变成  <code>24,32</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173649665.png\" alt=\"image-20230711173649665\" /></p>\n<ol start=\"4\">\n<li>添加 14</li>\n</ol>\n<p>这个也简单，直接添加到 12 的右边，变成  <code>12,14</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173735064.png\" alt=\"image-20230711173735064\" /></p>\n<ol start=\"5\">\n<li>添加 26</li>\n</ol>\n<p>此时应该添加到  <code>24,32</code>  的中间，由于一个节点只能添加两个数据，那么就需要拆分。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711173823070.png\" alt=\"image-20230711173823070\" /></p>\n<p>为了满足 B 树特点，发现上层的  <code>16</code>  只有一个数，那么就补足它。组成  <code>16,26</code> 。</p>\n<p>因为此时  <code>24,32</code>  <strong>这个节点，不满足 BST 的排序了</strong>，24 是小于 26 的。只能 32 满足。</p>\n<p><strong>拆完上层，再拆本层</strong>：由于 24 介于  <code>16,24</code>  之间，<strong>则将它安排在 3 节点中的中间节点</strong>，  <code>24,32</code>  把 24 拆分出去了，只剩下  <code>32</code>  ，此时完全满足 B 树的特点</p>\n<ol start=\"6\">\n<li>添加 34</li>\n</ol>\n<p>此时就简单了，添加到  <code>32,34</code>  中。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174145067.png\" alt=\"image-20230711174145067\" /></p>\n<ol start=\"7\">\n<li>添加 10</li>\n</ol>\n<p>此时应该添加到  <code>12,14</code>  的左侧，但是不满足条件：一个节点最多只能装 2 个数据。</p>\n<p>放到  <code>12,14</code>  的左节点，也不满足条件：所有叶子节点必须在同一层，也不满足 2-3 树 节点的 数量要求。</p>\n<p>那么此时就需要拆分，先看它们上层  <code>16,26</code>  是满 的，如何做呢？看下图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174344071.png\" alt=\"image-20230711174344071\" /></p>\n<p>左侧的拆分图，上面我们分析过了，不满足 B 树要求，那么就需要拆分成右图这样：</p>\n<ul>\n<li></li>\n</ul>\n<ol>\n<li>\n<p>将  <code>12,14</code>  中的 14 拆分成 右子节点 ，10 挂在 左节点。</p>\n</li>\n<li>\n<p>此时不满足 B 树要求的，则将  <code>16,26</code>  中的 26 拆分成 右子节点。</p>\n</li>\n<li>\n<p><code>24</code>  这个节点由于上层被拆分了，不满足在中间节点了。调整它的位置</p>\n</li>\n<li>\n<p>原来的  <code>32,34</code>  节点调整为  <code>16</code>  的有节点。</p>\n</li>\n<li>\n<p>添加 8</p>\n<p>此时很简单，组成  <code>8,10</code>  即可</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174809201.png\" alt=\"image-20230711174809201\" /></p>\n</li>\n<li>\n<p>添加 28</p>\n</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711174827823.png\" alt=\"image-20230711174827823\" /></p>\n<p>这里有个小问题，此时 28 不是应该加在  <code>26,28</code>  吗？难道说还有一个规则？</p>\n<ul>\n<li><strong>只有一个数据的节点</strong>，下面只允许 <strong>最多右 2 个节点，要么没有</strong></li>\n<li><strong>有 2 个数据的节点</strong>，下面只允许 <strong>最多 3 个节点，要么没有</strong></li>\n</ul>\n<ol start=\"10\">\n<li>添加 38</li>\n</ol>\n<p>此时就简单，直接组成  <code>34,38</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711175119632.png\" alt=\"image-20230711175119632\" /></p>\n<ol start=\"11\">\n<li>添加 20</li>\n</ol>\n<p>这个也简单，直接组成  <code>20,24</code></p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711175153140.png\" alt=\"image-20230711175153140\" /></p>\n<h5 id=\"2-3树添加规则总结\"><a class=\"anchor\" href=\"#2-3树添加规则总结\">#</a> 2-3 树添加规则总结</h5>\n<p>满足如下特点：</p>\n<ol>\n<li>\n<p>所有  <mark>叶子节点</mark>  都在同一层</p>\n<p>只要是 B 树都满足这个条件，就是<mark>满树</mark>。</p>\n</li>\n<li>\n<p>有两个子节点的节点 叫  <mark>二节点</mark></p>\n<p>二节点要么  <mark>没有子节点</mark> ，要么  <mark>必须有两个子节点</mark>。</p>\n</li>\n<li>\n<p>有三个子节点的节点叫  <mark>三节点</mark></p>\n<p>三节点要么  <mark>没有子节点</mark>，要么  <mark>必须有三个子节点</mark>。</p>\n</li>\n<li>\n<p>2-3 树 是由 <mark>二节点</mark>  和  <mark>三节点</mark> 构成的树</p>\n</li>\n<li>\n<p>构建的树，要满足二叉排序树（BST）的顺序。</p>\n</li>\n<li>\n<p><mark>一个节点中，最多只允许放 2  个数据</mark>。</p>\n</li>\n<li>\n<p><mark>只有一个数据的节点</mark>，下面只允许 <mark>最多有 2 个节点，要么没有</mark></p>\n</li>\n<li>\n<p><mark>有 2 个数据的节点</mark>，下面只允许 <mark>最多有 3 个节点，要么没有</mark></p>\n</li>\n</ol>\n<p>其它说明</p>\n<p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。如图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711190603750.png\" alt=\"image-20230711190603750\" /></p>\n<h3 id=\"b树b-树b树\"><a class=\"anchor\" href=\"#b树b-树b树\">#</a> B 树，B+ 树，B <code>*</code>  树</h3>\n<h4 id=\"b树的介绍\"><a class=\"anchor\" href=\"#b树的介绍\">#</a> B 树的介绍</h4>\n<p><strong>B-tree</strong> 树即 <mark>B 树</mark>，<strong>B</strong> 即<mark> Balanced</mark>，平衡的意思。有人把 B-tree 翻译成 B - 树，容易让人产生<mark>误解</mark>。会以为 B - 树是一种树，而 B 树又是另一种树。实际上，<mark>B-tree 就是指的 B 树</mark>。</p>\n<p>前面已经介绍了 2-3 树 和 2-3-4 树，它们就是 B 树 (英语: B-tree 也写成 B - 树)，这里我们再做一个说明，我们在学习 MySQL 时，经常听到说某种类型的索引是基于 B 树或者 B + 树的，如图：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711191024778.png\" alt=\"image-20230711191024778\" /></p>\n<p><strong>B 树的说明</strong>:</p>\n<ol>\n<li>B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>\n<li>B - 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>\n<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据.</li>\n<li>搜索有可能在非叶子结点结束</li>\n<li>其搜索性能等价于在关键字全集内做一次二分查找</li>\n</ol>\n<h4 id=\"b树的介绍-2\"><a class=\"anchor\" href=\"#b树的介绍-2\">#</a> B + 树的介绍</h4>\n<p>B + 树是 B 树的变体，也是一种多路搜索树。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711194503904.png\" alt=\"image-20230711194503904\" /></p>\n<p><strong>B + 树的说明</strong>:</p>\n<ol>\n<li>B + 树的搜索与 B 树也基本相同，区别是 B + 树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>\n<li>所有<strong>关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字 (数据) 恰好是有序的。</li>\n<li>不可能在非叶子结点命中</li>\n<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>\n<li>更适合文件索引系统</li>\n<li>B 树和 B + 树各有自己的应用场景，不能说 B + 树<strong>完全比</strong> B 树好，反之亦然.</li>\n</ol>\n<h4 id=\"b树的介绍-3\"><a class=\"anchor\" href=\"#b树的介绍-3\">#</a> B 树的介绍</h4>\n<p>B * 树是 B + 树的变体，在 B + 树的非根和非叶子结点再增加指向兄弟的指针。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/image-20230711195028517.png\" alt=\"image-20230711195028517\" /></p>\n<p><strong>B 树的说明</strong>:</p>\n<ol>\n<li>B * 树定义了非叶子结点关键字个数至少为 (2/3)*M，即块的最低使用率为 2/3，而 B + 树的块的最低使用率为 B + 树的 1/2。</li>\n<li>从第 1 个特点我们可以看出，B * 树分配新结点的概率比 B + 树要低，空间使用率更高</li>\n</ol>\n",
            "tags": [
                "java",
                "计算机学科",
                "数据结构与算法",
                "多路查找树"
            ]
        }
    ]
}