<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="D の Java" href="https://pigpigletsgo.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="D の Java" href="https://pigpigletsgo.github.io/atom.xml"><link rel="alternate" type="application/json" title="D の Java" href="https://pigpigletsgo.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="计算机学科,springcloud"><link rel="canonical" href="https://pigpigletsgo.github.io/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E7%BA%A7%E7%AF%87/"><title>SpringCloud 高级篇 - springcloud - 高级 - springcloud - spring - java - 计算机学科 | D & PersonalBlog = D の Java = 别怕路长梦远</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">SpringCloud 高级篇</h1><div class="meta"><span class="item" title="创建时间：2024-01-24 18:48:46"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-01-24T18:48:46+08:00">2024-01-24</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>81k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:14</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">D & PersonalBlog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/666b3077b407f3c0ce9c10c00b861abe.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/560306a4274d1fc26eb475dd52237387.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/5da180f23a92b4141ea87338ac84c765.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/560306a4274d1fc26eb475dd52237387.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/5651daf17bf5de77514e658264d7cccc.jpg"></li><li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a8d0ac76b87f7593653e29559d61b32d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机学科"><span itemprop="name">计算机学科</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/" itemprop="item" rel="index" title="分类于 java"><span itemprop="name">java</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/spring/" itemprop="item" rel="index" title="分类于 spring"><span itemprop="name">spring</span></a><meta itemprop="position" content="3"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/spring/springcloud/" itemprop="item" rel="index" title="分类于 springcloud"><span itemprop="name">springcloud</span></a><meta itemprop="position" content="4"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/" itemprop="item" rel="index" title="分类于 springcloud - 高级"><span itemprop="name">springcloud - 高级</span></a><meta itemprop="position" content="5"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pigpigletsgo.github.io/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E7%BA%A7%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="D"><meta itemprop="description" content="别怕路长梦远, 欢迎来我的博客空间"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="D の Java"></span><div class="body md" itemprop="articleBody"><h1 id="一-微服务保护"><a class="anchor" href="#一-微服务保护">#</a> 一、微服务保护🎄</h1><ul><li>Sentinel</li></ul><p>学习内容：</p><ul><li>初始 Sentinel</li><li>流量控制</li><li>隔离和降级</li><li>授权规则</li><li>规则持久化</li></ul><h2 id="11-初始sentinel"><a class="anchor" href="#11-初始sentinel">#</a> 1.1、初始 Sentinel🌳</h2><ul><li>雪崩问题及解决方案</li><li>服务保护技术对比</li><li>Sentinel 介绍和安装</li><li>微服务整合 Sentinel</li></ul><h3 id="111-雪崩问题"><a class="anchor" href="#111-雪崩问题">#</a> 1.1.1、雪崩问题🌲</h3><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</p><p><strong>场景</strong>：</p><p>比方说在服务 A 内部依赖于服务 B，而服务 A 内部可能还有一些其它的业务比如说它依赖于服务 C 或者是依赖于服务 D</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161531964.png" alt="image-20231016153100257"></p><p>现在假设说服务 D 出现了故障，那服务 A 内部依赖与服务 D 的业务请求就不能正常访问了</p><p>因为服务 A 访问服务 D 就必然要等待服务 D 的响应结果，而因为服务 D 出现了故障不可能返回结果它会阻塞，那就导致了服务 A 内部业务也会阻塞，阻塞 它就不会释放 tomcat 的链接。当然其它业务请求不受影响还可以正常工作。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161532119.png" alt="image-20231016153207881"></p><p>但是既然有第一个依赖于服务 D 这样的请求，那一定还会有第二个甚至第三个。这样依赖于服务 D 的业务请求越来越多，而它们都不会释放连接，那么时久一定会把服务 A 内部所有的链接都给占用了</p><p>也就是说 tomcat 资源耗尽了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161537530.png" alt="image-20231016153714784"></p><p>此时再有服务进来哪怕不是依赖于服务 D 的而是服务 B 的，是不是也进不来了。那就可以认为服务 A 也出现了故障</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161539417.png" alt="image-20231016153923278"></p><p>这就造成了一个服务的故障导致了依赖于它的服务最终也出现了故障。在微服务里这种调用关系可不止这么简单</p><p>那么服务 A 依赖于服务 D 导致最后给服务 D 拖垮了，那肯定还会有其它的服务也依赖于服务 D，最终也会被拖垮，将来其它依赖于服务 A 的也会出现故障，最终故障的服务越来越多那么整个微服务群就不可用了。</p><p>这不就是雪崩了吗！</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161541181.png" alt="image-20231016154142767"></p><h3 id="112-解决雪崩问题"><a class="anchor" href="#112-解决雪崩问题">#</a> 1.1.2、解决雪崩问题🌲</h3><p><strong>解决雪崩问题的常见方式有四种</strong>：</p><p>1、<mark>超时处理</mark>：设定超时时间，请求超过一定时间没有响应结果就返回错误信息，不会无休止等待</p><p>会在调用业务时加上一个超时时间比如说 1 秒钟，当服务 A 依赖于服务 C 时请求最多等待 1 秒钟，如果请求超过 1 秒钟就会立即结束这个请求，不再等待，返回给用户提示信息 (不好意思失败了)</p><p>缺点：只能起到缓解作用，不能解决根本问题，因为请求速度大于等待时间就会出现问题</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161546216.png" alt="image-20231016154632246"></p><p>2、<mark>舱壁模式</mark>：限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p><p>舱壁模式是来自于现实生活中的船舱的设计，一些大型的轮船它都会把船体利用隔板分隔成独立的小的空间这样的隔板就叫做舱壁。因为这些空间之间是相互隔离的，假设说船体的某个部位撞上了冰山漏水了。那么最多只是把部分船舱填满水，因为是隔离的所以其它船舱不受影响。这样就提高了整艘船的容灾能力</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161550959.png" alt="image-20231016155024959"></p><p>这种模式延续到程序设计里边是怎么做的呢？</p><p>这是服务 A 里面的资源也就是 tomcat 就可以看做成整艘船。我们可以把 tomcat 里面的资源 (线程) 划分成一个一个独立的线程池。给每个业务分配一个线程池。现在业务 1 进来后它依赖于服务 B，它最多使用十个限制，访问业务 2 比方说它依赖于服务 C，它也最多使用十线程。</p><p>现在假设说服务 C 出现故障了，这个业务 2 就会阻塞占用线程，但是它最多占用十个，这时它能够使用 tomcat 的资源是有限的，这样就把故障隔离到十个线程内了，因此也叫线程隔离。因此就避免了整个 tomcat 被耗尽的情况</p><p>缺点：资源有一定的浪费，比如说服务 C 真的宕机了，现在每次请求来还让它尝试着去访问一下服务 C 还要占用十个线程也是一种浪费</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161558553.png" alt="image-20231016155848381"></p><p>3、<mark>熔断降级</mark>：由<mark>断路器</mark>统计业务执行的异常比例，如果超出阈值则会<mark>熔断</mark>该业务，拦截访问该业务的一切请求。</p><p>统计服务 A 里面的业务，比方说服务 A 里第一次业务访问是正常的，结果后面两次都出现了故障。这时断路器就会统计比例，三个请求一个正常两个故障，故障比例高达 60%。假设说阈值是 50% 超出了阈值，此时就会出现熔断。</p><p>一旦被熔断如果在服务 A 内部还想要访问服务 D 的业务就无法再去访问服务 D 了，只要是访问服务 D 的业务就会被拦截</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161606208.png" alt="image-20231016160627109"></p><p>4、<mark>流量控制</mark>：限制业务访问 QPS，避免服务因流量的突增而故障。</p><p>QPS：每秒钟处理的请求数量</p><p>比方说有一个微服务，它能承受的最大 QPS 为 2，也就是每秒钟最多处理两个请求。</p><p>但是现在有无数个请求涌过来，就会出现故障，一旦这个服务出现故障，而依赖于这个服务的其它服务也就跟着出现故障就会出现雪崩问题</p><p>所以我们要避免服务因为流量过高而引起故障，这时就需要用到 Sentinel 了</p><p>现在假设说有无数个请求过来而 Sentinel 可以按照这个服务所能够承受的频率去释放请求，这时微服务就能从容应对这些请求了就避免了出现故障</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161613445.png" alt="image-20231016161314587"></p><p>流量控制是预防雪崩，前面三种是已经有服务故障了我怎么样去避免这个故障传递给其它服务</p><p>但是也不能说，那我就只用 流量控制呗，其它的我就不用了，这样显然是不对的。</p><p>因为高并发引起的服务故障只是故障的原因之一，往往服务还会因为其它问题而出现故障。比方说网络问题或者说 fgc 引起的假死问题，这时我们就需要用到其它的解决方案了</p><blockquote><p><strong>总结</strong>：</p><p>什么是雪崩问题？</p><ul><li>微服务之间相互调用，因为调用链中一个服务故障，引起整个链路都无法访问的情况</li></ul><p>如何避免因瞬间高并发流量而导致服务故障？</p><ul><li>流量控制</li></ul><p>如何避免因服务故障引起的雪崩问题？</p><ul><li>超时处理</li><li>线程隔离</li><li>降级熔断</li></ul></blockquote><h3 id="113-服务保护技术对比"><a class="anchor" href="#113-服务保护技术对比">#</a> 1.1.3、服务保护技术对比🌲</h3><table><thead><tr><th></th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离 / 信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比例</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口 (基于 RxJava)</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动，匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则，查看秒级监控，机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet，Spring Cloud，Dubbo，gRPC 等</td><td>Servlet，Spring Cloud Netflix</td></tr></tbody></table><h2 id="12-认识sentinel"><a class="anchor" href="#12-认识sentinel">#</a> 1.2、认识 Sentinel🌳</h2><p>Sentinel 是阿里巴巴开源的一款微服务流量控制组件。官网地址：<span class="exturl" data-url="aHR0cHM6Ly9zZW50aW5lbGd1YXJkLmlvL3poLWNuLw==">https://sentinelguard.io/zh-cn/</span></p><p><strong>Sentinel 具有以下特征</strong>：</p><p>1、<mark>丰富的应用场景</mark>：Sentinel 承接了阿里巴巴进 10 年的双十一大促流量的核心场景，例如秒杀 (即突发流量控制在系统容量可以承受的范围)，消息削峰添谷，集群流量控制，实时熔断下游不可用应用等。</p><p>2、<mark>完备的实时监控</mark>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台集群秒级数据，甚至 500 台以下规模的集群的汇总运行情况</p><p>3、<mark>广泛的开源生态</mark>：Sentinel 提供开箱即用的与其它开源框架 / 库的整合模块，例如与 Spring cloud，Dubbo，gRPC 的整合。您只需要引入相应的依赖并运行简单的配置即可快速的接入 Sentinel</p><p>4、<mark>完善的 SPI 扩展点</mark>：Sentinel 提供简单易用，完善的 SPI 扩展接口。您可以通过实现扩展接口来快速的定制逻辑。例如定制规则管理，适配动态数据源等。</p><h3 id="121-安装sentinel控制台"><a class="anchor" href="#121-安装sentinel控制台">#</a> 1.2.1、安装 Sentinel 控制台🌲</h3><p>sentinel 官方提供了 UI 控制台，方便我们对系统做限流设置。大家可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvU2VudGluZWw="> Github</span> 下载。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161747500.png" alt="image-20231016174714403"></p><p>1、将其拷贝到一个非中文目录，然后运行命令</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">java</span> <span class="token parameter variable">-jar</span> sentinel-dashboard-1.8.6.jar</pre></td></tr></table></figure><p>2、然后访问：localhost:8080 即可看到控制台页面，默认的账号和密码都是 sentinel</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161747766.png" alt="image-20231016174746831"></p><h2 id="13-安装sentinel控制台"><a class="anchor" href="#13-安装sentinel控制台">#</a> 1.3、安装 Sentinel 控制台🌳</h2><p>如果要修改 Sentinel 的默认端口，账号，密码，可以通过下列配置：</p><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>但是它已经是一个 jar 包了怎么改它的配置文件呢？</p><p>修改配置方式：</p><blockquote><p>举例说明：</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>sentinel-dashboard-1.8.6.jar <span class="token parameter variable">-Dserver.port</span><span class="token operator">=</span><span class="token number">8090</span></pre></td></tr></table></figure></blockquote><h2 id="14-微服务与sentinel整合"><a class="anchor" href="#14-微服务与sentinel整合">#</a> 1.4、微服务与 Sentinel 整合🌳</h2><h3 id="141-引入cloud-demo"><a class="anchor" href="#141-引入cloud-demo">#</a> 1.4.1、引入 cloud-demo🌲</h3><p>要使用 Sentinel 肯定要结合微服务，这里我们使用 SpringCloud 工程，项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZG91a2FpeGluL3R5cG9yYS5naXQ=">https://gitee.com/doukaixin/typora.git</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161754232.png" alt="image-20231016175423216"></p><p>项目结构如下：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161755797.png" alt="image-20231016175537988"></p><p>启动项目进行测试看看是否还可以正常使用：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161939226.png" alt="image-20231016193950393"></p><p>访问页面</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161939102.png" alt="image-20231016193935669"></p><p>一切正常后我们就开始整合</p><h3 id="142-微服务整合sentinel"><a class="anchor" href="#142-微服务整合sentinel">#</a> 1.4.2、微服务整合 Sentinel🌲</h3><p>我们在 order-service 中整合 Sentinel，并且链接 Sentinel 的控制台，步骤如下：</p><p>1、引入 Sentinel 依赖：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-sentinel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>2、配置控制台地址</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">sentinel</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token key atrule">transport</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token key atrule">dashboard</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8080</span></pre></td></tr></table></figure><p>3、访问微服务的任意端点，触发 Sentinel 监控</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310161955434.png" alt="image-20231016195535390"></p><h2 id="15-限流规则"><a class="anchor" href="#15-限流规则">#</a> 1.5、限流规则🌳</h2><ul><li>快速入门</li><li>流控模式</li><li>流控效果</li><li>热点参数限流</li></ul><h3 id="151-蔟点链路"><a class="anchor" href="#151-蔟点链路">#</a> 1.5.1、蔟点链路🌲</h3><p>蔟点链路：就是项目内的调用链路，链路中<mark>被监控</mark>的每个接口就是一个资源。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点 (Endpoint)，因此 SpringMVC 的每一个端点 (Endpoint)，就是调用链路中的一个资源。</p><p>流控，熔断等都是<mark>针对蔟点链路中的资源</mark>来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162003730.png" alt="image-20231016200306361"></p><p>点击资源 /order/{orderId} 后面的流控按钮，就可以弹出表单。表单中可以添加流控规则，如下图所示：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162009637.png" alt="image-20231016200951539"></p><p>其含义是限制 /order/{orderId} 这个资源的单击 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p><p>针对来源中 defalt 表示一切请求都限流</p><h4 id="1511-案例流控规则入门案例"><a class="anchor" href="#1511-案例流控规则入门案例">#</a> 1.5.1.1、案例，流控规则入门案例🌴</h4><p><strong>需求</strong>：给 /order/{orderId} 这个资源设置流控规则，QPS 不能超过 5。然后利用 jmeter 测试。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162014028.png" alt="image-20231016201450102"></p><p>这里使用 jemeter 进行并发的测试工具安装文章：<a href="../Jmeter/Jmeter%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.md">jmeter 安装及使用</a>.</p><p>测试文件文章地址：<a href="../%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/sentinel%E6%B5%8B%E8%AF%95.jmx">sentinel 测试.jmx</a>.</p><p>导入到 jmeter 中</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162035976.png" alt="image-20231016203528848"></p><p>如果点击没有反应就直接将 jmx 文件拖到蓝瓶子里面就算导入了</p><p>右键，流控入门，点击启动，之后可以点击查看结果树来查看请求的情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162036099.png" alt="image-20231016203617798"></p><p>这是设置 QPS 后的请求情况，没有限流的时候全是通过的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162037652.png" alt="image-20231016203706692"></p><p>查看控制台的情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162032402.png" alt="image-20231016203257242"></p><h3 id="152-流控模式"><a class="anchor" href="#152-流控模式">#</a> 1.5.2、流控模式🌲</h3><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li><p>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</p></li><li><p>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>两个资源，A 触发了阈值，但我却对 B 做了限流</p></li><li><p>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</p></li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162041214.png" alt="image-20231016204109075"></p><h4 id="1521-流控模式-关联"><a class="anchor" href="#1521-流控模式-关联">#</a> 1.5.2.1、流控模式 - 关联🌴</h4><ul><li>关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li><li>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162047957.png" alt="image-20231016204748747"></p><p>当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源。</p><h5 id="15211-案例流控模式-关联"><a class="anchor" href="#15211-案例流控模式-关联">#</a> 1.5.2.1.1、案例，流控模式 - 关联🎋</h5><p>需求：</p><ul><li>在 OrderController 新建两个端点：/order/query 和 /order/update，无需实现业务</li><li>配置流控规则，当 /order/update 资源被访问的 QPS 超过 5 个时，对 /order/query 请求限流</li></ul><p>重启服务后蔟点链路里面就会被清空了，我们需要重新去请求一下</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162054136.png" alt="image-20231016205436554"></p><p>分别请求一下 query 和 update 的接口</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162055490.png" alt="image-20231016205532378"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162055118.png" alt="image-20231016205543133"></p><p>再去查看蔟点链路就可以看到有信息了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162056790.png" alt="image-20231016205631141"></p><p>配置流控规则，当 /order/update 资源被访问的 QPS 超过 5 个时，对 /order/query 请求限流。</p><p>我们要对谁进行限流就对谁进行流控规则</p><p>点击 query 的流控</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162058104.png" alt="image-20231016205856014"></p><p>通过 jmeter 进行测试：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162101233.png" alt="image-20231016210113073"></p><p>请求的地址就是 /order/update</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162101101.png" alt="image-20231016210145527"></p><p>可以看到这个请求不会受到任何影响</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162102511.png" alt="image-20231016210228553"></p><p>但，当访问 /order/query 时</p><p>就发生了异常，update 触发阈值时对 query 限流就实现了这样一种关联模式了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162103557.png" alt="image-20231016210318424"></p><blockquote><p><strong>小结</strong>：</p><p>满足下面条件可以使用关联模式：</p><ul><li>两个有竞争关系的资源</li><li>一个优先级较高，一个优先级较低</li></ul></blockquote><h4 id="1523-流控模式-链路"><a class="anchor" href="#1523-流控模式-链路">#</a> 1.5.2.3、流控模式 - 链路🌴</h4><p>链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p><p>例如：有两条请求链路一个是从 test1 访问 common 资源另一个是从 test2 访问 common 资源：</p><ul><li>/test1 -&gt; /common</li><li>/test2 -&gt; /common</li></ul><p>如果希望统计从 /test2 进入到 /common 的请求，则可以这样配置：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162107107.png" alt="image-20231016210716025"></p><p>这个配置的意思：</p><p>在做限流统计时，只统计从 test2 进入 common 的请求，test1 进来的不管。所以这种统计是对请求来源的一种统计</p><p>什么情况下我们会用到这样的模式呢？通过如下案例了解</p><h5 id="15231-案例流控模式-链路"><a class="anchor" href="#15231-案例流控模式-链路">#</a> 1.5.2.3.1、案例，流控模式 - 链路🎋</h5><p>需求：有查询订单和创建订单业务，两者需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p><p>步骤：</p><p>1、在 OrderService 中添加一个 queryGoods 方法，不用实现业务</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Service</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span><span class="token string">"goods"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">queryGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2、在 OrderController 中，改造 /order/query 端点，调用 OrderService 中的 queryGoods 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">queryOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 查询商品</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   orderService<span class="token punctuation">.</span><span class="token function">queryGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token comment">// 查询订单</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询订单"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">return</span> <span class="token string">"查询订单成功"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>3、在 OrderController 中添加一个 /order/save 的端点，调用 OrderService 的 queryGoods 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">saveOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   orderService<span class="token punctuation">.</span><span class="token function">queryGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新增订单"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">return</span> <span class="token string">"新增订单成功"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>4、给 queryGoods 设置限流规则，从 /order/query 进入 queryGoods 的方法限制 QPS 必须小于 2</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170741307.png" alt="image-20231017074152072"></p><ul><li><p>Sentinel 默认只标记 Controller 中的方法为资源，如果要标记其它方法，需要利用 @SentinelResource 注解，示例：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span><span class="token string">"goods"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">queryGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li><li><p>Sentinel 默认会将 Controller 方法做 context 整合，导致链路模式的流控失败，需要修改 application.yml，添加配置：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">sentinel</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token key atrule">transport</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token key atrule">dashboard</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8080</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token key atrule">web-context-unify</span><span class="token punctuation">:</span> false // 关闭context整合</pre></td></tr></table></figure></li></ul><p>访问 order/query 和 order/save</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162148402.png" alt="image-20231016214825324"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162148432.png" alt="image-20231016214834464"></p><p>查看 sentinel 的蔟点链路信息</p><p>可以看到 /order/query 与 /order/save 变成了两个独立的链路了，在之前没有关闭 context 整合时它俩是同一个跟链路下的子链路</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310162149544.png" alt="image-20231016214905203"></p><p>现在我们就可以对 goods 添加流控规则了，也就是上面的第 4 步</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170741307.png" alt=""></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170755887.png" alt="image-20231017075526647"></p><p>使用 jmeter 进行测试</p><p>发起 200 个请求每秒发起 4 个 ，而且同时发起两个请求</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170802306.png" alt="image-20231017080217215"></p><p>可以看到请求 save 没问题</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170806261.png" alt="image-20231017080631501"></p><p>可以看到请求 query 时是两个两个的。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170806763.png" alt="image-20231017080641204"></p><blockquote><p><strong>总结</strong>：</p><p>流控模式有哪些？</p><ul><li>直接：对当前资源限流</li><li>关联：高优先级资源触发阈值，对低优先级资源限流</li><li>链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</li></ul></blockquote><h4 id="1524-流控效果"><a class="anchor" href="#1524-流控效果">#</a> 1.5.2.4、流控效果🌲</h4><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常。是默认的处理方式。</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的剪个不能小于指定时长</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170813160.png" alt="image-20231017081328807"></p><h5 id="15241-流控效果-warm-up"><a class="anchor" href="#15241-流控效果-warm-up">#</a> 1.5.2.4.1、流控效果 - warm up🌴</h5><p>warm up 也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是 threshold 除以 coldFactor，持续指定时长后，逐渐提高到 threshold 值。而 clodFactor 的默认值是 3.</p><p>例如，我设置 QPS 的 threshold 为 10，预热时间为 5 秒，那么初始阈值就是 10 / 3，也就是 3，然后在 5 秒后逐渐增长到 10</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170818338.png" alt="image-20231017081845114"></p><h6 id="152411-案例流控效果-warm-up"><a class="anchor" href="#152411-案例流控效果-warm-up">#</a> 1.5.2.4.1.1、案例，流控效果 - warm up🎋</h6><p>需求：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用 warm up 效果，预热时长为 5 秒</p><p>请求一下通过 id 查询的 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDg4L29yZGVyLzEwMQ==">http://localhost:8088/order/101</span></p><p>然后回到 Sentinel 刷新页面，就可以看到 orderId 了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170823021.png" alt="image-20231017082330841"></p><p>给 orderId 添加一个流控规则</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170827278.png" alt="image-20231017082705193"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170827270.png" alt="image-20231017082714223"></p><p>使用 jmeter 进行测试：</p><p>可以看到通过的 QPS 越来越多</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170829082.png" alt="image-20231017082949095"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170830693.png" alt="image-20231017083005138"></p><h5 id="15242-流控效果-排队等待"><a class="anchor" href="#15242-流控效果-排队等待">#</a> 1.5.2.4.2、流控效果 - 排队等待🌴</h5><p>当请求超过 QPS 阈值时，快速失败和 warm up 会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成。如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>例如：QPS=5，意味着每 200ms 处理一个队列中的请求；timeout=2000，意味着预期等待超过 2000ms 的请求会被拒绝并抛出异常</p><p>比如下面的时间线，有无数个请求要进入队列执行，那第一个进入队列的请求它的等待时间一定是 0ms。但是同一时刻又来了一个请求那么第二个请求它一定要等待至少 200ms，所以它的预期等待时间就是 2 秒，后面的请求以此类推。直到等到时间最多为 2000ms 时，再来一个请求它的等待时间就是超出这 2000ms 的时间了，而超出的请求就会被拒绝</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170838123.png" alt="image-20231017083846925"></p><p>好处：假设说请求 QPS 是波动型的，比如说第一秒钟一个请求也没来，这时队列是空的。结果第二秒一下来了 10 个请求，放到队列里然后每 200ms 放行一个换算成 QPS 就是 5，所以不管进入的 QPS 是怎样波动的出去的 QPS 一定是稳定的按照 200ms 一个的速度去放。所以就起到了流量整形的作用</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170854889.png" alt="image-20231017085359679"></p><h6 id="152421-案例流控效果-排队等待"><a class="anchor" href="#152421-案例流控效果-排队等待">#</a> 1.5.2.4.2.1、案例，流控效果 - 排队等待🎋</h6><p>需求：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队的流控效果，超时时长设置为 5ss</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170859614.png" alt="image-20231017085932633"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170901195.png" alt="image-20231017090152352"></p><p>使用 jmeter 进行测试：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170908478.png" alt="image-20231017090853567"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170909192.png" alt="image-20231017090906285"></p><blockquote><p><strong>总结</strong>：</p><p>流控效果有哪些？</p><ul><li>快速失败：QPS 超过阈值时，拒绝新的请求</li><li>warm up：QPS 超过阈值时，拒绝新的请求；QPS 阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。</li><li>排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</li></ul></blockquote><h3 id="153-热点参数限流"><a class="anchor" href="#153-热点参数限流">#</a> 1.5.3、热点参数限流🌲</h3><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而热点参数限流是分别统计<mark>参数值相同</mark>的请求，判读是否超过 QPS 阈值。</p><p>比如说：有一个资源是根据 id 查询商品，共有 4 个请求。如果按照原来的统计方式那 QPS 就是 4。而按照热点参数它会根据参数值来判断，前三个请求传递的 id 为 1，而最后一个传递的 id 为 2。所以 QPS 统计就会分开统计了，id 为 1 的统计为 3 个 QPS 就为 3，id 为 2 的统计为 1 个 QPS 就为 1</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170919488.png" alt="image-20231017091910421"></p><h4 id="1531-配置热点限流"><a class="anchor" href="#1531-配置热点限流">#</a> 1.5.3.1、配置热点限流🌴</h4><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170920122.png" alt="image-20231017092015196"></p><p>参数索引：代表当前列表中索引为 0 的参数也就是第一个</p><p>单机阈值 + 统计窗口时长 = n 秒钟最多处理 5 个请求</p><p>代表的含义是：对 hot 这个资源的 0 号参数 (第一个参数) 做统计，每 1 秒<strong>相同参数值</strong>的请求数不能超过 5</p><h4 id="1532-配置热点限流高级项"><a class="anchor" href="#1532-配置热点限流高级项">#</a> 1.5.3.2、配置热点限流高级项🌴</h4><p>在热点参数限流的高级选项中，可以对部分参数设置例外配置：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310170924654.png" alt="image-20231017092441509"></p><p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 秒相同参数的 QPS 不能超过 5，有两个例外：</p><p>1、如果参数值是 100，则每 1 秒允许的 QPS 为 10</p><p>2、如果参数值是 101，则每 1 秒允许的 QPS 为 15</p><h4 id="1533-案例热点参数限流"><a class="anchor" href="#1533-案例热点参数限流">#</a> 1.5.3.3、案例，热点参数限流🌴</h4><p>给 /order/{orderId} 这个资源添加热点参数限流，规则如下：</p><ul><li>默认的热点参数规则是每 1 秒请求量不超过 2</li><li>给 102 这个参数设置例外：每 1 秒请求量不超过 4</li><li>给 103 这个参数设置例外：每 1 秒请求量不超过 10</li></ul><blockquote><p>&lt;font color='red'&gt; 注意 &lt;/font&gt;：</p><p>热点参数限流对默认的 SpringMVC 资源无效</p></blockquote><p>步骤：</p><p>1、热点参数限流对默认的 SpringMVC 资源无效，我们 order/{orderId} 这个资源恰好就是 Sentinel 默认对 SpringMVC 监控的一个资源，所以即便配置了热点参数也不会生效，只有通过 @SentinelResource 去声明的资源才可以配置热点参数限流</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span><span class="token string">"hot"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"&#123;orderId&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderByUserId</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"orderId"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 根据 id 查询订单并返回</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">queryOrderById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这时资源就同时具备了两个名称了，一个是 order/{orderId} 这是默认的 SpringMVC 资源名称。</p><p>另外一个就是我们自己起的 hot</p><p>重启 orderService 服务后访问页面 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDg4L29yZGVyLzEwMQ==">http://localhost:8088/order/101</span></p><p>这样就可以看到蔟点链路了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171009407.png" alt="image-20231017100944355"></p><p>2、配置热点限流，不要点击树形列表中的热点这个表单里面没有高级配置</p><p>我们点击左边的选项栏中的热点规则，进行配置</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171011792.png" alt="image-20231017101141197"></p><p>点击新增热点限流规则就会弹出一个表单进行配置</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171015751.png" alt="image-20231017101511501"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171017813.gif" alt="test"></p><p>使用 jmeter 进行测试：</p><p>order/101 的请求结果</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171021326.png" alt="image-20231017102157624"></p><p>order/102 请求的结果</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171022007.png" alt="image-20231017102216489"></p><p>order/103 请求结果</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171022759.png" alt="image-20231017102239351"></p><p>Sentinel 的控制台情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171022389.png" alt="image-20231017102256408"></p><h2 id="16-隔离和降级"><a class="anchor" href="#16-隔离和降级">#</a> 1.6、隔离和降级🌳</h2><ul><li>FeignClient 整合 Sentinel</li><li>线程隔离 (舱壁模式)</li><li>熔断降级</li></ul><p><strong>回顾，隔离和降级的原理</strong></p><p>虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离 (舱壁模式) 和熔断降级手段了。</p><p>给每个业务划分线程池，当有请求访问业务 1 时最多使用十个线程，虽然服务 C 故障了请求过程中会阻塞但是最多只占用 10 个线程资源</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171031862.png" alt="image-20231017103151291"></p><p>熔断降级会统计故障服务的比例，比如说服务 A 访问服务 D 成功的只有一个，故障的有两个这时的比例就是 60%。此时 断路器就会熔断业务，再有要请求服务 D 的业务就会快速失败</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171033093.png" alt="image-20231017103347716"></p><p>不管是线程隔离还是熔断降级，都是对 &lt;font color='red'&gt; 客户端 (调用方) &lt;/font&gt;. 的保护</p><h3 id="161-feign整合sentinel"><a class="anchor" href="#161-feign整合sentinel">#</a> 1.6.1、Feign 整合 Sentinel🌲</h3><p>SpringCloud 中，微服务调用都是通过 Feign 来实现的，因此做客户端保护必须整合 Feign 和 Sentinel</p><p>1、修改 OrderService 的 applicaiton.yml 文件，开启 Feign 的 Sentinel 功能</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">feign</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token key atrule">sentinel</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启 feign 对 sentinel 的支持</span></pre></td></tr></table></figure><p>2、给 FeignClient 编写失败后的降级逻辑</p><p>2.1、方式一：FallbackClass，无法对远程调用的异常做处理</p><p>2.2、方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p><p>2.2.1、在 feign-api 项目中定义类，实现 FallbackFactory：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserClientFallbackFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserClient</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">UserClient</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 创建 UserClient 接口实现类，实现其中的方法，编写失败降级的处理逻辑</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 记录异常信息</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"查询用户异常"</span><span class="token punctuation">,</span> throwable<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 根据业务需求返回默认的数据，这里是空用户</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2.2.2、在 feign-api 项目中的 DefaultFeignConfigration 类中将 UserClientFallbackFactory 注册为一个 Bean：</p><p>声明 Bean 很简单，定义函数返回 new 出来的对象并注册 Bean 就行了</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">UserClientFallbackFactory</span> <span class="token function">userClientFallbackFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserClientFallbackFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2.2.3、在 feign-api 项目中的 UserClient 接口中使用 UserClientFallbackFactory：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userservice"</span><span class="token punctuation">,</span> fallbackFactory <span class="token operator">=</span> <span class="token class-name">UserClientFallbackFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"user/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>3、重启 orderService 服务</p><p>重复完成后查看 Sentinel 的蔟点链路情况，下面的情况说明完成了 Feign 与 Sentinel 的整合了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171304966.png" alt="image-20231017130442973"></p><blockquote><p><strong>总结</strong>：</p><p>Sentinel 支持的雪崩解决方案：</p><ul><li>线程隔离 (仓壁模式)</li><li>降级熔断</li></ul><p>Feign 整合 Sentinel 的步骤：</p><ol><li>在 application.yml 中配置：feign.sentinel.enable = true</li><li>给 FeignClient 编写 FallbackFactory 并注册为 Bean</li><li>将 FallbackFactory 配置到 FeignClient</li></ol></blockquote><h3 id="162-线程隔离"><a class="anchor" href="#162-线程隔离">#</a> 1.6.2、线程隔离🌲</h3><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离</li><li>信号量隔离 (Sentinel 默认采用)</li></ul><p>通过案例来查看两个线程隔离的差别：</p><p>假设说有四个服务 i，a，b，c 。服务 i 里面的业务依赖于服务 a，b，c。比方说来了一个请求，它的业务依赖于服务 a，b。如果说我们现在用的是线程池隔离那么它就会给这个业务所依赖的每个服务都创建线程池，请求来了以后不会使用请求本身的线程，而是去创建的线程池中分别取一个线程而用这个线程去调用 Feign 的客户端，发起远程调用。这样呢就把两个服务隔离了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171315936.png" alt="image-20231017131457045"></p><p>而如果采用的是信号量的模式就简单多了。比如说来了一个请求，要访问服务 c。它会使用请求本身的线程直接去调用 Feign 的客户端去调用服务 c。那它怎么做隔离呢？它会在请求进入时做一个判断，维持了一个计数器。判断现在计数器还有没有。比如说计数器总数为 10 每进入一个请求计数器就会减 1，然后就可以去访问服务 c 了。当来了十个请求计数器被取完后再来新请求就会被拒绝。这样就等于利用计数器限制了最终线程的数量了。如果处理完请求计数器还是要还回去的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171319389.png" alt="image-20231017131940276"></p><h4 id="1621-两者的优缺点"><a class="anchor" href="#1621-两者的优缺点">#</a> 1.6.2.1、两者的优缺点：</h4><h5 id="线程池隔离"><a class="anchor" href="#线程池隔离">#</a> 线程池隔离</h5><p><strong>优点</strong>：</p><p>1、支持主动超时</p><p>如果发现请求有点久了可以手动的终止线程</p><p>2、支持异步调用</p><p>每一次请求都是一个独立的线程而不是 tomcat 请求的线程</p><p><strong>缺点</strong>：</p><p>1、线程的额外开销比较大</p><p>场景：</p><p>1、低扇出</p><p>扇出：比方说请求到我这个服务，而我这个服务依赖于其它的 n 个服务。就是从我这来了，来了一个而后我扇出了好几个。如果依赖的服务越多，那扇出也就越高，而扇出越高调用的越多我需要开启的线程也越多，消耗也就越大。所以它不适用于高扇出的场景！</p><h5 id="信号量隔离"><a class="anchor" href="#信号量隔离">#</a> 信号量隔离</h5><p><strong>优点</strong>：</p><p>1、轻量级，无额外开销</p><p><strong>缺点</strong>：</p><p>1、不支持主动超时</p><p>2、不支持异步调用</p><p>场景：</p><p>1、高频调用</p><p>2、高扇出</p><h4 id="1622-线程隔离-舱壁模式"><a class="anchor" href="#1622-线程隔离-舱壁模式">#</a> 1.6.2.2、线程隔离 (舱壁模式)🌴</h4><p>在添加限流规则时，可以选择两种阈值类型：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171332558.png" alt="image-20231017133257502"></p><ul><li>QPS：就是每秒的请求数，在快速入门中已经演示过</li><li>线程数：是该资源能使用的 tomcat 线程数的最大值。也就是通过限制线程数量，实现 &lt;font color='red'&gt; 舱壁模式 &lt;/font&gt;.</li></ul><h5 id="16221-案例线程隔离-舱壁模式"><a class="anchor" href="#16221-案例线程隔离-舱壁模式">#</a> 1.6.2.2.1、案例，线程隔离 (舱壁模式)🎋</h5><p>需求：给 UserClient 的查询用户接口设置流控规则，线程数不能超过 2。然后利用 jmeter 测试。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171336102.png" alt="image-20231017133620881"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171336135.png" alt="image-20231017133657213"></p><p>配置完成！使用 jmeter 进行高并发测试：</p><p>其中的线程数为 10，时间为 0。表示一瞬间发 10 个线程请求。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171337544.png" alt="image-20231017133755763"></p><p>测试结果：</p><p>但是怎么没有看到被拒绝的请求呢？</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171341275.png" alt="image-20231017134110845"></p><p>其实我们做了降级策略了</p><p>在 FeignClient 注解中加了 fallbackFactory</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userservice"</span><span class="token punctuation">,</span> fallbackFactory <span class="token operator">=</span> <span class="token class-name">UserClientFallbackFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"user/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所以当线程隔离被降级以后它不是报错，而是会走这个降级逻辑返回一个空对象</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserClientFallbackFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserClient</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">UserClient</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 创建 UserClient 接口实现类，实现其中的方法，编写失败降级的处理逻辑</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 记录异常信息</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"查询用户异常"</span><span class="token punctuation">,</span> throwable<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 根据业务需求返回默认的数据，这里是空用户</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是在 idea 的控制台会打印异常的信息</p><pre><code>10-17 13:40:38:046 ERROR 1804 --- [nio-8088-exec-3] c.i.f.c.f.UserClientFallbackFactory : 查询用户异常
</code></pre><p>我们在回到 jmeter 点击请求查看详细情况，有的获取的数据是空的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171347804.png" alt="image-20231017134731646"></p><blockquote><p><strong>总结</strong>：</p><p>线程隔离的两种手段是？</p><ul><li>信号隔离</li><li>线程池隔离</li></ul><p>信号量隔离的特点是？</p><ul><li>基于计数器模式，简单，开销小</li></ul><p>线程池隔离的特点是？</p><ul><li>基于线程池模式，有额外开销，但隔离控制更强</li></ul></blockquote><h3 id="163-熔断降级"><a class="anchor" href="#163-熔断降级">#</a> 1.6.3、熔断降级🌲</h3><p>熔断降级是解决雪崩问题的重要手段。其思路是由 &lt;font color='red'&gt; 断路器 &lt;/font &gt; 统计服务调用的异常比例，慢请求比例，如果超出阈值则会 &lt; font color='red'&gt; 熔断 &lt;/font &gt; 该服务。即拦截访问该服务的一切请求；而当请求恢复时，断路器会放行访问该服务的请求。</p><p>断路器内部由一个状态机来实现的，这个状态机包含三种状态，分别是：closed，open，Half-Open</p><p>closed 状态下，断路器不会拦截任何请求。不管请求是正常的还是异常的都可以访问，它会去统计调用异常的比例，如果统计过程中发现异常比例过高达到了阈值就会从 closed 状态切换到 open 状态、这时就会拦截进入该服务的一些请求了也就相当于是熔断了。熔断有一个持续的时间，当熔断时间结束就会从 open 状态切换到 half-open 状态 (半开状态)。half-open 状态会放行一次请求，然后根据这次请求的结果来判断下一步。</p><p>比如说放行一次请求发现这个请求依赖是失败的那么就会再次进入 open 状态</p><p>如果放行一次请求执行完了发现是成功的那么就会从 half-open 切换到 closed 状态</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171422210.png" alt="image-20231017142215093"></p><p>我们知道断路器要想从 closed 状态进入到 open 状态需要判断服务有没有触发熔断的条件。而熔断判断的条件就是依据熔断策略来完成的，而在 Sentinel 里熔断的策略有三种：慢调用，异常比例，异常数</p><h4 id="1631-熔断策略-慢调用"><a class="anchor" href="#1631-熔断策略-慢调用">#</a> 1.6.3.1、熔断策略 - 慢调用🌴</h4><p><mark>慢调用</mark>：业务的响应时长 (RT) 大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171428040.png" alt="image-20231017142805647"></p><p><strong>解读</strong>：RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5 秒。然后进入 half-open 状态，放行一次请求做测试。</p><h5 id="16311-案例熔断策略-慢调用"><a class="anchor" href="#16311-案例熔断策略-慢调用">#</a> 1.6.3.1.1、案例，熔断策略 - 慢调用🎋</h5><p>需求：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms，统计时间为 1 秒， 最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5</p><p>问题：本地调用时间不可能那么长所以为了能够触发慢调用需要修改一下业务代码让其超过响应时间</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Truth"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> truth<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token comment">// 休眠，触发熔断</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>         <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"truth: "</span> <span class="token operator">+</span> truth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>重启 userService 服务</p><p>访问 order/101 时就会去请求 userId 为 1 的用户</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171439770.png" alt="image-20231017143949635"></p><p>order/102</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171441135.png" alt="image-20231017144136736"></p><p>order/101</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171441279.png" alt="image-20231017144150302"></p><p>可以看到 102 请求时长基本不超过 10 毫秒，而 101 请求时长基本不下 70 毫秒。这样就能满足我们触发阈值的情况了</p><p>然后就可以去配置熔断降级策略了，去 Sentinel 控制台中</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171445150.png" alt="image-20231017144506913"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171445998.png" alt="image-20231017144515744"></p><p>然后我们就可以去进行测试了：</p><p>这次的测试可以不用 jmeter 了，因为需要一秒内 5 次请求，有 2 次触发就行了很容易可以去刷新 order/{orderId} 的请求页面</p><p>现在访问 order/102，是正常可以访问的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171448397.png" alt="image-20231017144804306"></p><p>连续请求 5 次 order/101，也就是刷新 5 次页面</p><p>再去访问 order/102 就会发现 user 中没有数据了，当 order 去查 user 的那一刻直接被熔断了，压根没有去查直接走降级逻辑返回 null 了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171449564.png" alt="image-20231017144859133"></p><p>等待 5 秒后再去刷新一个 order/102 页面，熔断就取消了可以请求到 user 的数据了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171451453.png" alt="image-20231017145103496"></p><h4 id="1632-熔断策略-异常比例异常数"><a class="anchor" href="#1632-熔断策略-异常比例异常数">#</a> 1.6.3.2、熔断策略 - 异常比例，异常数🌴</h4><ul><li><mark>异常比例或异常数</mark>：统计指定时间内的 调用，如果调用次数超过指定的请求数，并且出现异常的比例达到设定的比例阈值 (或超过指定异常数) ，则触发熔断。例如：</li></ul><p>按照异常的比例熔断</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171454750.png" alt="image-20231017145414614"></p><p>达到异常数量熔断</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171456985.png" alt="image-20231017145619743"></p><p><strong>解读</strong>：统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.5，则触发熔断，熔断时长为 5 秒。然后进入 half-open 状态，放行一次请求做测试。</p><h5 id="16321-案例熔断策略-异常比例"><a class="anchor" href="#16321-案例熔断策略-异常比例">#</a> 1.6.3.2.1、案例，熔断策略 - 异常比例🎋</h5><p><strong>需求</strong>：给 UserClient 的查询用户接口设置降级规则，统计时间为 1 秒，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5</p><p>&lt;font color='red'&gt; 提示 &lt;/font&gt;：为了触发异常统计，我们需要修改 UserService 中的业务，抛出异常如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">queryById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Truth"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token class-name">String</span> truth<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"故意抛出异常，触发异常比例熔断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"truth: "</span> <span class="token operator">+</span> truth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">queryById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>给 UserClient 查询用户接口设置降级规则</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171511550.png" alt="image-20231017151144666"></p><p>访问 order/102</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171512960.png" alt="image-20231017151235103"></p><p>然后连续访问 n 次 order/101</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171516133.png" alt="image-20231017151605944"></p><p>在访问 order/102 就发现被熔断了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171515798.png" alt="image-20231017151556049"></p><blockquote><p><strong>总结</strong>：</p><p>Sentinel 熔断降级的策略有哪些？</p><p>1、慢调用比例：超过指定时长的调用为慢调用，统计单位时长内慢调用的比例，超过阈值则熔断</p><p>2、异常比例：统计单位时长内异常调用的比例，超过阈值则熔断</p><p>3、异常数：统计单位时长内异常调用的次数，超过阈值则熔断</p></blockquote><h2 id="17-授权规则"><a class="anchor" href="#17-授权规则">#</a> 1.7、授权规则🌳</h2><ul><li>授权规则</li><li>自定义异常结果</li></ul><h3 id="171-授权规则"><a class="anchor" href="#171-授权规则">#</a> 1.7.1、授权规则🌲</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><blockquote><p>我们学习网关的时候讲过，gateway 它不就是把门的吗。所有请求都要经过网关去做身份的认证，怎么到这儿又要整一个呢？</p><p>万一公司出了一个内鬼，它把微服务地址泄露给了外边哪些不怀好意的人，那这些哥们就可以绕过网关直接访问微服务了。那网关里做的再严密也都没用了，所以 Sentinel 授权规则可以解决这个问题。授权规则会去验证你请求从哪来的。如果说你是从网关过来的那就放行，如果说你从别的地方来的就拦截</p></blockquote><ul><li>白名单：来源 (origin) 在白名单内的调用者允许访问</li><li>黑名单：来源 (origin) 在黑名单内的调用者不允许访问</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171530129.png" alt="image-20231017153026632"></p><p>例如，我们限定只允许从网关来的请求访问 order-service，那么流控应用中就填写网关的名称</p><p>那么这时</p><p orderid="">资源名填的就是：order-service 里面的受保护资源，比方说 order/</p><p>流控应用填的就是：允许的调用者的名字 origin，请求来源名称，那么请求来源名称是怎么得到的呢？</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171531533.png" alt="image-20231017153153844"></p><p>Sentinel 是通过 RequestOriginParser 这个接口的 parseOrigin 来获取请求的来源的。</p><p>但是这个方法的返回结果只能是 default，也就是说无论是从网关过来还是浏览器过来它的来源名称都叫 default</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RequestOriginParser</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token comment">/**</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   * 从请求 request 对象中获取 origin，获取方式自定义</pre></td></tr><tr><td data-num="4"></td><td><pre>   */</pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">String</span> <span class="token function">parseOrigin</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所以我们必须自己想办法实现这个接口编写它的业务逻辑，让从网关过来的请求和从浏览器过来的请求返回不同的结果，这样来源名称不同就可以编写授权规则了</p><p>例如，我们尝试从 reqeust 中获取一个名为 origin 的请求头，作为 origin 的值：</p><p>这里 gateway 访问消费者也就是 orderservice 服务所以下面业务代码是写到 order 服务中的</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeaderOriginParser</span> <span class="token keyword">implements</span> <span class="token class-name">RequestOriginParser</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">parseOrigin</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 1. 获取请求头</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">String</span> header <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"origin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 2. 非空判断</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            header <span class="token operator">=</span> <span class="token string">"blank"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> header<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们还需要在 gateway 服务中，利用网关的过滤器添加名为 gateway 的 origin 头</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">-</span> AddRequestHeader=origin<span class="token punctuation">,</span>gateway <span class="token comment"># 添加名为 origin 的请求头，值为 gateway</span></pre></td></tr></table></figure><p>重启 orderservice 服务和 gateway 服务</p><p>随便访问一个 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDg4L29yZGVyLzEwMQ==">http://localhost:8088/order/101</span></p><p>然后查看 Sentinel 控制台中的蔟点链路</p><p>然后我们就可以给 /order/{orderId} 配置授权规则：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171605527.png" alt="image-20231017160506456"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171605725.png" alt="image-20231017160532751"></p><p>此时我们再去访问 order/101 服务</p><p>注意：这里 order/101 是绕过了网关的</p><p>访问是不成功的。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171605535.png" alt="image-20231017160543084"></p><p>那我们使用网关进行访问的</p><p>可以正常访问</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171606887.png" alt="image-20231017160611726"></p><p>但是由于上面直接跳过网关访问 order/101 的时候就会报错，页面的报错提示如下：</p><p>说是限流异常这就不合理了，明明是授权异常怎么就限流异常了呢</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171609433.png" alt="image-20231017160543084"></p><p>所以我们可以对其进行自定义异常：</p><h3 id="172-自定义异常结果"><a class="anchor" href="#172-自定义异常结果">#</a> 1.7.2、自定义异常结果🌲</h3><p>默认情况下，发生限流，降级，授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现 BlockExceptionHanlder 接口：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BlockExcpetionHandler</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token comment">/**</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   * 处理请求被限流，降级，授权拦截时抛出的异常：BlockException</pre></td></tr><tr><td data-num="4"></td><td><pre>   */</pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">BlockExcpetion</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>而 BlockException 包含很多个子类，分别对应不同的场景：</p><table><thead><tr><th>异常</th><th>说明</th></tr></thead><tbody><tr><td>FlowException</td><td>限流异常</td></tr><tr><td>ParamFlowException</td><td>热点参数限流的异常</td></tr><tr><td>DegradeException</td><td>降级异常</td></tr><tr><td>AuthorityException</td><td>授权规则异常</td></tr><tr><td>SystemBlockException</td><td>系统规则异常</td></tr></tbody></table><p>我们在 order-service 中定义类，实现 BlockExceptionHandler 接口：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SentinelBlockHandler</span> <span class="token keyword">implements</span> <span class="token class-name">BlockExceptionHandler</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> httpServletRequest<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">BlockException</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token string">"未知异常"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">429</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">FlowException</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            msg <span class="token operator">=</span> <span class="token string">"请求被限流了 !"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">DegradeException</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            msg <span class="token operator">=</span> <span class="token string">"请求被降级了 !"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">ParamFlowException</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            msg <span class="token operator">=</span> <span class="token string">"热点参数限流 !"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">AuthorityException</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            msg <span class="token operator">=</span> <span class="token string">"请求没有权限 !"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            status <span class="token operator">=</span> <span class="token number">401</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&#123;\"message\": \""</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"\",\"status\": "</span> <span class="token operator">+</span> status <span class="token operator">+</span> <span class="token string">"&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>重启 orderservice 服务，然后访问一下 order/101。再去 Sentinel 控制台查看蔟点链路并添加授权规则：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171629649.png" alt="image-20231017162948414"></p><p>然后再对 order/101 进行直接访问</p><p>可以看到自定义异常成功了！</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171630717.png" alt="image-20231017163007309"></p><blockquote><p><strong>总结</strong>：</p><p>获取请求来源的接口是什么？</p><ul><li>RequestOriginParser</li></ul><p>处理 BlockException 的接口是什么</p><ul><li>BlockExcpetionHandler</li></ul></blockquote><h2 id="18-规则持久化"><a class="anchor" href="#18-规则持久化">#</a> 1.8、规则持久化🌳</h2><ul><li>规则管理模式</li><li>实现 push 模式</li></ul><p>Sentinel 的控制台规则管理有三种模式：</p><ul><li>原始模式：Sentinel 的默认模式，将规则保存在内存，重启服务会丢失。</li><li>pull 模式</li><li>push 模式</li></ul><h3 id="181-规则管理模式-pull模式"><a class="anchor" href="#181-规则管理模式-pull模式">#</a> 1.8.1、规则管理模式 - pull 模式🌲</h3><p>pull 模式：控制台将配置的规则推送到 Sentinel 客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171635037.png" alt="image-20231017163548813"></p><p>缺点：存在时效性问题，从而导致数据的不一致问题</p><h3 id="182-规则管理模式-push模式"><a class="anchor" href="#182-规则管理模式-push模式">#</a> 1.8.2、规则管理模式 - push 模式🌲</h3><p>push 模式：控制台将配置规则推送到远程配置中心，例如 Nacos。Sentinel 客户端监听 Nacos，获取配置变更的推送消息，完成本地配置更新</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171639844.png" alt="image-20231017163912849"></p><blockquote><p><strong>总结</strong>：</p><p>Sentinel 的三种配置管理模式是什么？</p><ul><li><p>原始模式：保存在内存</p><p>不支持持久化</p></li><li><p>pull 模式：保存在本地文件或数据库，定时去读取</p><p>定时轮询存在时效性问题，导致数据不一致</p></li><li><p>push 模式：保存在 Nacos，监听变更实时更新</p></li></ul></blockquote><h3 id="183-实现push模式"><a class="anchor" href="#183-实现push模式">#</a> 1.8.3、实现 push 模式🌲</h3><p>push 模式实现最为复杂，依赖于 Nacos，并且需要修改 Sentinel 控制台源码。</p><p>详细步骤可以参考文章<a href="../sentinel%E6%8C%81%E4%B9%85%E5%8C%96/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96.md"> sentinel 规则持久化</a>.</p><h1 id="二-分布式事务"><a class="anchor" href="#二-分布式事务">#</a> 二、分布式事务🎄</h1><ul><li>seata</li></ul><p><strong>事务的 ACID 原则</strong></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171718973.png" alt="image-20231017171810630"></p><h2 id="21-分布式服务案例"><a class="anchor" href="#21-分布式服务案例">#</a> 2.1、分布式服务案例🌳</h2><p>微服务下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务：</p><ul><li>账户服务负责扣减用户余额</li><li>库存服务负责扣减商品库存</li></ul><p>比方说以下微服务：里面包含三个服务 订单服务，账户服务，库存服务。现在有一个用户下单的业务，用户下单时我希望订单服务去创建订单并且写入数据库，而后它再去调用账户服务和库存服务。账户服务去扣减用户的余额，而库存服务则去扣减商品库存。里面就包含了三个不同的微服务调用，而每个微服务都有自己独立的数据库，也就是独立的事务。最终希望的肯定是下单业务一旦执行每一个服务都要成功，如果失败都失败。但是能不能达到这样的结果呢下面进行验证</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171720793.png" alt="image-20231017172030706"></p><h2 id="22-演示分布式事务问题"><a class="anchor" href="#22-演示分布式事务问题">#</a> 2.2、演示分布式事务问题 🌳</h2><p>在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致这样的事务就是 &lt;font color='red'&gt; 分布式事务 &lt;/font&gt;.</p><p>1、导入微服务项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZG91a2FpeGluL3R5cG9yYS5naXQ=">https://gitee.com/doukaixin/typora.git</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171737590.png" alt="image-20231017173700559"></p><p>2、创建数据库，名为 seata_demo，然后导入 SQL 文件，改 SQL 文件在 seata-demo 项目中的 SQL 文件夹中</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171737039.png" alt="image-20231017173733114"></p><p>3、启动 nacos，所有微服务</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171955624.png" alt="image-20231017195536248"></p><p>4、测试下单功能，发送 Post 请求</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171956965.png" alt="image-20231017195605740"></p><p>发送请求后查看数据库</p><p>账户表</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171956775.png" alt="image-20231017195643886"></p><p>库存表</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171957799.png" alt="image-20231017195701407"></p><p>可以发现，账户余额扣了 200 变成了 800，而库存扣了 2 变成了 8</p><p>那么我们让扣除库存的时候报错看看会发生什么情况。</p><p>现在库存不够 10 个了我请求扣 10 个就会发生报错。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171958176.png" alt="image-20231017195804119"></p><p>可以看到响应结果 500 了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171958776.png" alt="image-20231017195845362"></p><p>此时我们再查看数据库的情况</p><p>账户表</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171959625.png" alt="image-20231017195918162"></p><p>库存表</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310171959448.png" alt="image-20231017195930412"></p><p>账户表的余额被扣了 200，但是库存表的数量却没有发生变化，这样显然是不合理的。</p><p>下面我们来分析下这件事儿。</p><p>在上面的业务中，订单服务去创建了订单然后去调用了账户服务和库存服务完成余额扣减和库存扣减，其中订单服务和账户服务都创建成功了。而库存服务在执行的时候却因为库存不足而失败了。那按照理论上讲这里报错前面都应该跟着回滚</p><p>原因：</p><p>1、每个服务都是独立的库存服务抛出异常其它服务也不知道</p><p>2、每个服务都是独立的所以它们的事务也是独立的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172023838.png" alt="image-20231017202319388"></p><p>如果要解决分布式事务的问题，首先要考虑四点：</p><p>首先第一点：分布式事务产生的原因，这个上述分析过了。</p><p>第二点：理解理论基础</p><p>第三点：弄清 seata 原理</p><p>第四点：利用 seata 手动实践，解决分布式事务问题</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172032081.png" alt="image-20231017203228913"></p><p>学习内容：</p><ul><li>理论基础</li><li>初始 Seata</li><li>手动实践</li><li>高可用</li></ul><h2 id="23-理论基础"><a class="anchor" href="#23-理论基础">#</a> 2.3、理论基础🌳</h2><ul><li>CAP 定理</li><li>BASE 理论</li></ul><h3 id="231-cap定理"><a class="anchor" href="#231-cap定理">#</a> 2.3.1、CAP 定理🌲</h3><p>1998 年，加州大学的计算机科学 Eric Brewer 提出，分布式系统有三个指标：</p><p>1、Consistency (一致性)</p><p>2、Availability (可用性)</p><p>3、Partition tolerance (分区容错性)</p><p>Eric Brewer 说，分布式系统无法同时满足这三个指标。</p><p>这个结论就叫做 CAP 定理。</p><p>三个圆不会同时重叠，最多两两重叠，也就是说同时满足两个</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172037268.png" alt="image-20231017203753986"></p><h4 id="2311-cap定理-consistency"><a class="anchor" href="#2311-cap定理-consistency">#</a> 2.3.1.1、CAP 定理 - Consistency🌴</h4><p>Consistency (一致性) ：用户访问分布式系统中的任意节点，得到的数据必须一致</p><p>比方说有两个节点，第一个节点上有个数据叫 data 值为 0，第二个节点也是如此。现在用户不管是访问哪个节点，结果都是一样的。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172043065.png" alt="image-20231017204312228"></p><p>但是，如果我对节点 node1 的数据进行了修改，这时两个节点的数据就不一样了。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172044702.png" alt="image-20231017204437374"></p><p>为了满足一致性就一定要把 node1 的数据同步到 node2 中，一旦数据同步完成，数据就再此一致了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172044179.png" alt="image-20231017204454104"></p><p>所以，作为一个分布式系统在做数据备份的时候一定要及时完成数据同步这样才能满足一致性</p><h4 id="2312-cap定理-availability"><a class="anchor" href="#2312-cap定理-availability">#</a> 2.3.1.2、CAP 定理 - Availability🌴</h4><p>Availability (可用性) ：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</p><p>比如说 node3 的请求被阻塞或者拒绝了，那所有的请求进来无法访问了，这时 node3 就是不可用了</p><p>所以可用性是指这个节点能不能被正常的访问</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172048465.png" alt="image-20231017204818409"></p><h4 id="2313-cap定理-partition-tolerance"><a class="anchor" href="#2313-cap定理-partition-tolerance">#</a> 2.3.1.3、CAP 定理 - Partition tolerance🌴</h4><p>Partition (分区) ：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p><p>Tolerance (容错) ：在集群出现分区时，整个系统也要持续对外提供服务</p><p>比如说 node3 因为网络故障与 node1 与 node2 断开了连接。node1 与 node2 之间正常访问。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172052718.png" alt="image-20231017205201677"></p><p>此时整个集群就会被划分成两个区了。node1 和 node2 它俩是一个区，node3 自己是一个区，这时如果有用户向 node2 写入了一个数据，node2 可以把数据同步给 node1 的但是 node3 上不能同步到数据，因此这两个区的数据就不一致了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172055775.png" alt="image-20231017205544452"></p><p>那如果我一定要满足数据的一致性呢，那我是不是可以让 node3 等待 node2 网络的恢复和数据的同步，在恢复之前所有来访问我的请求我都阻塞在这里。如果这么做可能会满足数据的一致性，但是 node3 明明是一个健康的节点结果进来的请求你都卡在这里不让人家访问，那 node3 不就是不可用了吗，所以它就不满足 可用性了。</p><p>我要想满足可用性，我就没办法保证一致性。</p><p>我要保证数据一致性，我就没办法让 node3 是可用性的</p><p>当网络出现分区时，可用性和一致性没有办法同时满足。但是网络分区也是不可避免的。</p><p>当 p 一定要实现，那么这时 c 和 a 之间就要做出抉择了。要么 c 要么 a 没有办法同时满足。这就是 CAP 定理了的原因了</p><blockquote><p><strong>总结</strong>：</p><p>简述 CAP 定理内容？</p><ul><li>分布式系统节点通过网络连接，一定会出现分区问题 (P)</li><li>当分区出现时，系统的一致性 (C) 和可用性 (A) 就无法同时满足</li></ul><p>思考：elasticsearch 集群是 CP 还是 AP？</p><p>答：ES 集群当网络出现故障时，有节点与其它节点断开连接的时候。es 集群处于一个警告状态，出现故障的节点过了一段时间后就会从集群中剔除，而这个节点上原来的数据分片。会分散到其它健康的节点上，而故障节点从集群中剔除用户无法访问了因此就牺牲了 可用性了。而数据会负责其它节点数据同步可以正常进行保证了数据的一致性。</p><p>因此 es 集群显然是一个 CP。满足高一致性低可用性</p></blockquote><p>我们知道在分布式系统下网络分区是不可避免的，所以不得不在一致性和可用性之间做出一个选择。</p><p>但是这两个特性都很重要我一个都不想放弃我该怎么办呢？Base 理论正好可以解决这个问题</p><h3 id="232-base理论"><a class="anchor" href="#232-base理论">#</a> 2.3.2、BASE 理论🌲</h3><p>BASE 理论是对 CAP 的一种解决思路，包含三个思想：</p><ul><li>Basically Available (基本可用)：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>Soft State (软状态)：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li>Eventually Consistent (最终一致性)：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><p>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借签 CAP 定理的 BASE 理论：</p><ul><li>AP 模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现 &lt;font color='red'&gt; 最终一致 &lt;/font&gt;.</li><li>CP 模式：各个子事务执行后互相等待，同时提交，同时回滚，达成 &lt;font color='red'&gt; 强一致 &lt;/font&gt;。但事务等待过程中，处于弱可用状态。</li></ul><h4 id="2321-分布式事务模型"><a class="anchor" href="#2321-分布式事务模型">#</a> 2.3.2.1、分布式事务模型🌴</h4><p>解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者 (子系统事务)。</p><p>用户下单调用订单服务，然后去调用账户服务和库存服务。那这个地方我们就需要一个事务的协调者了，每个微服务都跟事务协调者保持联系，如果你现在要做强一致。订单服务执行的时候不要提交，扣款服务，扣库存服务，但是库存服务执行完后发现失败了。怎么知道的。它们要把自己的执行结果告知给协调者，然后协调者一看有人失败了将来再通知其它服务让它们做回滚，这样大家就能保持一致了</p><p>每一个事务的参与者 (子系统事务)。</p><p>这里的子系统事务，称为 &lt;font color='red'&gt; 分支事务 &lt;/font&gt;.；有关联的各个分支事务 在一起称为 &lt;font color='red'&gt; 全局事务 &lt;/font&gt;.</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310172141933.png" alt="image-20231017214146879"></p><p>所以事务协调者，就是去协调各个分支事物的状态让它们达成一致</p><blockquote><p><strong>总结</strong>：</p><p>简述 BASE 理论三个思想：</p><ol><li>基本可用</li><li>软状态</li><li>最终一致</li></ol><p>解决分布式事务的思想和模型：</p><ol><li>全局事务：整个分布式事务</li><li>分支事务：分布式事务中包含的每个子系统的事务</li><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚</li></ol></blockquote><h2 id="24-初始seata"><a class="anchor" href="#24-初始seata">#</a> 2.4、初始 Seata🌳</h2><ul><li>Seata 的架构</li><li>部署 TC 服务</li><li>微服务集成 Seata</li></ul><p>Seata 是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p><p>官网地址：<span class="exturl" data-url="aHR0cHM6Ly9zZWF0YS5pby96aC1jbi8=">https://seata.io/zh-cn/</span></p><p><strong>Seata 事务管理中有三个重要的角色</strong>：</p><p>1、TC (Transaction Coordinator) - 事务协调者：维护全局和分布式事务的状态，协调全局事务提交和回滚。</p><p>2、TM (Transaction Manager) - 事务管理器：定义全局事务的范围，开始全局事务，提交或回滚全局事务。</p><p>3、RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310180745437.png" alt="image-20231018074554248"></p><p>Seata 根据要做强一致还是最终一致又延伸出了好几种不同的解决方案：</p><p><strong>Seata 提供了四个不同的分布式解决方案</strong>：</p><p>1、XA 模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</p><p>2、TCC 模式：最终一致的分阶段事务模式，有业务侵入</p><p>3、AT 模式：最终一致的分阶段事务模式，无业务侵入，也是 Seata 的默认模式</p><p>4、SAGA 模式：长事务模式，有业务侵入</p><h3 id="241-部署tc服务"><a class="anchor" href="#241-部署tc服务">#</a> 2.4.1、部署 TC 服务🌲</h3><p>参考文章：<a href="../Seata/seata%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90.md">seata 的部署和集成</a>.</p><h3 id="242-手动实践"><a class="anchor" href="#242-手动实践">#</a> 2.4.2、手动实践🌲</h3><ul><li>XA 模式</li><li>AT 模式</li><li>TCC 模式</li><li>SAGA 模式</li></ul><h4 id="2421-xa模式原理"><a class="anchor" href="#2421-xa模式原理">#</a> 2.4.2.1、XA 模式原理🌴</h4><p>XA 规则 是 X/Open 组织定义的分布式事务处理 (DTP，Distributed Transaction Processing) 标准，XA 规范 描述了全局的 TM 与局部的 RM 之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><p>这种模式，它把分布式事务定义成了两个阶段。第一阶段为 “准备阶段” 在此阶段中实物协调者会向事务参与者 (RM) 去发起一个准备的请求，在上面讲述中 RM 是资源管理器，但是在 XA 标准中这个 RM 其实都是由数据区实现的。也就是说数据库本身实现了 RM 功能。事务协调者通知这些数据库去执行自己的业务，但是执行完不要提交，然后把执行结果告知事务协调者</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181016731.png" alt="Snipaste_2023-10-18_10-16-42"></p><p>然后进行 “第二阶段” 事务协调者通知 RM 可以提交了。事务结束</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181017816.png" alt="image-20231018101741714"></p><p>如果 第一阶段 有任意一个服务失败了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181018842.png" alt="image-20231018101839751"></p><p>那么第二阶段，事务协调者就会通知所有的 RM 进行回滚</p><p>XA 模式，其实就是基于数据库本身的特性去实现的一种分布式事务</p><h4 id="2422-seata的xa模式"><a class="anchor" href="#2422-seata的xa模式">#</a> 2.4.2.2、seata 的 XA 模式🌴</h4><p>seata 的 XA 模式做了一些调整，但大体相似：</p><p>TM 注册全局事务，TM 作为分布式入口自然去调用微服务，调用微服务里面的 RM 拦截请求，seata 里面也实现了 RM，数据库也有 RM，在这个情况下 seata 的 RM 仅仅是代理你的请求。然后做一下分支事务的注册，接下来的事就是直接调用数据库了执行业务 SQL，但是执行完不提交，去报告一下事务的状态到 TC 就行了。所以 TC 此时就冲当了事务协调的作用了</p><p>至此，第一阶段结束</p><p>第二阶段 TM 发现业务结束了就去通知 TC，然后 TC 去检查事务的状态，都成功就成功。有一个失败就要回滚</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181126968.png" alt="image-20231018112632854"></p><p>如果我们只看核心部分就和 XA 没有什么太大的区别了</p><p><strong>RM 一阶段的工作</strong>：</p><p>1、注册分支实物到 TC</p><p>2、执行分支业务 sql 但不提交</p><p>3、报告执行状态到 TC</p><p><strong>TC 二阶段的工作</strong>：</p><ul><li>TC 检测各分支事务执行状态<ul><li>如果都成功，通过所有 RM 提交事务</li><li>如果有失败，通过所有 RM 回滚事务</li></ul></li></ul><p><strong>RM 二阶段的工作</strong>：</p><ul><li>接收 TC 指令，提交或回滚事务</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181128704.png" alt="image-20231018112758938"></p><blockquote><p><strong>总结</strong>：</p><p>XA 模式的优点是什么？</p><ul><li>事务的强一致性，满足 ACID 原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA 模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul></blockquote><h4 id="2423-实现xa模式"><a class="anchor" href="#2423-实现xa模式">#</a> 2.4.2.3、实现 XA 模式🌴</h4><p>Seata 的 starter 已经完成了 XA 模式的自动装配，实现非常简单，步骤如下：</p><p>1、修改 application.yml 文件 (每个参与事务的微服务)，开启 XA 模式</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">seata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">data-source-proxy-mode</span><span class="token punctuation">:</span> XA <span class="token comment"># 开启数据源代理的 XA 模式</span></pre></td></tr></table></figure><p>2、给发起全局事务的入口方法添加 @GlobalTransactional 注解，本例中是 OrderServiceImpl 中的 create 方法：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@GlobalTransactional</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Order</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 创建订单</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   orderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token comment">// 扣用户余额</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      accountClient<span class="token punctuation">.</span><span class="token function">deduct</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token comment">// 扣库存</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      storageClient<span class="token punctuation">.</span><span class="token function">deduct</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getCommodityCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FeignException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"下单失败，原因:&#123;&#125;"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">contentUTF8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">contentUTF8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token keyword">return</span> order<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>3、重启服务并测试</p><p>目前的 account_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181144973.png" alt="image-20231018114458627"></p><p>目前 storage_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181145948.png" alt="image-20231018114522634"></p><p>使用 postman 进行发送请求测试</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181146511.png" alt="image-20231018114629170"></p><p>测试后 account_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181146234.png" alt="image-20231018114658167"></p><p>测试后 storage_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181147047.png" alt="image-20231018114715998"></p><p>可以看到没有问题，下面测试 异常 的情况</p><p>postman 测试如下：</p><p>将存库数量改为 10，当前的库存数据是不足 10 个的因此执行就会出问题可以看到状态码 500 已经异常了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181148645.png" alt="image-20231018114814272"></p><p>我们看下数据库有没有回滚啊</p><p>测试后 account_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181149371.png" alt="image-20231018114937327"></p><p>测试后 storage_tbl 表单信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181149916.png" alt="image-20231018114955744"></p><p>可以看到没有任何变化</p><p>看下 idea 的控制台的打印信息：</p><p>accountApplication 打印出了事务回滚的信息，其它的是报错的信息，因为报错本身就没有执行成功</p><pre><code>10-18 11:48:06:076  INFO 18016 --- [h_RMROLE_1_2_16] i.s.c.r.p.c.RmBranchRollbackProcessor    : rm handle branch rollback process:xid=192.168.45.1:8091:4251845158843265029,branchId=4251845158843265031,branchType=XA,resourceId=jdbc:mysql:///seata_demo,applicationData=null
10-18 11:48:06:080  INFO 18016 --- [h_RMROLE_1_2_16] io.seata.rm.AbstractRMHandler            : Branch Rollbacking: 192.168.45.1:8091:4251845158843265029 4251845158843265031 jdbc:mysql:///seata_demo
10-18 11:48:06:083  INFO 18016 --- [h_RMROLE_1_2_16] i.s.rm.datasource.xa.ResourceManagerXA   : 192.168.45.1:8091:4251845158843265029-4251845158843265031 was rollbacked
10-18 11:48:06:084  INFO 18016 --- [h_RMROLE_1_2_16] io.seata.rm.AbstractRMHandler            : Branch Rollbacked result: PhaseTwo_Rollbacked
</code></pre><h4 id="2424-at模式原理"><a class="anchor" href="#2424-at模式原理">#</a> 2.4.2.4、AT 模式原理🌴</h4><p>AT 模式同样是分阶段提交的事务模型，不过却弥补了 XA 模型中资源锁定周期过长的缺陷。</p><p>AT 模式执行完业务 sql 后会直接提交事务，而不是等待对方的执行。在执行业务 sql 的时候由 RM 拦截这次的执行并且给数据形成一个快照，快照名为：undo log，如果失败了就可以根据快照进行恢复了。在第一阶段就已经提交了，第二阶段将 log 给删除</p><p>阶段一 RM 的工作：</p><p>1、注册分支事务</p><p>2、&lt;font color='red'&gt; 记录 undo-log (数据快照)&lt;/font&gt;.</p><p>3、执行业务 sql 并 &lt;font color='red'&gt; 提交 &lt;/font&gt;.</p><p>4、报告事务状态</p><p>阶段二提交时 RM 的工作：</p><p>1、删除 undo-log 即可</p><p>阶段二回滚时 RM 的工作：</p><p>1、根据 undo-log 恢复数据到更新前</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181329271.png" alt="image-20231018132921268"></p><p>下面通过一个例子来进行比喻：</p><p>例如，一个分支业务的 SQL 是这样的：update tb_account set money = money - 10 where id = 1</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181333976.png" alt="image-20231018133322819"></p><blockquote><p><strong>总结</strong>：</p><p>简述 AT 模式与 XA 模式最大的区别是什么？</p><ul><li>XA 模式一阶段不提交事务，锁定资源；AT 模式一阶段直接提交，不锁定资源</li><li>XA 模式依赖数据库机制实现回滚；AT 模式利用数据快照实现数据回滚</li><li>XA 模式强一致；AT 模式最终一致</li></ul></blockquote><h5 id="24241-at模式的脏写问题"><a class="anchor" href="#24241-at模式的脏写问题">#</a> 2.4.2.4.1、AT 模式的脏写问题🎋</h5><p>上述得知，AT 模式相对于 XA 模式来讲，性能得到了一些提升，因为 AT 模式在第一阶段的时候执行事务会直接提交。而不是等待各个分支一起执行完，因此资源锁定周期短 性能就比较好了。但是也正是因为它提前释放了资源没有去做锁，这就导致了在并发访问情况下会存在一些安全问题。</p><p>比如说有个 account 表，业务是修改 money 字段让其减 10，那么有一个线程开启了这个样事务。事务开启第一件事就是获取数据库锁，并生成一个快照。然后执行 sql 从 100 改为 90，然后提交事务，事务一旦提交锁就释放了，数据也就改了。第一阶段完成就轮到第二阶段，但同一时刻因为是并发现在有另外一个线程也开启了事务执行这个业务。事务 2 等待事务 1 释放锁了，然后拿到锁才能去保存快照并执行业务 sql 将 90 改 为 80，然后提交事务并释放锁。</p><p>如果这时事务 1 拿到锁后它要做回滚，因为事务 1 的第二阶段还没做完，这时事务 1 的快照数据为 money=100 这是回滚就出问题了。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181351685.png" alt="image-20231018135124412"></p><p>为了解决这个问题 AT 模式引入了一个叫 “全局锁” 的东西</p><p><mark>全局锁</mark>：由 TC 记录当前正在操作某行数据的事务，改事务持有全局锁，具备执行权。</p><p>TC 通过一张表来进行记录，分别记录：当前由哪个事务在操作，操作的哪张表，主键 操作这张表的哪一行数据。通过记录查看这个表的这行数据就只能被这个事务进行操作，其它事务不能操作。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181402045.png" alt="image-20231018140242928"></p><p>尽管如此，事务 1 在操作 money 字段的时候也可能会有一个没有被 seata 管理的业务来操作 money 字段此时就会产生脏写的问题了。分布式事务我们应该尽量的避免两个操作同一个字段。但是再怎么避免也不是不可能的情况</p><p>AT 模式也对这种方式做了一些处理。</p><p>当事务 1 第二阶段进行回滚时，会拿到 更新前的快照和更新后的快照。然后用更新后的快照数据去对当前的数据库数据做对比，判断是否一致，如果不一致就会记录异常，发送警告，人工介入</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181414617.png" alt="image-20231018141424667"></p><blockquote><p><strong>总结</strong>：</p><p>AT 模式的优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入，框架自动完成回滚和提交</li></ul><p>AT 模式的缺点：</p><ul><li>两阶段之间属于软状态，属于最终一致</li><li>框架的快照功能会影响性能，但比 XA 模式好很多</li></ul></blockquote><h4 id="2425-实现at模式"><a class="anchor" href="#2425-实现at模式">#</a> 2.4.2.5、实现 AT 模式🌴</h4><p>AT 模式中的快照生成，回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p><p>1、导入 SQL 文件：seata-at.sql。打开 sql 文件其中 lock_table 导入到 TC 服务关联的数据库，undo_log 表导入到微服务管理的数据库：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181426661.png" alt="image-20231018142639716"></p><p>2、修改 application.yml 文件，将事务模式修改为 AT 模式即可：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">seata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">data-source-proxy-mode</span><span class="token punctuation">:</span> AT <span class="token comment"># 开启数据源代理的 AT 模式</span></pre></td></tr></table></figure><p>3、重启服务并测试</p><p>目前的数据库数据</p><p>account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181429533.png" alt="image-20231018142929459"></p><p>storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181429518.png" alt="image-20231018142946308"></p><p>使用 postman 进行测试</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181430146.png" alt="image-20231018143051522"></p><p>测试后的 account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181431746.png" alt="image-20231018143114523"></p><p>测试后的 storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181431267.png" alt="image-20231018143133064"></p><p>使用 postman 进行一次失败的测试：</p><p>库存数据现在不够 10 个我们扣减 10 个此时就会产生异常</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181432899.png" alt="image-20231018143222278"></p><p>测试后的 account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181432696.png" alt="image-20231018143252735"></p><p>测试后的 storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181433130.png" alt="image-20231018143302062"></p><p>可以发现没有发生任何的变化啊。说明事务生效了，整个分布式事务都回滚了</p><p>accountApplication 服务在 idea 控制台中打印的信息如下：</p><p>可以看到最终删除了一个叫 undo_log 的表的数据也就是快照数据</p><pre><code>10-18 14:32:15:309  INFO 19080 --- [h_RMROLE_1_2_16] i.s.c.r.p.c.RmBranchRollbackProcessor    : rm handle branch rollback process:xid=192.168.45.1:8091:4251845158843265037,branchId=4251845158843265039,branchType=AT,resourceId=jdbc:mysql:///seata_demo,applicationData=null
10-18 14:32:15:310  INFO 19080 --- [h_RMROLE_1_2_16] io.seata.rm.AbstractRMHandler            : Branch Rollbacking: 192.168.45.1:8091:4251845158843265037 4251845158843265039 jdbc:mysql:///seata_demo
10-18 14:32:15:347  INFO 19080 --- [h_RMROLE_1_2_16] i.s.r.d.undo.AbstractUndoLogManager      : xid 192.168.45.1:8091:4251845158843265037 branch 4251845158843265039, undo_log deleted with GlobalFinished
10-18 14:32:15:348  INFO 19080 --- [h_RMROLE_1_2_16] io.seata.rm.AbstractRMHandler            : Branch Rollbacked result: PhaseTwo_Rollbacked
</code></pre><h4 id="2426-tcc模式原理"><a class="anchor" href="#2426-tcc模式原理">#</a> 2.4.2.6、TCC 模式原理🌴</h4><p>TCC 模式与 AT 模式非常相似，每阶段都是独立事务，不同的是 TCC 通过人工编码来实现数据恢复。需要实现三个方法：</p><p>1、Try：资源的检测和预留</p><p>2、Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功</p><p>3、Cancel：预留资源释放，可以理解为 try 的反向操作</p><p>举例，一个扣减用户余额的业务。假设账户 A 原来余额是 100，需要余额扣减 30 元</p><ul><li><p>阶段一 (Try)：检查余额是否充足，如果充足则冻结金额增加 30 元，可用余额扣除 30</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181448987.png" alt="image-20231018144806649"></p></li><li><p>阶段二 (Confirm)：假如要提交，则冻结金额扣减 30</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181448879.png" alt="image-20231018144815748"></p></li><li><p>阶段二 (Cancel)：如果要回滚，则冻结金额扣减 30，可用余额增加 30</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181448428.png" alt="image-20231018144824406"></p></li></ul><p>TCC 的工作模型图：</p><p>由 TM 开启并注册全局事务到 TC 上，然后 TM 通知每一个分支事务去执行，分支事务被 RM 做拦截，RM 先去注册一下分支事务。然后再执行操作，第一阶段进行 Try。Try 是一个独立的资源会直接提交，提交后报告事务的状态。二阶段：TM 通知 TC 事务结束了，然后 TC 做事务状态的判断，看看分支资源够不够。如果够直接 Confirm 提交，如果不够就执行 Cancel 逻辑进行回滚。</p><p>而这三个 Try，Confirm，Cancel 都是需要人工编写的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181456139.png" alt="image-20231018145621001"></p><blockquote><p><strong>总结</strong>：</p><p>TCC 模式的每个阶段是做什么的？</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC 的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比 AT 模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库比如：redis</li></ul><p>TCC 的缺点是什么？</p><ul><li>有代码侵入，需要认为编写 Try，Confirm 和 Cancel 接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑 Confirm 和 Cancel 的失败情况，做好幂等处理</li></ul></blockquote><h5 id="24261-案例改造account-service服务利用tcc实现分布式事务"><a class="anchor" href="#24261-案例改造account-service服务利用tcc实现分布式事务">#</a> 2.4.2.6.1、案例，改造 account-service 服务，利用 TCC 实现分布式事务🎋</h5><p>需求如下：</p><p>1、修改 acoount-service，编写 Try，Confirm，Cancel 逻辑</p><p>2、Try 业务：添加冻结金额，扣减可用金额</p><p>3、Confirm 业务：删除冻结金额</p><p>4、Cancel 业务：删除冻结金额，恢复可用金额</p><p>5、保证 Confirm，Cancel 接口的 &lt;font color='red'&gt; 幂等性 &lt;/font&gt;.</p><p>6、允许 &lt;font color='red'&gt; 空回滚 &lt;/font&gt;.</p><p>7、拒绝 &lt;font color='red'&gt; 业务悬挂 &lt;/font&gt;.</p><h5 id="24262-tcc的空回滚和业务悬挂"><a class="anchor" href="#24262-tcc的空回滚和业务悬挂">#</a> 2.4.2.6.2、TCC 的空回滚和业务悬挂🎋</h5><blockquote><p>当某分支事务的 try 阶段阻塞时，可能导致全局事务超时而触发二阶段的 cancel 操作。在未执行 try 操作时先执行了 cancel 操作，这时 cancel 不能做回滚，就是 &lt;font color='red'&gt; 空回滚 &lt;/font&gt;.</p><p>因此也不能报错。报错就会重试就会陷入一个死循环中。</p><p>对于已经空回滚的业务，如果以后继续执行 try，就永远不可能 Confirm 或 Cancel，这就是 &lt;font color='red'&gt; 业务悬挂 &lt;/font&gt;。应当阻止执行空回滚后的 try 操作，避免悬挂</p></blockquote><p>当第二个事务去执行的时候就会被阻塞，阻塞后得不到执行 TM 就会卡在这里，等待超时后就会报一个错误给 TC 了，TC 此时就会返回一个回滚的通知于是 RM 就会执行 Cancel 的逻辑了。</p><p>第一个分支执行 Cancel 没问题因为它已经 Try 了，但是第二个分支就出问题了 还没冻结金额就去恢复金额去了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181514887.png" alt="image-20231018151440530"></p><p>​</p><p><strong>业务分析</strong></p><p>为了实现空回滚，防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务 id 和执行状态，为此我们设计了一张表 (account_freeze_tbl 这个表在项目中 sql 文件夹已经提供了)：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181702525.png" alt="image-20231018170230443"></p><p>有了表后我们还需要创建实体类和 mapper</p><p>实体类</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Data</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"account_freeze_tbl"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountFreeze</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span><span class="token constant">INPUT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> xid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">String</span> userId<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> freezeMoney<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> state<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">TRY</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">CONFIRM</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">CANCEL</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>mapper</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountFreezeMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AccountFreeze</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="24263-声明tcc接口"><a class="anchor" href="#24263-声明tcc接口">#</a> 2.4.2.6.3、声明 TCC 接口：</h5><p>TCC 的 Try，Confirm，Cancel 方法都需要在接口中基于注解来声明，语法如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@LocalTCC</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountTCCService</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">// Try 逻辑，@TwoPhaseBusinessAction 中的 name 属性要与当前方法名一致，用于指定 Try 逻辑对应方法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@TwoPhaseBusinessAction</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"deduct"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            commitMethod <span class="token operator">=</span> <span class="token string">"confirm"</span><span class="token punctuation">,</span> rollbackMethod <span class="token operator">=</span> <span class="token string">"cancel"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token annotation punctuation">@BusinessActionContextParameter</span><span class="token punctuation">(</span>paramName <span class="token operator">=</span> <span class="token string">"userId"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> userId<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token annotation punctuation">@BusinessActionContextParameter</span><span class="token punctuation">(</span>paramName <span class="token operator">=</span> <span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 二阶段 confirm 确认方法，可以另命名，但要保证与 commitMethod 一致</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">// @Param context 上下文，可以传递 Try 方法的参数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token comment">// @return boolean 执行是否成功</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token keyword">boolean</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token comment">// 二阶段回滚方法，要保证与 rollbackMethod 一致</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Service</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountTccServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AccountTCCService</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">AccountMapper</span> mapper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">AccountFreezeMapper</span> freezeMapper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">AccountTccServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">AccountMapper</span> mapper<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                                 <span class="token class-name">AccountFreezeMapper</span> freezeMapper<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>mapper <span class="token operator">=</span> mapper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>freezeMapper <span class="token operator">=</span> freezeMapper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token annotation punctuation">@Transactional</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 1. 获取事务 id</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">String</span> xid <span class="token operator">=</span> <span class="token class-name">RootContext</span><span class="token punctuation">.</span><span class="token function">getXID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 1.1. 判断 freeze 中是否有冻结记录，如果有，一定是 CANCEL 执行过，要拒绝业务</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">AccountFreeze</span> freeze1 <span class="token operator">=</span> freezeMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>freeze1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// CANCEL 执行过，要拒绝业务</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 2. 扣减可用余额</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        mapper<span class="token punctuation">.</span><span class="token function">deduct</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 3. 记录冻结金额，事务状态</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token class-name">AccountFreeze</span> freeze <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountFreeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">TRY</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setXid</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        freezeMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token comment">// 1. 获取事务 id</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token class-name">String</span> xid <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getXid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token comment">// 2. 根据 id 删除冻结记录</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> freezeMapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token class-name">BusinessActionContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token comment">// 1. 从上下文中获取 用户的 id 和余额</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token class-name">String</span> xid <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getXid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token class-name">String</span> userId <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getActionContext</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token class-name">AccountFreeze</span> freeze <span class="token operator">=</span> freezeMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token comment">// 1.1. 空回滚的判断，判断 freeze 是否为 null，为 null 证明 try 没有执行，需要空回滚</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>freeze <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>            <span class="token comment">// 证明 try 没有执行，需要回滚</span></pre></td></tr><tr><td data-num="58"></td><td><pre>            freeze <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AccountFreeze</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>            freeze<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>            freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>            freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>            freeze<span class="token punctuation">.</span><span class="token function">setXid</span><span class="token punctuation">(</span>xid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>            freezeMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>        <span class="token comment">// 1.2. 幂等判断</span></pre></td></tr><tr><td data-num="67"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>freeze<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>            <span class="token comment">// 已经处理过一次 CANCEL 了，无需重复处理</span></pre></td></tr><tr><td data-num="70"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>        <span class="token comment">// 2. 恢复可用余额</span></pre></td></tr><tr><td data-num="73"></td><td><pre>        mapper<span class="token punctuation">.</span><span class="token function">refund</span><span class="token punctuation">(</span>freeze<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> freeze<span class="token punctuation">.</span><span class="token function">getFreezeMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>        <span class="token comment">// 3. 将冻结金额清零，状态改为 CANCEL</span></pre></td></tr><tr><td data-num="75"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setFreezeMoney</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>        freeze<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">AccountFreeze<span class="token punctuation">.</span>State</span><span class="token punctuation">.</span><span class="token constant">CANCEL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>        <span class="token keyword">int</span> count <span class="token operator">=</span> freezeMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>freeze<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>目前的数据库数据</p><p>account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181752228.png" alt="image-20231018175239070"></p><p>storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181752894.png" alt="image-20231018175252816"></p><p>使用 postman 进行测试</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181753247.png" alt="image-20231018175315999"></p><p>请求完后查看数据库的数据</p><p>account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181753982.png" alt="image-20231018175345921"></p><p>storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181754323.png" alt="image-20231018175359525"></p><p>测试失败的 postman 请求</p><p>因为此时库存的数量不够 10 个，我们减去 10 个就会产生异常</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181754231.png" alt="image-20231018175428861"></p><p>查看数据库的数据情况</p><p>测试后的 account_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181932222.png" alt="image-20231018193221241"></p><p>测试后的 storage_tbl 表的数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181932553.png" alt="image-20231018193242522"></p><p>可以看到完成了数据的回滚</p><h4 id="2427-saga模式"><a class="anchor" href="#2427-saga模式">#</a> 2.4.2.7、Saga 模式🌴</h4><p>Saga 模式是 SEATA 提供的长事务解决方案。也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>二阶段：成功则什么都不做，失败则通过编写补偿业务来回滚</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310181938269.png" alt="image-20231018193808535"></p><p>Saga 模式优点：</p><p>1、事务参与者可以基于事务驱动实现异步调用，吞吐高</p><p>2、一阶段直接提交事务，无锁，性能好</p><p>3、不用编写 TCC 中的三个阶段，实现简单</p><p>缺点：</p><p>1、软状态支持时间不确定，时效性差</p><p>2、没有锁，没有事务隔离，会有脏写</p><h4 id="2428-四种模式对比"><a class="anchor" href="#2428-四种模式对比">#</a> 2.4.2.8、四种模式对比🌴</h4><table><thead><tr><th></th><th>XA</th><th>AT</th><th>TCC</th><th>SAGA</th></tr></thead><tbody><tr><td>一致性</td><td>强一致</td><td>弱一致</td><td>弱一致</td><td>最终一致</td></tr><tr><td>隔离性</td><td>完全隔离</td><td>基于全局锁隔离</td><td>基于资源预留隔离</td><td>无隔离</td></tr><tr><td>代码侵入</td><td>无</td><td>无</td><td>有，要编写三个接口</td><td>有，要编写状态机和补偿业务</td></tr><tr><td>性能</td><td>差</td><td>好</td><td>非常好</td><td>非常好</td></tr><tr><td>场景</td><td>对一致性，隔离性有高要求的业务</td><td>基于关系型数据库的大多数分布式场景都可以</td><td>对性能要求较高的事务 &lt;br /&gt; 有非关系型数据库要参与的事务</td><td>业务流程长，业务流程多 &lt;br /&gt; 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</td></tr></tbody></table><h1 id="三-高可用"><a class="anchor" href="#三-高可用">#</a> 三、高可用🎄</h1><ul><li>高可用集群结构</li><li>实现高可用集群</li></ul><p><strong>TC 的异地多机房容灾架构</strong></p><p>TC 服务作为 Seata 的核心服务，一定要保证<mark>高可用</mark>和<mark>异地容灾</mark>.</p><p>具体实现查看文章：<a href="../Seata/seata%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90.md">seata 的部署和集成.md</a>.</p><h1 id="四多级缓存"><a class="anchor" href="#四多级缓存">#</a> 四，多级缓存🎄</h1><p>亿级流量的缓存方案</p><h2 id="41-传统缓存的问题"><a class="anchor" href="#41-传统缓存的问题">#</a> 4.1、传统缓存的问题🌳</h2><p>传统的缓存策略一般是请求到达 Tomcat 后，先查询 redis，如果未命中则查询数据库，存在下面的问题：</p><p>1、请求要经过 Tomcat 处理，Tomcat 的性能成为整个系统的瓶颈</p><p>2、Redis 缓存失效时，会对数据库产生冲击</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191526124.png" alt="image-20231019152653849"></p><h2 id="42-多级缓存方案"><a class="anchor" href="#42-多级缓存方案">#</a> 4.2、多级缓存方案🌳</h2><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻 Tomcat 压力，提升服务性能：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191532661.png" alt="image-20231019153224519"></p><p>用作缓存的 Nginx 是业务 Nginx，需要部署为集群，再有专门的 Nginx 用来做反向代理：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191534434.png" alt="image-20231019153411071"></p><h2 id="43-jvm进程缓存"><a class="anchor" href="#43-jvm进程缓存">#</a> 4.3、JVM 进程缓存🌳</h2><ul><li>导入商品案例</li><li>初始 Caffeine</li><li>实现进程缓存</li></ul><h3 id="431-导入商品案例"><a class="anchor" href="#431-导入商品案例">#</a> 4.3.1、导入商品案例🌲</h3><p>查看文章：<a href="./%E6%A1%88%E4%BE%8B%E5%AF%BC%E5%85%A5%E8%AF%B4%E6%98%8E/%E6%A1%88%E4%BE%8B%E5%AF%BC%E5%85%A5%E8%AF%B4%E6%98%8E.md">案例导入说明</a>.</p><h3 id="432-初始caffeine"><a class="anchor" href="#432-初始caffeine">#</a> 4.3.2、初始 Caffeine🌲</h3><h4 id="4321-本地进程缓存"><a class="anchor" href="#4321-本地进程缓存">#</a> 4.3.2.1、本地进程缓存🌴</h4><p>缓存在日常开发中起到至关重要的作用。由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们吧缓存分为两类：</p><p>1、分布式缓存，例如 Redis：</p><ul><li>优点：存储容量更大，可靠性更好，可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大，可靠性要求较高，需要在集群间共享</li></ul><p>2、进程本地缓存，例如 HashMap，GuavaCache：</p><ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限，可靠性较低，无法共享</li><li>场景：性能要求较高，缓存数据量较小</li></ul><p>Caffeine 是一个基于 java8 开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前 Spring 内部的缓存使用的就是 Caffeine。Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jlbi1tYW5lcy9jYWZmZWluZQ==">https://github.com/ben-manes/caffeine</span></p><h5 id="43211-caffeine示例"><a class="anchor" href="#43211-caffeine示例">#</a> 4.3.2.1.1、Caffeine 示例🎋</h5><p>可以通过 item-service 项目中的单元测试来学习 Caffeine 的使用：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">testBasicOpsTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 构建 cache 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token comment">// 2. 存数据</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">,</span> <span class="token string">"郭明然"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 3. 取数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token class-name">String</span> gf <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gf = "</span> <span class="token operator">+</span> gf<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">// 4. 取数据，如果未命中，则查询数据库</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token class-name">String</span> defaultGF <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"defaultGF"</span><span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token comment">// 4.1. 根据 key 去查询数据库</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">return</span> <span class="token string">"是个傻子"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"defaultGF = "</span> <span class="token operator">+</span> defaultGF<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">//------------------ 执行结果 ------------------</span></pre></td></tr><tr><td data-num="19"></td><td><pre>gf <span class="token operator">=</span> 郭明然</pre></td></tr><tr><td data-num="20"></td><td><pre>defaultGF <span class="token operator">=</span> 是个傻子</pre></td></tr></table></figure><p>Caffeine 提供了三种缓存驱逐策略：</p><p>1、基于容量：设置缓存的数量上限</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">testBasicOpsTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 构建 cache 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存大小上限为 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 2. 存数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">,</span> <span class="token string">"郭明然"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">,</span> <span class="token string">"郭明然1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">,</span> <span class="token string">"郭明然2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token comment">//        try &#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token comment">//            // 延迟 10ms，给清理线程一点时间</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token comment">//            Thread.sleep(100);</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token comment">//        &#125; catch (InterruptedException e) &#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token comment">//            throw new RuntimeException(e);</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token comment">//        &#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token comment">// 3. 取数据</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">//---------------- 打印结果 ----------------</span></pre></td></tr><tr><td data-num="24"></td><td><pre>郭明然</pre></td></tr><tr><td data-num="25"></td><td><pre>郭明然<span class="token number">1</span></pre></td></tr><tr><td data-num="26"></td><td><pre>郭明然<span class="token number">2</span></pre></td></tr></table></figure><p>使用线程睡眠让其等待 10ms 给清理线程一点时间</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">testBasicOpsTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 构建 cache 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存大小上限为 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 2. 存数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">,</span> <span class="token string">"郭明然"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">,</span> <span class="token string">"郭明然1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">,</span> <span class="token string">"郭明然2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>       <span class="token comment">// 延迟 10ms，给清理线程一点时间</span></pre></td></tr><tr><td data-num="14"></td><td><pre>       <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10l</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token comment">// 3. 取数据</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">//---------------- 打印结果 ----------------</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">null</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">null</span></pre></td></tr><tr><td data-num="26"></td><td><pre>郭明然<span class="token number">2</span></pre></td></tr></table></figure><p>2、基于时间：设置缓存的有效时间</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">testBasicOpsTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 构建 cache 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 2. 存数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">,</span> <span class="token string">"郭明然"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">,</span> <span class="token string">"郭明然1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">,</span> <span class="token string">"郭明然2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token comment">// 3. 取数据</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token comment">// 延迟 10ms，给清理线程一点时间</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">11000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span><span class="token string">"gf2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">//------------------- 打印结果 -------------------</span></pre></td></tr><tr><td data-num="24"></td><td><pre>郭明然</pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">null</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">null</span></pre></td></tr></table></figure><p>3、基于引用：设置缓存为软引用或弱引用，利用 GC 来回收缓存数据。性能较差，不建议使用。</p><p><mark>软引用</mark>：内存不足时才会回收； <mark>弱引用</mark>：就算内存充足时也会回收；</p><p>在默认情况下，当一个缓存元素过期的时候，Caffeine 不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p><h3 id="433-实现进程缓存"><a class="anchor" href="#433-实现进程缓存">#</a> 4.3.3、实现进程缓存🌲</h3><h4 id="4331-案例实现商品的查询的本地进程缓存"><a class="anchor" href="#4331-案例实现商品的查询的本地进程缓存">#</a> 4.3.3.1、案例，实现商品的查询的本地进程缓存🌴</h4><p>利用 Caffeine 实现下列需求：</p><p>1、给根据 id 查询商品的业务添加缓存，缓存未命中时查询数据库</p><p>2、给根据 id 查询商品存库的业务添加缓存，缓存未命中时查询数据库</p><p>3、缓存初始大小为 100</p><p>4、缓存上限为 10000</p><p>步骤：</p><p>1、给根据 id 查询商品的业务添加缓存，缓存未命中时查询数据库</p><p>2、给根据 id 查询商品存库的业务添加缓存，缓存未命中时查询数据库</p><p>3、缓存初始大小为 100</p><p>4、缓存上限为 10000</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Item</span><span class="token punctuation">></span></span> <span class="token function">itemCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">initialCapacity</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存初始化大小</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10_000</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存最大上限值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemStock</span><span class="token punctuation">></span></span> <span class="token function">itemStockCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">initialCapacity</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存初始化大小</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10_000</span><span class="token punctuation">)</span> <span class="token comment">// 设置缓存最大上限值</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>5、在 controller 层进行两个缓存对象的自动装配</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Item</span><span class="token punctuation">></span></span> itemCache<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">ItemStock</span><span class="token punctuation">></span></span> itemStockCache<span class="token punctuation">;</span></pre></td></tr></table></figure><p>6、编写缓存代码</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Item</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">// 优先根据缓存查，如果未命中则查询数据库</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">return</span> itemCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">return</span> itemService<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">ne</span><span class="token punctuation">(</span><span class="token string">"status"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/stock/&#123;id&#125;"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ItemStock</span> <span class="token function">findStockById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">return</span> itemStockCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> key <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">return</span> stockService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>请求接口进行测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgxL2l0ZW0vMTAwMDE=">http://localhost:8081/item/10001</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191732546.png" alt="image-20231019173236082"></p><p>第一次请求我们可以在 idea 控制台中看到打印了一段执行 SQL 的日志，说明查了一下数据库</p><pre><code>17:31:53:355 DEBUG 5692 --- [nio-8081-exec-1] c.h.item.mapper.ItemMapper.selectOne     : ==&gt;  Preparing: SELECT id,name,title,price,image,category,brand,spec,status,create_time,update_time FROM tb_item WHERE (status &lt;&gt; ? AND id = ?)
17:31:53:383 DEBUG 5692 --- [nio-8081-exec-1] c.h.item.mapper.ItemMapper.selectOne     : ==&gt; Parameters: 3(Integer), 10001(Long)
17:31:53:405 DEBUG 5692 --- [nio-8081-exec-1] c.h.item.mapper.ItemMapper.selectOne     : &lt;==      Total: 1
</code></pre><p>清空 idea 控制台再对该页面进行一次访问，因为缓存一开始就是空的</p><p>当我们执行过一次后数据就会被缓存起来，第二次执行就直接拿缓存的数据了可以看到控制台很干净没有一点打印信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191733727.png" alt="image-20231019173347678"></p><p>当然库存也是一样的道理</p><p>访问 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgxL2l0ZW0vc3RvY2svMTAwMDE=">http://localhost:8081/item/stock/10001</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191735447.png" alt="image-20231019173509976"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191734949.png" alt="image-20231019173456734"></p><p>清空控制台信息进行第二次访问，此时数据已经被缓存起来了。</p><p>二次依旧很干净</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191735198.png" alt="image-20231019173553835"></p><h1 id="五-lua语言入门"><a class="anchor" href="#五-lua语言入门">#</a> 五、Lua 语言入门🎄</h1><p>因为 Nginx 开发需要使用 Lua 语言来进行编程，所以我们就需要学习 Lua 语言</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191745432.png" alt="image-20231019174517515"></p><p>学习内容：</p><ul><li>初始 Lua</li><li>变量和循环</li><li>条件控制，函数</li></ul><h2 id="51-初始lua"><a class="anchor" href="#51-初始lua">#</a> 5.1、初始 Lua🌳</h2><p>Lua 是一种轻量级小巧的脚本语言，用标准 C 语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<span class="exturl" data-url="aHR0cDovL3d3dy5sdWEub3JnLw==">http://www.lua.org/</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310191751131.png" alt="image-20231019175148607"></p><h3 id="511-helloworld"><a class="anchor" href="#511-helloworld">#</a> 5.1.1、HelloWorld🌲</h3><p>1、在 Linux 虚拟机的任意目录下，新建一个 hello.lua 文件</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># vim hello.lua</span></pre></td></tr></table></figure><p>2、添加下面的内容</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>print<span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>3、运行</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># lua hello.lua</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Hello World<span class="token operator">!</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><h3 id="512-数据类型"><a class="anchor" href="#512-数据类型">#</a> 5.1.2、数据类型🌲</h3><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值 nil 属于该类，表示一个无效值 (在条件表达式中相当于 false)</td></tr><tr><td>boolean</td><td>包含两个值：false 和 true</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>table</td><td>Lua 中的表 (table) 其实是一个 “关联数组” (associative arrays)，数组的索引可以是数字，字符串或表类型。在 Lua 里，table 的创建是通过 “构造表达式” 来完成，最简单构造表达式是 { }，用来创建一个空表。</td></tr></tbody></table><p>可以利用 type 函数测试给定变量或者值的类型</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># vim hello.lua</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># lua hello.lua</span></pre></td></tr><tr><td data-num="3"></td><td><pre>string</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat hello.lua</span></pre></td></tr><tr><td data-num="5"></td><td><pre>print<span class="token punctuation">(</span>type<span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">))</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># vim hello.lua</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># lua hello.lua</span></pre></td></tr><tr><td data-num="3"></td><td><pre>number</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat hello.lua</span></pre></td></tr><tr><td data-num="5"></td><td><pre>print<span class="token punctuation">(</span>type<span class="token punctuation">(</span><span class="token number">10.4</span> * <span class="token number">3</span><span class="token punctuation">))</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><h3 id="513-变量"><a class="anchor" href="#513-变量">#</a> 5.1.3、变量🌲</h3><p>Lua 声明变量的时候，并不需要指定数据类型：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 声明字符串</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> str <span class="token operator">=</span> <span class="token string">'hello'</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 声明数字</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">local</span> num <span class="token operator">=</span> <span class="token number">21</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 声明布尔类型</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">local</span> flag <span class="token operator">=</span> <span class="token keyword">true</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">-- 声明数组 key 为索引的 table </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">local</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'python'</span><span class="token punctuation">,</span> <span class="token string">'lua'</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">-- 声明 table ，类似 java 的 map</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">local</span> map <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name <span class="token operator">=</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>访问 table：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 访问数组，lua 数组的角标从 1 开始</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 访问 table</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span>name<span class="token punctuation">)</span></pre></td></tr></table></figure><p>字符串拼接使用 <code>..</code></p><h3 id="514-循环"><a class="anchor" href="#514-循环">#</a> 5.1.4、循环🌲</h3><p>数组，table 都可以利用 for 循环来遍历</p><ul><li>遍历数组：</li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 声明数组 key 为索引的 table</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'python'</span><span class="token punctuation">,</span> <span class="token string">'lua'</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 遍历数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><ul><li>遍历 table</li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 声明 map，也就是 table</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> map <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name <span class="token operator">=</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 遍历 table</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h3 id="515-函数"><a class="anchor" href="#515-函数">#</a> 5.1.5、函数🌲</h3><p>定义函数的语法：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> 函数名<span class="token punctuation">(</span> argument1<span class="token punctuation">,</span> argument2<span class="token punctuation">,</span> argument3 <span class="token punctuation">...</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token comment">-- 函数体</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">return</span> 返回值</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>例如，定义一个函数，用来打印数组：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">printArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token keyword">do</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token function">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">end</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><h3 id="516-条件控制"><a class="anchor" href="#516-条件控制">#</a> 5.1.6、条件控制🌲</h3><p>类似 Java 的条件控制，例如 if , else 语法：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>布尔表达式<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">then</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment">-- [布尔表达式为 true 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token comment">-- [布尔表达式为 false 时执行该语句块 --]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>与 java 不同，布尔表达式中的逻辑运算是基于英文单词：</p><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>逻辑与操作符。若 A 为 false，则返回 A，否则返回 B</td><td>(A and B) 为 false</td></tr><tr><td>or</td><td>逻辑或操作符。若 A 为 true，则返回 A，否则返回 B</td><td>(A or B) 为 true</td></tr><tr><td>not</td><td>逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false</td><td>not (A and B) 为 true</td></tr></tbody></table><h1 id="六-多级缓存"><a class="anchor" href="#六-多级缓存">#</a> 六、多级缓存🎄</h1><ul><li>安装 OpenResty</li><li>OpenResty 快速入门</li><li>请求参数处理</li><li>查询 Tomcat</li><li>Redis 缓存预热</li><li>查询 Redis 缓存</li><li>Nginx 本地缓存</li></ul><h2 id="61-初始openresty"><a class="anchor" href="#61-初始openresty">#</a> 6.1、初始 OpenResty🌳</h2><p>OpenResty 是一个基于 Nginx 的高性能 Web 平台，用于方便地搭建能够处理高并发，扩展性极高的动态 Web 应用，Web 服务和动态网关。具备下列特点：</p><ul><li>具备 Nginx 的完整功能</li><li>基于 Lua 语言进行扩展，集成了大量精良的 Lua 库，第三方模块</li><li>允许使用 Lua 自定义业务逻辑，自定义库</li></ul><p>官方网站：<span class="exturl" data-url="aHR0cHM6Ly9vcGVucmVzdHkub3JnL2NuLw==">https://openresty.org/cn/</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200852606.png" alt="image-20231020085036341"></p><h3 id="611-openresty安装"><a class="anchor" href="#611-openresty安装">#</a> 6.1.1、OpenResty 安装🌲</h3><p>查看文章：<a href="./OpenResty%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85OpenResty.md">安装 OpenResty</a>.</p><h3 id="612-案例openresty快速入门实现商品详情页数据查询"><a class="anchor" href="#612-案例openresty快速入门实现商品详情页数据查询">#</a> 6.1.2、案例，OpenResty 快速入门，实现商品详情页数据查询🌲</h3><p>商品详情页目前展示的是假数据，在浏览器的控制台可以看到查询商品信息的请求：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200915073.png" alt="image-20231020091453815"></p><p>而这个请求最终被反向代理到虚拟机的 OpenResty 集群：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200915958.png" alt="image-20231020091503555"></p><p>需求：在 OpenResty 中接收这个请求，并返回一段商品的假数据。</p><p>步骤：一。</p><p>1、在 nginx.conf 的 http 下面，添加对 OpenResty 的 Lua 模块的加载</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># lua 模块</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lua_package_path <span class="token string">"/usr/local/openresty/lualib/?.lua;;"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># c 模块     </span></pre></td></tr><tr><td data-num="4"></td><td><pre>lua_package_cpath <span class="token string">"/usr/local/openresty/lualib/?.so;;"</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>2、在 nginx.conf 的 server 下面，添加对 /api/item 这个路径的监听</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 这里可以理解为就是 SpringMVC 中的 Controller</span></pre></td></tr><tr><td data-num="2"></td><td><pre>location /api/item <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 默认的响应类型</span></pre></td></tr><tr><td data-num="4"></td><td><pre>default_type application/json<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 这里可以理解为就是 Service 业务逻辑层</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 响应结果由 lua/item.lua 下的文件决定</span></pre></td></tr><tr><td data-num="7"></td><td><pre>content_by_lua_file lua/item.lua<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>步骤：二。</p><p>1、在 nginx 目录创建文件夹：lua</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># mkdir lua</span></pre></td></tr></table></figure><p>2、在 lua 文件夹下，新建文件：item.lua</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># touch lua/item.lua</span></pre></td></tr></table></figure><p>3、内容如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--  返回假数据，这里的 ngx.say () 函数，就是写数据到 Response 中</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">'&#123;"id":10001, "name":"SALSA AIR"&#125;'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>这里面的假数据去 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDElRTQlQjglQUQlRTYlODklOTMlRTUlQkMlODAlRTYlOEUlQTclRTUlODglQjYlRTUlOEYlQjAlRTklODAlODklRTYlOEIlQTl2dWUlRTclODQlQjYlRTUlOTAlOEUlRTglQjUlOEIlRTUlODAlQkNJdGVtJUU0JUI5JTlGJUU1JUIwJUIxJUU2JTk4JUFGT2JqZWN0JUU1JUFGJUI5JUU4JUIxJUExJUVGJUJDJThDJUU1JUIwJTg2JUU5JTg3JThDJUU5JTlEJUEyJUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU0JUJEJTlDJUU0JUI4JUJBJUU1JTgxJTg3JUU2JTk1JUIwJUU2JThEJUFFJUU0JUJEJUJGJUU3JTk0JUE4">http://localhost/item.html?id=10001 中打开控制台选择 vue 然后赋值 Item 也就是 Object 对象，将里面的数据作为假数据使用</span></p><p>这个页面是从 nginx 代理里面访问过来的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200940251.png" alt="image-20231020094054757"></p><p>将假数据拷贝到 ngx.say (‘’) 里面</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200942719.png" alt="image-20231020094215395"></p><p>为了能区分一下是否成功，我们将里面的一些数据进行一下修改</p><p>此处只是修改了尺寸和价格</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">'&#123;"id":10001,"name":"SALSA AIR","title":"RIMOWA 31寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4","price":27900,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp","category":"拉杆箱","brand":"RIMOWA","spec":"","status":1,"createTime":"2019-04-30T16:00:00.000+00:00","updateTime":"2019-04-30T16:00:00.000+00:00","stock":2999,"sold":31290&#125;'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>完整的 nginx.conf 配置内容：</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#user  nobody;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token directive"><span class="token keyword">worker_processes</span>  <span class="token number">1</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token directive"><span class="token keyword">error_log</span>  logs/error.log</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token directive"><span class="token keyword">worker_connections</span>  <span class="token number">1024</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token directive"><span class="token keyword">include</span>       mime.types</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token directive"><span class="token keyword">default_type</span>  application/octet-stream</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token directive"><span class="token keyword">sendfile</span>        <span class="token boolean">on</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token directive"><span class="token keyword">keepalive_timeout</span>  <span class="token number">65</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    </pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment"># lua 模块</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token directive"><span class="token keyword">lua_package_path</span> <span class="token string">"/usr/local/openresty/lualib/?.lua;;"</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment"># c 模块     </span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token directive"><span class="token keyword">lua_package_cpath</span> <span class="token string">"/usr/local/openresty/lualib/?.so;;"</span></span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8081</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> /api/item</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>          <span class="token comment"># 默认的响应类型</span></pre></td></tr><tr><td data-num="25"></td><td><pre>          <span class="token directive"><span class="token keyword">default_type</span> application/json</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>          <span class="token comment"># 响应结果由 lua/item.lua 下的文件决定</span></pre></td></tr><tr><td data-num="27"></td><td><pre>          <span class="token directive"><span class="token keyword">content_by_lua_file</span> lua/item.lua</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token directive"><span class="token keyword">index</span>  index.html index.htm</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token directive"><span class="token keyword">error_page</span>   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>4、重新加载配置</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>nginx <span class="token parameter variable">-s</span> reload</pre></td></tr></table></figure><p>查看商品页面，没有刷新前</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200946010.png" alt="image-20231020094617482"></p><p>刷新后</p><p>可以看到尺寸和价格被修改了但是中文也乱码了。。。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200951850.png" alt="image-20231020095132419"></p><h2 id="62-openresty获取请求参数"><a class="anchor" href="#62-openresty获取请求参数">#</a> 6.2、OpenResty 获取请求参数🌳</h2><p>OpenResty 提供了各种 API 用来获取不同类型的请求参数：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310200958589.png" alt="image-20231020095810221"></p><h3 id="621-案例获取请求路径中的商品id信息拼接到json结果中返回"><a class="anchor" href="#621-案例获取请求路径中的商品id信息拼接到json结果中返回">#</a> 6.2.1、案例，获取请求路径中的商品 id 信息，拼接到 json 结果中返回🌲</h3><p>在查询商品信息的请求中，通过路径占位符的方式，传递了商品 id 到后台：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201002974.png" alt="image-20231020100241654"></p><p>需求：在 OpenResty 中接收这个请求，并获取路径中的 id 信息，拼接到结果的 json 字符串中返回</p><p>OpenResty 中接受请求</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token directive"><span class="token keyword">location</span> ~ /api/item(\d+)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token comment"># 默认的响应类型</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token directive"><span class="token keyword">default_type</span> application/json</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment"># 响应结果由 lua/item.lua 下的文件决定</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token directive"><span class="token keyword">content_by_lua_file</span> lua/item.lua</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>并获取路径中的 id 信息，拼接到结果的 json 字符串中返回</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 获取路径参数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> id <span class="token operator">=</span> ngx<span class="token punctuation">.</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 返回结果</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">'&#123;"id":'</span> <span class="token operator">..</span> id <span class="token operator">..</span> <span class="token string">',"name":"SALSA AIR","title":"RIMOWA 31寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4","price":27900,"image":"https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp","category":"拉杆箱","brand":"RIMOWA","spec":"","status":1,"createTime":"2019-04-30T16:00:00.000+00:00","updateTime":"2019-04-30T16:00:00.000+00:00","stock":2999,"sold":31290&#125;'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>重启 Linux 中的 nginx 服务器</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre>nginx <span class="token parameter variable">-s</span> reload</pre></td></tr></table></figure><p>访问页面进行测试：</p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDE=">http://localhost/item.html?id=10001</span></p><p>请求结果</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201022922.png" alt="image-20231020102241989"></p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDI=">http://localhost/item.html?id=10002</span></p><p>请求结果</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201023953.png" alt="image-20231020102259850"></p><p>可以看到 id 就不再是写死的了，而是可以事实变化的</p><h2 id="63-查询tomcat"><a class="anchor" href="#63-查询tomcat">#</a> 6.3、查询 Tomcat🌳</h2><p>先看下多级缓存的架构。目前已经准备好了 nginx 反向代理服务器，它去接受前端的请求并且转到 OpenResty，服务端也编写好了进程缓存 OpenResty 也搭好了，但是 OpenResty 接收到请求后要查询数据。我们先实现从 Tomcat 去查然后再存储到缓存中。</p><p>需要注册 OPenResty 在虚拟机上，而 Tomcat 在本机上，ip 地址不同</p><p>两个 ip 地址访问的便捷方式：不管虚拟机的 ip 地址是什么只要官前三位就行了，然后把最后一位替换成 1 一定得到的就是 windows 电脑的位置。前提是需要关闭防火墙</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201030614.png" alt="image-20231020103028998"></p><h3 id="631-案例获取请求路径中的商品id信息根据id向tomcat查询商品信息"><a class="anchor" href="#631-案例获取请求路径中的商品id信息根据id向tomcat查询商品信息">#</a> 6.3.1、案例，获取请求路径中的商品 id 信息，根据 id 向 Tomcat 查询商品信息🌲</h3><p>这里要修改 item.lua，满足下面的需求：</p><p>1、获取请求参数中的 id</p><p>2、根据 id 向 Tomcat 服务发送请求，查询商品信息</p><p>3、根据 id 向 Tomcat 服务发送请求，查询库存信息</p><p>4、组装商品信息，库存信息，序列化为 Json 格式并返回</p><p>步骤：</p><p>一，nginx 内部发送 Http 请求</p><p>nginx 提供了内部 API 用以发送 http 请求：</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 注意：这里的 path 是路径，并不包含 ip 和端口。这个请求会被 nginx 内部的 server 监听并处理</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 这肯定不行，因为我们希望可以发送给 Tomcat 所以就要指定 Tomcat 的 ip 和端口</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token directive"><span class="token keyword">local</span> resp = ngx.location.capture(<span class="token string">"/path"</span>,</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   	<span class="token directive"><span class="token keyword">method</span> = ngx.HTTP_GET, -- 请求方式</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      args = <span class="token punctuation">&#123;</span>a = 1, b = 2<span class="token punctuation">&#125;</span>, -- get方式传参数</pre></td></tr><tr><td data-num="6"></td><td><pre>      body = "c=3&amp;d=4" -- post方式传参数</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span>)</pre></td></tr></table></figure><p>返回的响应内容包括：</p><ul><li>resp.status：响应状态码</li><li>resp.header：响应头，是一个 table</li><li>resp.body：响应体，就是响应数据</li></ul><p>我们希望这个请求发送到 Tomcat 服务器，所以还需要编写一个 server 来对这个路径做反向代理：</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token directive"><span class="token keyword">location</span> /path</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token comment"># 这里是 windows 电脑的 ip 和 Java 服务端口，需要确保 windows 防火墙处于关闭状态</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token directive"><span class="token keyword">proxy_pass</span> http://192.168.137.169:8081</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编写代码：</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8081</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token directive"><span class="token keyword">location</span> /item</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token directive"><span class="token keyword">proxy_pass</span> http://192.168.137.1:8081</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token directive"><span class="token keyword">location</span> ~ /api/item/(\d+)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token comment"># 默认的响应类型</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token directive"><span class="token keyword">default_type</span> application/json</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token comment"># 响应结果由 lua/item.lua 下的文件决定</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token directive"><span class="token keyword">content_by_lua_file</span> lua/item.lua</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token directive"><span class="token keyword">index</span>  index.html index.htm</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token directive"><span class="token keyword">error_page</span>   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Tomcat 的反向代理搞定了，以后只要调用 capture API 请求是 item 开头就一定能达到 Tomcat。所以以后就可以放心的使用这套 API 了，那么既然这个 API 经常要使用。那我们可以将发请求的代码封装成一个函数</p><h4 id="6311-封装http查询的函数"><a class="anchor" href="#6311-封装http查询的函数">#</a> 6.3.1.1、封装 HTTP 查询的函数🌴</h4><p>我们可以吧 http 查询的请求封装为一个函数，放到 OPenResty 函数库中，方便后期使用。</p><p>1、在 /usr/local/openresty/lualib 目录下创建 common.lua 文件：</p><p>为什么是这个位置？ 因为在上述配置 nginx 加载模块中指定的路径就是加载这个位置的任何.lua 文件</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">vim</span> /usr/local/openresty/lualib/common.lua</pre></td></tr></table></figure><p>2、在 common.lua 中封装 http 查询的函数</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 封装函数，发送 http 请求，并解析响应</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_http</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">local</span> resp <span class="token operator">=</span> ngx<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">capture</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        method <span class="token operator">=</span> ngx<span class="token punctuation">.</span>HTTP_GET<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        args <span class="token operator">=</span> params<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">-- 记录错误信息，返回 404</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"http not found, path: "</span><span class="token punctuation">,</span> path <span class="token punctuation">,</span> <span class="token string">", args: "</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> resp<span class="token punctuation">.</span>body</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">-- 将方法导出</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">local</span> _M <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  </pre></td></tr><tr><td data-num="16"></td><td><pre>    read_http <span class="token operator">=</span> read_http</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span>  </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">return</span> _M</pre></td></tr></table></figure><p>在 item.lua 文件中编写代码如下：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 导入 common 函数库</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'common'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">local</span> read_http <span class="token operator">=</span> common<span class="token punctuation">.</span>read_http</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 获取路径参数</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">local</span> id <span class="token operator">=</span> ngx<span class="token punctuation">.</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 查询商品信息</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">local</span> itemJSON <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span><span class="token string">"/item/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">-- 查询库存信息</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">local</span> stockJSON <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span><span class="token string">"/item/stock"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">-- 返回结果</span></pre></td></tr><tr><td data-num="14"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>itemJSON<span class="token punctuation">)</span></pre></td></tr></table></figure><p>访问 uri 进行一下请求测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDM=">http://localhost/item.html?id=10003</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201318784.png" alt="image-20231020131800919"></p><p>返回的数据</p><pre><code>&#123;
    &quot;id&quot;: 10003,
    &quot;name&quot;: &quot;韩版牛仔裤&quot;,
    &quot;title&quot;: &quot;唐狮新品牛仔裤女学生韩版宽松裤子 A款/中牛仔蓝（无绒款） 26&quot;,
    &quot;price&quot;: 84600,
    &quot;image&quot;: &quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t26989/116/124520860/644643/173643ea/5b860864N6bfd95db.jpg!q70.jpg.webp&quot;,
    &quot;category&quot;: &quot;牛仔裤&quot;,
    &quot;brand&quot;: &quot;唐狮&quot;,
    &quot;spec&quot;: &quot;&#123;\&quot;颜色\&quot;: \&quot;蓝色\&quot;, \&quot;尺码\&quot;: \&quot;26\&quot;&#125;&quot;,
    &quot;status&quot;: 1,
    &quot;createTime&quot;: &quot;2019-05-01T00:00:00.000+00:00&quot;,
    &quot;updateTime&quot;: &quot;2019-05-01T00:00:00.000+00:00&quot;,
    &quot;stock&quot;: null,
    &quot;sold&quot;: null
&#125;
</code></pre><p>现在所有的商品都能正常查询了，但是！</p><p>里面的，销量和存库的数据还没有。</p><p>但是如果要是有 3 张表，4 张表，5 张表都需要把它们拼接起来，所以最终需要的是完整的数据</p><p>但是 itemJSON 得到的数据是一个 Json 数据，我们需要转换为 Lua 里面的对象，使用 table 这个数据类型来进行存储</p><p>如下就是将 JSON 反序列化为 Lua 对象的方式：</p><h4 id="6312-json结果处理"><a class="anchor" href="#6312-json结果处理">#</a> 6.3.1.2、JSON 结果处理🌴</h4><p>OPenResty 提供了一个 cjson 的模块用来处理 JSON 的序列化和反序列化。</p><p>官方地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5yZXN0eS9sdWEtY2pzb24v">https://github.com/openresty/lua-cjson/</span></p><p>该模块的目录位置如下：/usr/local/openresty/lualib/</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201330405.png" alt="image-20231020133045031"></p><p><strong>使用</strong>：</p><p>1、导入 cjson 模块：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">local</span> cjson <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cjson'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>2、序列化：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">local</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   name <span class="token operator">=</span> <span class="token string">'jack'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   age <span class="token operator">=</span> <span class="token number">21</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">local</span> json <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></pre></td></tr></table></figure><p>3、反序列化</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">local</span> json <span class="token operator">=</span> <span class="token string">'&#123;"name": "jack", "age": 21&#125;'</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 反序列化</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">local</span> obj <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span></pre></td></tr></table></figure><p>继续下面的代码步骤：</p><p>1、将请求到的 json 数据序列化为 lua 中的 table 数据</p><p>2、再将序列化的数据进行调用拼接</p><p>3、拼接完毕后再将 lua 中 table 数据序列化为 json 响应到前端</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 导入 common 函数库</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'common'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">local</span> read_http <span class="token operator">=</span> common<span class="token punctuation">.</span>read_http</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 导入 cjson 库</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">local</span> cjson <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cjson'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 获取路径参数</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">local</span> id <span class="token operator">=</span> ngx<span class="token punctuation">.</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">-- 查询商品信息</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">local</span> itemJSON <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span><span class="token string">"/item/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">-- 查询库存信息</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">local</span> stockJSON <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span><span class="token string">"/item/stock/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">-- JSON 转化为 lua 的 table</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">local</span> item <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>itemJSON<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">local</span> sto <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>stockJSON<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">-- 组合数据</span></pre></td></tr><tr><td data-num="21"></td><td><pre>item<span class="token punctuation">.</span>stock <span class="token operator">=</span> sto<span class="token punctuation">.</span>stock</pre></td></tr><tr><td data-num="22"></td><td><pre>item<span class="token punctuation">.</span>sold <span class="token operator">=</span> sto<span class="token punctuation">.</span>sold</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">-- 把 item 序列化为 json 返回结果</span></pre></td></tr><tr><td data-num="25"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>cjson<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>请求 uri 进行测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDQ=">http://localhost/item.html?id=10004</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201343013.png" alt="image-20231020134303536"></p><p>请求到的数据</p><pre><code>&#123;
    &quot;spec&quot;: &quot;&#123;\&quot;颜色\&quot;: \&quot;白色\&quot;, \&quot;尺码\&quot;: \&quot;36\&quot;&#125;&quot;,
    &quot;sold&quot;: 974,
    &quot;status&quot;: 1,
    &quot;updateTime&quot;: &quot;2019-05-01T00:00:00.000+00:00&quot;,
    &quot;title&quot;: &quot;森马(senma)休闲鞋女2019春季新款韩版系带板鞋学生百搭平底女鞋 黄色 36&quot;,
    &quot;stock&quot;: 99999,
    &quot;price&quot;: 10400,
    &quot;image&quot;: &quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/29976/8/2947/65074/5c22dad6Ef54f0505/0b5fe8c5d9bf6c47.jpg!q70.jpg.webp&quot;,
    &quot;createTime&quot;: &quot;2019-05-01T00:00:00.000+00:00&quot;,
    &quot;category&quot;: &quot;休闲鞋&quot;,
    &quot;name&quot;: &quot;休闲板鞋&quot;,
    &quot;brand&quot;: &quot;森马&quot;,
    &quot;id&quot;: 10004
&#125;
</code></pre><p>可以看到有库存和销量的数据了</p><h3 id="632-tomcat集群的负载均衡"><a class="anchor" href="#632-tomcat集群的负载均衡">#</a> 6.3.2、Tomcat 集群的负载均衡🌲</h3><p>我们已经实现了，从 OPenResty 向 tomcat 发送一个 http 请求去查询商品信息返回页面，完成渲染。但是在上述实现案例中 Tomcat 只有一台</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201346554.png" alt="image-20231020134614455"></p><p>在实际生产中 Tomcat 一定是一个集群。所以 OPenResty 再发送请求时必须得对多台 Tomcat 实现一个负载均衡</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201349192.png" alt="image-20231020134913570"></p><p>比方说 负载均衡挑选了 8081，然后请求就会到达 8081 然后去查询数据库。</p><p>查询完数据库后会形成一个 jvm 进程缓存，保存在 8081 这台服务器上，缓存有了以后下次可以直接读取缓存就不用查询数据库了性能就非常好了。但是非常可惜的是进程缓存是不能共享的 8081 有这个缓存，8082 并没有，而负载均衡的规则是 轮询。如果这样访问缓存就会在多台 Tomcat 去冗余的保存。第一个占用额外空间，第二是缓存的命中率也有点惨</p><p>如果说我想要商品 10001 第一次查询完以后永远都有缓存。那么我必须让 item/10001 这个请求每次都指向同一个服务器，这样才能保证这个缓存一直生效。假如说又来一个 item/10002 那我就让它指向下一个服务器。</p><p>不同商品永远访问不同服务器，相同商品永远访问同一个服务器，这样就能保证缓存永远命中。</p><p>这样 jvm 进程缓存才有意义。但是现在是轮询肯定做不到这一点，所以我们需要修改 nginx 负载均衡的算法了。</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># tomcat 集群配置</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token directive"><span class="token keyword">upstream</span> tomcat-cluster</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token comment"># 根据请求过来的路径来计算 hash 值然后决定访问哪个服务器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token directive"><span class="token keyword">hash</span> <span class="token variable">$request_uri</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token directive"><span class="token keyword">server</span> 192.168.249.128:8081</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token directive"><span class="token keyword">server</span> 192.168.249.128:8082</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码演示如下：</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token directive"><span class="token keyword">include</span>       mime.types</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token directive"><span class="token keyword">default_type</span>  application/octet-stream</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token directive"><span class="token keyword">sendfile</span>        <span class="token boolean">on</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token directive"><span class="token keyword">keepalive_timeout</span>  <span class="token number">65</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment"># lua 模块</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token directive"><span class="token keyword">lua_package_path</span> <span class="token string">"/usr/local/openresty/lualib/?.lua;;"</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment"># c 模块     </span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token directive"><span class="token keyword">lua_package_cpath</span> <span class="token string">"/usr/local/openresty/lualib/?.so;;"</span></span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token directive"><span class="token keyword">upstream</span> tomcat-cluster</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token directive"><span class="token keyword">hash</span> <span class="token variable">$request_uri</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token directive"><span class="token keyword">server</span> 192.168.249.128:8081</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token directive"><span class="token keyword">server</span> 192.168.249.128:8082</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8081</span></span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token directive"><span class="token keyword">server_name</span>  localhost</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> /item</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token directive"><span class="token keyword">proxy_pass</span> http://tomcat-cluster</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> ~ /api/item/(\d+)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>          <span class="token comment"># 默认的响应类型</span></pre></td></tr><tr><td data-num="26"></td><td><pre>          <span class="token directive"><span class="token keyword">default_type</span> application/json</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>          <span class="token comment"># 响应结果由 lua/item.lua 下的文件决定</span></pre></td></tr><tr><td data-num="28"></td><td><pre>          <span class="token directive"><span class="token keyword">content_by_lua_file</span> lua/item.lua</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token directive"><span class="token keyword">index</span>  index.html index.htm</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token directive"><span class="token keyword">error_page</span>   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token directive"><span class="token keyword">root</span>   html</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在 idea 中开启 8082 端口的服务</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201435034.png" alt="image-20231020143541296"></p><p>启动</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201436217.png" alt="image-20231020143629316"></p><p>访问 uri 进行测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDE=">http://localhost/item.html?id=10001</span></p><p>这个 uri 访问请求到的 Tomcat 服务为如下：</p><p>idea 控制台中打印信息：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201441979.png" alt="image-20231020144146827"></p><p>访问 uri 进行测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDI=">http://localhost/item.html?id=10002</span></p><p>这个 uri 访问请求到的 Tomcat 服务为如下：</p><p>idea 控制台中打印信息：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201442866.png" alt="image-20231020144213109"></p><p>将连个服务的控制台打印的信息都清空然后再去访问一下 10001 和 10002</p><p>控制台都没有打印任何的信息说明缓存起作用了。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201443037.png" alt="image-20231020144338972"></p><h2 id="64-添加redis缓存的需求"><a class="anchor" href="#64-添加redis缓存的需求">#</a> 6.4、添加 Redis 缓存的需求🌳</h2><p>请求成功后不应该直接查询 jvm 进程缓存而是应该先到 redis 中看看有没有缓存再去看 jvm 进程缓存</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201447926.png" alt="image-20231020144727615"></p><h3 id="641-添加redis缓存要面临的问题"><a class="anchor" href="#641-添加redis缓存要面临的问题">#</a> 6.4.1、添加 Redis 缓存要面临的问题🌲</h3><h4 id="6411-冷启动与缓存预热"><a class="anchor" href="#6411-冷启动与缓存预热">#</a> 6.4.1.1、冷启动与缓存预热🌴</h4><p><mark>冷启动</mark>：服务刚刚启动时，Redis 中并没有缓存，如果所有商品数据都在第一次查询是添加缓存，可能会给数据库带来较大压力</p><p><mark>缓存预热</mark>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到 Redis 中</p><p>我们数据流量较少，可以在启动时将所有数据都存入缓存中。</p><h4 id="6412-缓存预热"><a class="anchor" href="#6412-缓存预热">#</a> 6.4.1.2、缓存预热🌴</h4><p>步骤：</p><p>1、利用 Docker 安装 Redis</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes</span></pre></td></tr></table></figure><p>2、在 item-service 服务中引入 redis 依赖</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>3、配置 Redis 地址</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">redis</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.249.128</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span></pre></td></tr></table></figure><p>4、编写初始化类</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">StringRedisTemplate</span> redisTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">ItemService</span> itemService<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">IItemStockService</span> stockService<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> <span class="token constant">MAPPER</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 初始化缓存</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 1. 查询商品信息</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> itemService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 2. 放入缓存</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Item</span> item <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 2.1. 序列化为 json</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token class-name">String</span> json <span class="token operator">=</span> <span class="token constant">MAPPER</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 2.2. 存入 redis</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"item:id:"</span> <span class="token operator">+</span> item<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 1. 查询库存信息</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ItemStock</span><span class="token punctuation">></span></span> list1 <span class="token operator">=</span> stockService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// 2. 放入缓存</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ItemStock</span> itemStock <span class="token operator">:</span> list1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 2.1. 序列化为 json</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token class-name">String</span> json <span class="token operator">=</span> <span class="token constant">MAPPER</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>itemStock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">// 2.2. 存入 redis</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"item:stock:id:"</span> <span class="token operator">+</span> itemStock<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>重启或启动 8081 和 8082 两个服务器</p><p>可以看到启动时 redis 初始化缓存去查询了数据库此时可以看下 redis 中的数据情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201513672.png" alt="image-20231020151344361"></p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># docker exec -it redis redis-cli</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> keys *</pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"item:id:10004"</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"item:stock:id:10004"</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"item:id:10002"</span></pre></td></tr><tr><td data-num="6"></td><td><pre> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"item:stock:id:10005"</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"item:id:10001"</span></pre></td></tr><tr><td data-num="8"></td><td><pre> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"item:stock:id:10001"</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"item:stock:id:10003"</span></pre></td></tr><tr><td data-num="10"></td><td><pre> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"item:id:10003"</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">"item:stock:id:10002"</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">"item:id:10005"</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span></pre></td></tr></table></figure><h2 id="65-查询redis缓存"><a class="anchor" href="#65-查询redis缓存">#</a> 6.5、查询 Redis 缓存🌳</h2><h3 id="651-openresty的redis模块"><a class="anchor" href="#651-openresty的redis模块">#</a> 6.5.1、OpenResty 的 Redis 模块🌲</h3><p>OPenResty 提供了操作 Redis 的模块，我们只要引入该模块就能直接使用：</p><p>在 common.lua 文件中进行编写</p><ul><li>引入 Redis 模块，并初始化 Redis 对象</li></ul><p>为什么引入模块中文件名中间需要一个 . ？</p><p>解释：因为我们上述文章中都是引入的 lualib 目录下的模块因为直接在 lua 目录所以可以直接写文件名就行了。但是这个 redis 可不再 lualib 根目录中而是在 resty 目录下</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201533407.png" alt="image-20231020153335950"></p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 引入 redis 模块</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> redis <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'resty.redis'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 初始化 redis 对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">local</span> red <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 设置 redis 超时时间</span></pre></td></tr><tr><td data-num="6"></td><td><pre>red<span class="token punctuation">:</span><span class="token function">set_timeouts</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>封装函数，用来释放 Redis 链接，其实是放入连接池</li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 关闭 redis 连接的工具方法，其实是放入连接池</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">close_redis</span><span class="token punctuation">(</span>red<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">local</span> pool_max_idle_time <span class="token operator">=</span> <span class="token number">10000</span> <span class="token comment">-- 连接的空闲时间，单位是毫秒</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">local</span> pool_size <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">-- 连接池大小</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">local</span> ok<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">set_keepalive</span><span class="token punctuation">(</span>pool_max_idle_time<span class="token punctuation">,</span> pool_size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"放入redis连接池失败: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>OPenResty 提供了操作 Redis 的模块，我们只要引入该模块就能直接使用：</p><ul><li>封装函数，从 Redis 读数据并返回：</li></ul><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 查询 redis 的方法 ip 和 port 是 redis 地址，key 是查询的 key</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_redis</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">-- 获取一个连接</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">local</span> ok<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"连接redis失败 : "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">-- 查询 redis</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">local</span> resp<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">-- 查询失败处理</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"查询Redis失败: "</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">", key = "</span> <span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">-- 得到的数据为空处理</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span> resp <span class="token operator">==</span> ngx<span class="token punctuation">.</span>null <span class="token keyword">then</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        resp <span class="token operator">=</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"查询Redis数据为空, key = "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">close_redis</span><span class="token punctuation">(</span>red<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> resp</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>完整的代码编写：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 引入 redis 模块</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> redis <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'resty.redis'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 初始化 redis 对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">local</span> red <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 设置 redis 超时时间</span></pre></td></tr><tr><td data-num="6"></td><td><pre>red<span class="token punctuation">:</span><span class="token function">set_timeouts</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- 关闭 redis 连接的工具方法，其实是放入连接池</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">close_redis</span><span class="token punctuation">(</span>red<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">local</span> pool_max_idle_time <span class="token operator">=</span> <span class="token number">10000</span> <span class="token comment">-- 连接的空闲时间，单位是毫秒</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">local</span> pool_size <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">-- 连接池大小</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">local</span> ok<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">set_keepalive</span><span class="token punctuation">(</span>pool_max_idle_time<span class="token punctuation">,</span> pool_size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"放入redis连接池失败: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">-- 查询 redis 的方法 ip 和 port 是 redis 地址，key 是查询的 key</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_redis</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">-- 获取一个连接</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">local</span> ok<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"连接redis失败 : "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">-- 查询 redis</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">local</span> resp<span class="token punctuation">,</span> err <span class="token operator">=</span> red<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">-- 查询失败处理</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"查询Redis失败: "</span><span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">", key = "</span> <span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">-- 得到的数据为空处理</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">if</span> resp <span class="token operator">==</span> ngx<span class="token punctuation">.</span>null <span class="token keyword">then</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        resp <span class="token operator">=</span> <span class="token keyword">nil</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"查询Redis数据为空, key = "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token function">close_redis</span><span class="token punctuation">(</span>red<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">return</span> resp</pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token comment">-- 封装函数，发送 http 请求，并解析响应</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_http</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">local</span> resp <span class="token operator">=</span> ngx<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">capture</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        method <span class="token operator">=</span> ngx<span class="token punctuation">.</span>HTTP_GET<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        args <span class="token operator">=</span> params<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token comment">-- 记录错误信息，返回 404</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ngx<span class="token punctuation">.</span>ERR<span class="token punctuation">,</span> <span class="token string">"http 查询失败了~, path: "</span><span class="token punctuation">,</span> path <span class="token punctuation">,</span> <span class="token string">", args: "</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        ngx<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token keyword">return</span> resp<span class="token punctuation">.</span>body</pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token comment">-- 将方法导出</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token keyword">local</span> _M <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    read_http <span class="token operator">=</span> read_http<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    read_redis <span class="token operator">=</span> read_redis</pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span>  </pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token keyword">return</span> _M</pre></td></tr></table></figure><p>在 item.lua 文件中进行导入 redis 工具函数</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">local</span> read_redis <span class="token operator">=</span> common<span class="token punctuation">.</span>read_redis</pre></td></tr></table></figure><p>由于添加了 redis 缓存那么之前的查询商品信息和库存的函数就需要修改了。</p><p>但是需要修改两个太麻烦了所以对其进行封装函数：</p><p>需求：</p><p>1、修改 item.lua，封装一个函数 read_data，实现先查询 redis，如果未命中，再查询 tomcat</p><p>2、修改 item.lua，查询商品和库存时都调用 read_data 这个函数</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 封装查询函数，先查询 redis，如果未命中再查询 tomcat</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_data</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">-- 查询 redis</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">local</span> resp <span class="token operator">=</span> <span class="token function">read_redis</span><span class="token punctuation">(</span><span class="token string">"192.168.249.128"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">-- 判断 redis 是否命中</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">-- redis 查询失败，再查询 tomcat</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    resp <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">end</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> resp</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>编写完封装函数后将原来的请求函数进行替换</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 查询商品信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> itemJSON <span class="token operator">=</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token string">"item:id:"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token string">"/item/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 查询库存信息</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">local</span> stockJSON <span class="token operator">=</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token string">"item:stock:id:"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token string">"/item/stock/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>item.lua 文件的完整代码：</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 导入 common 函数库</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> common <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'common'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">local</span> read_http <span class="token operator">=</span> common<span class="token punctuation">.</span>read_http</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">local</span> read_redis <span class="token operator">=</span> common<span class="token punctuation">.</span>read_redis</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">-- 导入 cjson 库</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">local</span> cjson <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cjson'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">-- 封装查询函数，先查询 redis，如果未命中再查询 tomcat</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">read_data</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">-- 查询 redis</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">local</span> resp <span class="token operator">=</span> <span class="token function">read_redis</span><span class="token punctuation">(</span><span class="token string">"192.168.249.128"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">-- 判断 redis 是否命中</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">if</span> <span class="token keyword">not</span> resp <span class="token keyword">then</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">-- redis 查询失败，再查询 tomcat</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    ngx<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"redis查询失败,尝试查询http, key :"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    resp <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token keyword">end</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">return</span> resp</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">end</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">-- 获取路径参数</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">local</span> id <span class="token operator">=</span> ngx<span class="token punctuation">.</span>var<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">-- 查询商品信息</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">local</span> itemJSON <span class="token operator">=</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token string">"item:id:"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token string">"/item/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">-- 查询库存信息</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">local</span> stockJSON <span class="token operator">=</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token string">"item:stock:id:"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token string">"/item/stock/"</span> <span class="token operator">..</span> id<span class="token punctuation">,</span> <span class="token keyword">nil</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">-- JSON 转化为 lua 的 table</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">local</span> item <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>itemJSON<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">local</span> sto <span class="token operator">=</span> cjson<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>stockJSON<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">-- 组合数据</span></pre></td></tr><tr><td data-num="35"></td><td><pre>item<span class="token punctuation">.</span>stock <span class="token operator">=</span> sto<span class="token punctuation">.</span>stock</pre></td></tr><tr><td data-num="36"></td><td><pre>item<span class="token punctuation">.</span>sold <span class="token operator">=</span> sto<span class="token punctuation">.</span>sold</pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment">-- 把 item 序列化为 json 返回结果</span></pre></td></tr><tr><td data-num="39"></td><td><pre>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>cjson<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>重启虚拟机中的 nginx</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># nginx -s reload</span></pre></td></tr></table></figure><p>访问 uri 进行测试：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDI=">http://localhost/item.html?id=10002</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201603830.png" alt="image-20231020160328617"></p><p>查看 idea 控制台</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201603637.png" alt="image-20231020160349587"></p><p>将控制台信息清空后再次访问 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDI=">http://localhost/item.html?id=10002</span></p><p>控制台情况</p><p>说明数据已经被缓存了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201604800.png" alt="image-20231020160432732"></p><p>我们把两个服务器全关了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201605790.png" alt="image-20231020160510420"></p><p>再访问一下 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDI=">http://localhost/item.html?id=10002</span></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310201634990.png" alt="image-20231020163445555"></p><p>可以看到如果没有启动 Tomcat 也没事儿因为先去看了下 Redis 发现有相关数据直接拿来就不找服务器了。</p><h2 id="66-nginx本地缓存"><a class="anchor" href="#66-nginx本地缓存">#</a> 6.6、Nginx 本地缓存🌳</h2><p>OPenResty 为 Nginx 提供了 shard dict 的功能，可以在 Nginx 的多个 worker 之间共享数据，实现缓存功能。</p><p>1、开启共享字典，在 nginx.conf 的 http 下添加配置</p><figure class="highlight nginx"><figcaption data-lang="nginx"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小 150m</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token directive"><span class="token keyword">lua_shared_dict</span> item_cache <span class="token number">150m</span></span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>2、操作共享字典</p><p>在 item.lua 文件中导入</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 导入共享词典，本地缓存</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">local</span> item_cache <span class="token operator">=</span> ngx<span class="token punctuation">.</span>shared<span class="token punctuation">.</span>item_cache</pre></td></tr></table></figure><h3 id="661-案例在查询商品时优先查询openresty的本地缓存"><a class="anchor" href="#661-案例在查询商品时优先查询openresty的本地缓存">#</a> 6.6.1、案例，在查询商品时，优先查询 OPenResty 的本地缓存🌲</h3><p>需求：</p><p>1、修改 item.lua 中的 read_data 函数，优先查询本地缓存，未命中时在查询 Redis，Tomcat</p><p>2、查询 Redis 或 Tomcat 成功后，将数据写入本地缓存，并设置有效期</p><p>3、商品基本信息，有效期 30 分钟</p><p>4、库存信息，有效期 1 分钟</p><figure class="highlight lua"><figcaption data-lang="lua"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 封装查询函数，先查询 redis，如果未命中再查询 tomcat</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">function</span> <span class="token function">read_data</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> expire<span class="token punctuation">,</span> path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">-- 查询本地缓存</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">local</span> val <span class="token operator">=</span> item_cache<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">if</span> <span class="token keyword">not</span> val <span class="token keyword">then</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">-- 查询 redis</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    val <span class="token operator">=</span> <span class="token function">read_redis</span><span class="token punctuation">(</span><span class="token string">"192.168.249.128"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 判断查询结果</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> val <span class="token keyword">then</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">-- redis 查询失败，查询 tomcat</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        val <span class="token operator">=</span> <span class="token function">read_http</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">end</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">-- 查询成功，把数据写入本地缓存</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  item_cache<span class="token punctuation">:</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> expire<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token comment">-- 返回数据</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">return</span> val</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">end</span></pre></td></tr></table></figure><p>测试</p><p>切换到 nginx 目录下来监控 error.log 文件的打印情况</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># nginx -s reload</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># pwd</span></pre></td></tr><tr><td data-num="3"></td><td><pre>/usr/local/openresty/nginx</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># tail -f logs/error.log</span></pre></td></tr></table></figure><h1 id="七-缓存同步"><a class="anchor" href="#七-缓存同步">#</a> 七、缓存同步🎄</h1><ul><li>数据同步策略</li><li>安装 Canal</li><li>监听 Canal</li></ul><h2 id="71-数据同步策略"><a class="anchor" href="#71-数据同步策略">#</a> 7.1、数据同步策略🌳</h2><p>缓存数据同步的常见方式有三种：</p><p><mark>1、设置有效期</mark>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><p>1.1、优势：简单，方便</p><p>1.2、缺点：时效性差，缓存过期之前可能不一致</p><p>1.3、场景：更新频率较低，时效性要求低的业务</p><p><mark>2、同步双写</mark>：在修改数据库的同时，直接修改缓存</p><p>2.1、优势：时效性强，缓存与数据库强一致</p><p>2.2、缺点：有代码侵入，耦合度高</p><p>2.3、场景：对一致性，时效性要求较高的缓存数据</p><p><mark>3、异步通知</mark>：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><p>3.1、优势：低耦合，可以同时通知多个缓存服务</p><p>3.2、缺点：时效性一般，可能存在终极爱你不一致状态</p><p>3.3、场景：时效性要求一般，有多个服务需要同步</p><h3 id="711-缓存同步策略"><a class="anchor" href="#711-缓存同步策略">#</a> 7.1.1、缓存同步策略🌲</h3><p>异步通知可以使用基于 MQ 的异步通知</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310210915149.png" alt="image-20231021091552370"></p><p>但是基于 MQ 还是要修改里面的代码发送消息，而下面要讲的是基于 Canal 的异步通知</p><p>基于 Canal 的异步通知</p><p>canal 可以去监听数据库的变化</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310210917386.png" alt="image-20231021091750935"></p><h3 id="712-初始canal"><a class="anchor" href="#712-初始canal">#</a> 7.1.2、初始 Canal🌲</h3><p>Canal 意译为 水道 / 管道 / 沟渠，Canal 是阿里巴巴旗下的一款开源项目，基于 Java 开发。基于数据库增量日志解析，提供增量数据订阅 &amp; 消费。GiHub 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvY2FuYWw=">https://github.com/alibaba/canal</span></p><p>Canal 是基于 mysql 的主从同步来实现的，MySQL 主从同步的原理如下：</p><p>master 就是 mysql 的主节点，slave 就是 mysql 的从节点。主从数据是要做同步的，那它怎么做到的呢？首先 mysql 的主节点在做增删改查时就回去记录日志到 binary.log 文件中这个文件称为二进制日志文件。其中记录的就是 binary log events，里面记录的就是业务 sql。slave 会开启一个线程不断的来读取这个日志文件把这个文件读过来放到一个 relay log 文件中。这样主节点做了哪些 sql 从节点 也做哪些 sql</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310210922728.png" alt="image-20231021092228657"></p><p>而 Canal 就是把自己伪装成 MySQL 的一个 Slave 节点，从而监听 master 的 binary log 变化。再把得到的变化信息通知给 Canal 的客户端，进而完成对其它数据库的同步。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310210929872.png" alt="image-20231021092859461"></p><h3 id="713-canal安装"><a class="anchor" href="#713-canal安装">#</a> 7.1.3、Canal 安装🌲</h3><p>查看文章：<a href="./Canal/%E5%AE%89%E8%A3%85Canal.md">安装 Canal</a>.</p><h3 id="714-canal客户端"><a class="anchor" href="#714-canal客户端">#</a> 7.1.4、Canal 客户端🌲</h3><p>Canal 提供了各种语言的客户端，当 Canal 监听到 binlog 变化时，会通知 Canal 的客户端。不过这里我们会使用 Github 上的第三方开源的 canal-stater。地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05vcm1hbkd5bGxlbmhhYWwvY2FuYWwtY2xpZW50">https://github.com/NormanGyllenhaal/canal-client</span></p><p>引入依赖：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>top.javatool<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>canal-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.1-RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>编写配置：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">canal</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">destination</span><span class="token punctuation">:</span> dkx1 <span class="token comment"># canal 实例名称，要跟 canal-server 运行时设置的 destiation 一致</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.249.128<span class="token punctuation">:</span><span class="token number">11111</span> <span class="token comment"># canal 地址</span></pre></td></tr></table></figure><p>编写监听器，监听 Canal 消息：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 指定要监听的表</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@CanalTable</span><span class="token punctuation">(</span><span class="token string">"tb_item"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token annotation punctuation">@Component</span>                                    <span class="token comment">// 指定表关联的实体类</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemHandler</span> <span class="token keyword">implements</span> <span class="token class-name">EntryHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token comment">// 下面三个重写方法是，监听到数据库的增删改的消息的</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">EntryHandler</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Item</span> before<span class="token punctuation">,</span> <span class="token class-name">Item</span> after<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">EntryHandler</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>before<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token class-name">EntryHandler</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>Canal 推送给 canal-client 的是被修改的这一行数据 (row) ，而我们引入的 canal-client 则会帮我们把行数据封装到 item 实体类中。这个过程中需要知道数据库与实体的映射关系，要用到 JPA 的几个注解：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Data</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"tb_item"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 标记表中的 id 字段</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Id</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span><span class="token comment">// 商品 id</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 其它字段 省略</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Date</span> updateTime<span class="token punctuation">;</span><span class="token comment">// 更新时间</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// @Transient 标记不属于表中的字段  忽略</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token annotation punctuation">@Transient</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> stock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Transient</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> sold<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编写 redis 的缓存类 ，添加两个函数，一个新增或更新，一个是删除</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveItem</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token class-name">String</span> json <span class="token operator">=</span> <span class="token constant">MAPPER</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"item:id:"</span> <span class="token operator">+</span> item<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JsonProcessingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteItemById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"item:id:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>定义完 redis 的缓存类里面的函数后再回到编写监听器的类里面编写代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@CanalTable</span><span class="token punctuation">(</span><span class="token string">"tb_item"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemHandler</span> <span class="token keyword">implements</span> <span class="token class-name">EntryHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">RedisHandler</span> redisHandler<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Item</span><span class="token punctuation">></span></span> cache<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        redisHandler<span class="token punctuation">.</span><span class="token function">saveItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Item</span> before<span class="token punctuation">,</span> <span class="token class-name">Item</span> after<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>after<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        redisHandler<span class="token punctuation">.</span><span class="token function">saveItem</span><span class="token punctuation">(</span>after<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">EntryHandler</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>before<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Item</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token comment">// 写数据到 jvm 进程缓存</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        cache<span class="token punctuation">.</span><span class="token function">invalidate</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 写数据到 redis</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        redisHandler<span class="token punctuation">.</span><span class="token function">deleteItemById</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token class-name">EntryHandler</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动服务查看 idea 打印信息：</p><pre><code>meters: 10005(Long)
14:50:32:387 DEBUG 4956 --- [nio-8081-exec-7] c.h.i.mapper.ItemStockMapper.selectById  : &lt;==      Total: 1
14:50:32:472  INFO 4956 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=-1,entries=[],raw=false,rawEntries=[]]
14:50:34:474  INFO 4956 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=-1,entries=[],raw=false,rawEntries=[]]
14:50:36:477  INFO 4956 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=-1,entries=[],raw=false,rawEntries=[]]
14:50:38:478  INFO 4956 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=-1,entries=[],raw=false,rawEntries=[]]
14:50:40:472  INFO 4956 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=-1,entries=[],raw=false,rawEntries=[]]
</code></pre><p>表示 canal 与 java 成功的连接到了</p><p>那么测试一下数据同步打开 8081 端口的页面</p><p>比如说修改 10001 这个商品的数据：</p><p>原来的数据如下：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211452116.png" alt="image-20231021145237319"></p><p>修改后的数据如下：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211453292.png" alt="image-20231021145302067"></p><p>点击确定</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211453164.png" alt="image-20231021145357351"></p><p>再查看 idea 的控制台信息：</p><p>可以看到打印了一堆日志信息</p><pre><code>  version: 1
  logfileName: &quot;mysql-bin.000006&quot;
  logfileOffset: 1173
  serverId: 1000
  serverenCode: &quot;UTF-8&quot;
  executeTime: 1697871191000
  sourceType: MYSQL
  schemaName: &quot;&quot;
  tableName: &quot;&quot;
  eventLength: 91
&#125;
entryType: TRANSACTIONBEGIN
storeValue: &quot; H&quot;
, header &#123;
  version: 1
  logfileName: &quot;mysql-bin.000006&quot;
  logfileOffset: 1344
  serverId: 1000
  serverenCode: &quot;UTF-8&quot;
  executeTime: 1697871191000
  sourceType: MYSQL
  schemaName: &quot;dkx&quot;
  tableName: &quot;tb_item&quot;
  eventLength: 620
  eventType: UPDATE
  props &#123;
    key: &quot;rowsCount&quot;
    value: &quot;1&quot;
  &#125;
&#125;
entryType: ROWDATA
storeValue: &quot;\b_\020\002P\000b\324\n\n&amp;\b\000\020\373\377\377\377\377\377\377\377\377\001\032\002id \001(\0000\000B\00510001R\006bigint\nd\b\001\020\f\032\005title \000(\0000\000BCRIMOWA 21\345\257\270\346\211\230\350\277\220\347\256\261\346\213\211\346\235\206\347\256\261 SALSA AIR\347\263\273\345\210\227\346\236\234\347\273\277\350\211\262 820.70.36.4R\fvarchar(264)\n)\b\002\020\f\032\004name \000(\0000\000B\tSALSA AIRR\fvarchar(128)\n)\b\003\020\373\377\377\377\377\377\377\377\377\001\032\005price \000(\0000\000B\00516900R\006bigint\n\226\001\b\004\020\f\032\005image \000(\0000\000Buhttps://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webpR\fvarchar(200)\n-\b\005\020\f\032\bcategory \000(\0000\000B\t\346\213\211\346\235\206\347\256\261R\fvarchar(200)\n\'\b\006\020\f\032\005brand \000(\0000\000B\006RIMOWAR\fvarchar(100)\nG\b\a\020\f\032\004spec \000(\0000\000B\'&#123;\&quot;\351\242\234\350\211\262\&quot;: \&quot;\347\272\242\350\211\262\&quot;, \&quot;\345\260\272\347\240\201\&quot;: \&quot;26\345\257\270\&quot;&#125;R\fvarchar(200)\n\032\b\b\020\004\032\006status \000(\0000\000B\0011R\003int\n6\b\t\020]\032\vcreate_time \000(\0000\000B\0232019-05-01 00:00:00R\bdatetime\n6\b\n\020]\032\vupdate_time \000(\0000\000B\0232019-05-01 00:00:00R\bdatetime\022&amp;\b\000\020\373\377\377\377\377\377\377\377\377\001\032\002id \001(\0000\000B\00510001R\006bigint\022d\b\001\020\f\032\005title \000(\0000\000BCRIMOWA 21\345\257\270\346\211\230\350\277\220\347\256\261\346\213\211\346\235\206\347\256\261 SALSA AIR\347\263\273\345\210\227\346\236\234\347\273\277\350\211\262 820.70.36.4R\fvarchar(264)\022)\b\002\020\f\032\004name \000(\0000\000B\tSALSA AIRR\fvarchar(128)\022)\b\003\020\373\377\377\377\377\377\377\377\377\001\032\005price \000(\0010\000B\00528900R\006bigint\022\226\001\b\004\020\f\032\005image \000(\0000\000Buhttps://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webpR\fvarchar(200)\022-\b\005\020\f\032\bcategory \000(\0000\000B\t\346\213\211\346\235\206\347\256\261R\fvarchar(200)\022\'\b\006\020\f\032\005brand \000(\0000\000B\006RIMOWAR\fvarchar(100)\022G\b\a\020\f\032\004spec \000(\0010\000B\'&#123;\&quot;\351\242\234\350\211\262\&quot;: \&quot;\347\272\242\350\211\262\&quot;, \&quot;\345\260\272\347\240\201\&quot;: \&quot;33\345\257\270\&quot;&#125;R\fvarchar(200)\022\032\b\b\020\004\032\006status \000(\0000\000B\0011R\003int\0226\b\t\020]\032\vcreate_time \000(\0000\000B\0232019-05-01 00:00:00R\bdatetime\0226\b\n\020]\032\vupdate_time \000(\0000\000B\0232019-05-01 00:00:00R\bdatetime&quot;
],raw=false,rawEntries=[]]
</code></pre><p>我们再去访问商品数据的展示页面查看数据是否被修改了</p><p>访问 uri：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdC9pdGVtLmh0bWw/aWQ9MTAwMDEjaW5kZXg=">http://localhost/item.html?id=10001#index</span></p><p>可以看到这个页面的数据也被修改了说明缓存同步成功了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211504526.png" alt="image-20231021150447258"></p><h1 id="八-总结多级缓存架构"><a class="anchor" href="#八-总结多级缓存架构">#</a> 八、总结多级缓存架构🎄</h1><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211510207.png" alt="image-20231021151019996"></p><p>有一个页面叫 item.html 放到了 windows 的 nginx 服务器上。它的 主要作用就是一个静态资源服务器和反向代理服务器。当用户通过浏览器来请求它时它就可以把页面返回给用户而浏览器在渲染时发现缺少数据就会发送 ajax 请求来查询数据。查询地址就是 item/10001 这时的 nginx 反向代理服务器不回去处理业务，只是做反向代理，所以它会把请求代理给 OPenResty 集群，想要去查询数据又有先去本地如果有则直接返回，本地共享词典数据只能在当前 nginx 中使用。如果我们部署成 OPenResty 集群它们之间的内存是不共享的，所以这里也可以采用通过 id 计算 hash 来路由指定集群服务器的方式这样就会保证 OPenResty 缓存一直生效。本地缓存如果未命中则去查询 redis 缓存，命中则返回，未命中则查询 tomcat。查询 tomcat 也是集群也做了 jvm 进程缓存，tomcat 服务器之间是不共享内存的所以还需要使用通过 id 计算 hash 值的方式来路由指定 tomcat 服务器</p><p>那么多级缓存完成后就会面临一个问题就是数据同步的问题。</p><p>mysql 的数据进行了修改 redis 和 tomcat 进程缓存和 nginx 缓存都需要做同步</p><p>在 OPenResty 中使用的超时同步，设置过期时间过期自动删除就变成新数据了，这种方式适合于更新频率较低的数据</p><p>而 redis 与 mysql 之间的数据同步采用了 canal 监听 mysql 的方式</p><h1 id="九-服务异步通讯"><a class="anchor" href="#九-服务异步通讯">#</a> 九、服务异步通讯🎄</h1><p>高级篇 - rabbitmq 的高级特性</p><p>我们已经学习过它的基本用法了，学习了如何利用 springamqp 收和发消息，但是收和发消息只是 mq 的最基本的功能。因为在收和发消息的过程当中还有很多问题需要思考需要去解决这时就需要使用 mq 的高级特性去解决了</p><p>MQ 的一些常见问题</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211532979.png" alt="image-20231021153238893"></p><p>学习内容：</p><ul><li>消息可靠性</li><li>死信交换机</li><li>惰性队列</li><li>MQ 集群</li></ul><h2 id="91-消息可靠性问题"><a class="anchor" href="#91-消息可靠性问题">#</a> 9.1、消息可靠性问题🌳</h2><p>消息从生产者发送到 exchange，再到 queue，再到消费者，有哪些导致消息丢失的可能性？</p><p>先来温习一下 mq 的整个流程</p><p>消息的发送者称为 publisher，它把消息投递给交换机 exchange，而交换机会根据 routingkey 将消息路由到队列 queue 中，而队列再把消息投递给消费者 consumer</p><p>在整个这样的流程当中消息可能会发生丢失</p><ul><li>发送时丢失：<ul><li>生产者发送的消息未送达 exchange</li><li>消息到达 exchange 后未达到 queue</li></ul></li><li>MQ 宕机，queue 将消息丢失</li><li>consumer 接收到消息后未消息就宕机</li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211536652.png" alt="image-20231021153606449"></p><p>针对上述问题我们来学习如下内容：</p><ul><li>生产者消息确认</li><li>消息持久化</li><li>消费者消息确认</li><li>消费失败重试机制</li></ul><h3 id="911-生产者确认机制"><a class="anchor" href="#911-生产者确认机制">#</a> 9.1.1、生产者确认机制🌲</h3><p>RabbitMQ 提供了 publisher confirm 机制来避免消息发送到 MQ 过程中丢失。消息发送到 MQ 以后，会返回一个结果给发送者，表示消息是否处理成功。结果有两种请求：</p><ul><li>publisher-confirm，发送者确认<ul><li>消息成功投递到交换机，返回 ack</li><li>消息未投递到交换机，返回 nack</li></ul></li><li>publisher-return，发送者回执<ul><li>消息投递到交换机了，但是没有路由到队列。返回 ACK，及路由失败原因。</li></ul></li></ul><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211546864.png" alt="image-20231021154614145"></p><blockquote><p>&lt;font color='red'&gt; 注意 &lt;/font&gt;：</p><p>确认机制发送消息时，需要给每个消息设置一个全局唯一 id，以区分不同消息，避免 ack 冲突</p></blockquote><p>引入 demo 工程</p><p>首先，需要引入项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZG91a2FpeGluL3R5cG9yYS5naXQ=">https://gitee.com/doukaixin/typora.git</span></p><p>拉取分支：mq-advanced-demo 代码演示</p><h2 id="92-springamqp实现生产者确认"><a class="anchor" href="#92-springamqp实现生产者确认">#</a> 9.2、SpringAMQP 实现生产者确认🌳</h2><p>1、在 publisher 这个微服务的 applicaiton.yml 中添加配置：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.249.128 <span class="token comment"># rabbitMQ 的 ip 地址</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">username</span><span class="token punctuation">:</span> itcast</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">#------------------------------------</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token key atrule">template</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></pre></td></tr></table></figure><p>配置说明：</p><ul><li>publishe-confirm-type：开启 publisher-confirm，这里支持两种类型：<ul><li>simple：同步等待 confirm 结果，直到超时</li><li>correlated：异步回调，定义 ConfirmCallback，MQ 返回结果时会回调这个 ConfirmCallback</li></ul></li><li>publish-returns：开启 publish-return 功能，同样是基于 callback 机制，不过是定义 ReturnCallback</li><li>template.mandatory：定义消息路由失败时的策略。true，则调用 ReturnCallback; false：则直接丢弃消息</li></ul><p>2、每个 RabbitTemplate 只能配置一个 ReturnCallback，因此需要在项目启动过程中配置：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//                         实现 Spring 工厂的通知</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 重写 Bean 工厂准备好后调用的函数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 取出 RabbitTempalte 的 Bean</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 配置 ReturnCallback</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 记录日志 &#123;&#125; 为占位符</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送到队列失败，响应码：&#123;&#125;，失败原因：&#123;&#125;，"</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token string">"交换机：&#123;&#125;，路由key：&#123;&#125;，消息：&#123;&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 如果有需要的话，重发消息</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>returncallback 是 exchange 路由不到 queue 时，才触发的回调</p><p>confirmcallback 是在消息达不到交换机时，才回调</p><p>3、发送消息，指定消息 ID，消息 ConfirmCallback</p><p>先使用 test 代码进行一下测试</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211718275.png" alt="image-20231021171827222"></p><p>发送消息的代码中，有 交换机，但是 Routingkey 不存在，所以我们需要去创建一下</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211719943.png" alt="image-20231021171807188"></p><p>点击 bind</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211719018.png" alt="image-20231021171942977"></p><p>但是！在发送消息的测试代码中以前是那样写的，但是现在要做消息确认机制所以就要多传递一个参数了</p><p>测试代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token annotation punctuation">@SpringBootTest</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token annotation punctuation">@Autowired</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage2SimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">String</span> routingKey <span class="token operator">=</span> <span class="token string">"simple.test"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 1.1. 准备 CorrelationData</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 1.2. 消息 ID</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 1.3. 准备 ConfirmCallback</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 成功的回调函数</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        correlationData<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>confirm <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 判断结果</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>confirm<span class="token punctuation">.</span><span class="token function">isAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// ACK</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"消息成功投递到交换机 ！消息ID: &#123;&#125;"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token comment">// NACK</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息投递到交换机失败了 ！ 消息ID: &#123;&#125;"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token comment">// 重发消息</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">// 失败的回调函数</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> throwable <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token comment">// 记录日志</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送失败 ! "</span><span class="token punctuation">,</span> throwable<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token comment">// 重发消息</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"amq.topic"</span><span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> message<span class="token punctuation">,</span>correlationData <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>运行这个测试代码</p><p>idea 控制台打印信息如下：</p><pre><code>消息成功投递到交换机 ！消息ID: a4abf2f4-85f5-4fdc-bb73-7be9ab91b6bd
</code></pre><p>查看消息队列是否接受到了一个消息并查看内容</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211737447.png" alt="image-20231021173713091"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211737796.png" alt="image-20231021173730615"></p><blockquote><p><strong>总结</strong>：</p><p>SpringAMQP 中处理消息确认的几种情况：</p><ul><li>publisher-confirm<ul><li>消息成功发送到 exchange，返回 ack</li><li>消息发送失败，没有到达交换机，返回 nack</li><li>消息发送过程中出现异常，没有收到回执</li></ul></li><li>消息成功发送到 exchange，但没有路由到 queue<ul><li>调用 ReturnCallback</li></ul></li></ul></blockquote><p>以上就是生产确认的机制了。通过这些机制就能够确认消息 能够到达消息队列</p><h2 id="93-消息持久化"><a class="anchor" href="#93-消息持久化">#</a> 9.3、消息持久化🌳</h2><p>由于 RabbitMQ 默认是内存存储，如果此时 mq 发生了宕机，消息也是有可能丢失的。要想让消息真正安全，我们必须确保这个消息能够做到持久化。也就是把它写入到磁盘中</p><p>在消费者的 config 类中进行配置</p><p>1、交换机持久化：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">simpleExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 三个参数：交换机名称，是否持久化，当没有 queue 与其绑定时是否自动删除</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"simple.direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2、队列持久化</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">simpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 使用 QueueBuilder 构建队列，durable 就是持久化的</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span><span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动服务进行测试，结果如下：</p><p>队列</p><p>其中的 D 就是 durable 就是持久化的意思</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211756121.png" alt="image-20231021175655932"></p><p>交换机</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211759449.png" alt="image-20231021175939976"></p><p>关闭所有服务器</p><p>发送一下消息进行测试一下消息是否也能持久化</p><p>我们向 simple.queue 中发送一条消息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211831349.png" alt="image-20231021183122204"></p><p>此时队列中就会存留一条消息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211833155.png" alt="image-20231021183339726"></p><p>那么现在我们队列里面有消息了，并且队列已经持久化了，我们再去重启 mq 来测试一下</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># docker restart mq</span></pre></td></tr><tr><td data-num="2"></td><td><pre>mq</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><p>回到页面中进行查看</p><p>可以看到消息 没了！</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211835842.png" alt="image-20231021183522398"></p><p>这就证明消息没有持久化，那我们的目的是让消息也能持久啊，那怎么办？</p><p>3、消息持久化，SpringAMQP 中的消息默认是持久的，可以通过 MessageProperties 中的 DeliveryMode 来指定：</p><p>在测试代码中进行编写：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDurableMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, spring"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                             <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 消息体</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span> <span class="token comment">// 持久化</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动成功后查看队列情况：</p><p>可以看到队列中就有了一条消息了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211842026.png" alt="image-20231021184255870"></p><p>在队列的详情页面里面的 get message 中可以看到 delivery_mode：2 表示消息持久化</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211844251.png" alt="image-20231021184420061"></p><p>重启 mq 测试消息是否真的就是持久化了：</p><figure class="highlight sh"><figcaption data-lang="sh"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment"># docker restart mq</span></pre></td></tr><tr><td data-num="2"></td><td><pre>mq</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@localhost nginx<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr></table></figure><p>访问 mq 队里情况：</p><p>可以看到这条消息还存在着</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310211845144.png" alt="image-20231021184553048"></p><h2 id="94-消费者确认"><a class="anchor" href="#94-消费者确认">#</a> 9.4、消费者确认🌳</h2><p>RabbitMQ 支持消费者确认机制，即：消费者处理消息后可以向 MQ 发送 ack 回执，MQ 收到 ack 回执后才会删除消息。而 SpringAMQP 则允许配置三种确认模式：</p><ul><li>manual：手动 ack，需要在业务代码结束后，调用 api 发送 ack</li><li>auto：自动 ack，由 Spring 检测 listener 代码是否出现异常，没有异常则返回 ack；抛出异常则返回 nack</li><li>none：关闭 ack，MQ 假定消费者获取消息后会成功处理，因此消息投递后立即被删除</li></ul><p>配置方式是修改 application.yml 文件，添加下面配置：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.249.128 <span class="token comment"># rabbitMQ 的 ip 地址</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">username</span><span class="token punctuation">:</span> itcast</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">listener</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token key atrule">simple</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto <span class="token comment"># 自动 ack</span></pre></td></tr></table></figure><p>先看下 mq 的队列情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310212025971.png" alt="image-20231021202521333"></p><p>队列中有一条消息</p><p>我们在 consumer 的消费代码编写一个异常</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Component</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token operator">*</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到simple.queue的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消费者处理消息成功 ！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>配置完成后启动 consumer 服务进行测试</p><p>此时程序走到 debug 处，没有执行完毕我们看下现在的队列情况</p><p>可以看到它没有删除这条消息而是标记为了 Unacked</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310212027453.png" alt="image-20231021202727506"></p><p>如果程序不进行一直等待则会变回原来的状态</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310212029138.png" alt="image-20231021202909987"></p><p>java 代码程序往下走就会抛出异常，但是它会进行重新投递</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310212048599.gif" alt="test"></p><p>但是我们并不希望它就这样失败了就无脑重试那怎么办呢？看下面的内容。</p><h2 id="95-失败重试机制"><a class="anchor" href="#95-失败重试机制">#</a> 9.5、失败重试机制🌳</h2><p>当消费者出现异常后，消费会不断 requue (重新入队) 到队列，再重新发送给消费者，然后再次异常，再次 requeue，无限循环，导致 mq 的消息处理飙升，带来不必要的压力：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310212051338.png" alt="image-20231021205137135"></p><p>我们可以利用 Spring 的 retry 机制，在消费者出现异常时利用本地重试，而不是无限制的 requeue 到 mq 队列。</p><p>当然本地重试也不是无限让它一直重试</p><p>在消费者服务中进行配置：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spring</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.249.128 <span class="token comment"># rabbitMQ 的 ip 地址</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">username</span><span class="token punctuation">:</span> itcast</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">listener</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token key atrule">simple</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto</pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">#------------------------------------------------------</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token key atrule">retry</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>          <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启消费者失败重试</span></pre></td></tr><tr><td data-num="15"></td><td><pre>          <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> <span class="token number">1000</span> <span class="token comment"># 初始的失败等待时长为 1 秒</span></pre></td></tr><tr><td data-num="16"></td><td><pre>          <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment"># 下次失败的等待时长倍数，下次等待时长 = multiplier *last-interval</span></pre></td></tr><tr><td data-num="17"></td><td><pre>          <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">4</span> <span class="token comment"># 最大重试次数</span></pre></td></tr><tr><td data-num="18"></td><td><pre>          <span class="token key atrule">stateless</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># true 无状态；false 有状态。如果业务中包含事务，这里改为 false</span></pre></td></tr></table></figure><p>启动消费者服务后进行测试 idea 控制台打印如下：</p><p>报了一个异常，说重试次数耗尽了</p><pre><code>mqp.rabbit.support.ListenerExecutionFailedException: Retry Policy Exhausted
	at org.springframework.amqp.rabbit.retry.RejectAndDontRequeueRecoverer.recover(RejectAndDontRequeueRecoverer.java:45) ~[spring-rabbit-2.2.15.RELEASE.jar:2.2.15.RELEASE]
	at org.springframework.amqp.rabbit.config.StatelessRetryOperationsInterceptorFactoryBean.lambda$createRecoverer$0(StatelessRetryOperationsInterceptorFactoryBean.java:74) ~[spring-rabbit-2.2.15.RELEASE.jar:2.2.15.RELEASE]
	at org.springframework.retry.interceptor.RetryOperationsInterceptor$ItemRecovererCallback.recover(RetryOperationsInterceptor.java:141) ~[spring-retry-1.2.5.RELEASE.jar:na]
	at org.springframework.retry.support.RetryTemplate.handleRetryExhausted(RetryTemplate.java:512) ~[spring-retry-1.2.5.RELEASE.jar:na]
</code></pre><p>这条消息就会被丢弃掉</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310220940740.png" alt="image-20231022094032330"></p><h3 id="951-消费者失败消息处理策略"><a class="anchor" href="#951-消费者失败消息处理策略">#</a> 9.5.1、消费者失败消息处理策略🌲</h3><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有 MessageRecoverer 接口来处理，它包含三种不同的实现：</p><p>1、RejectAndDontRequeueRecoverer：重试耗尽后，直接 reject，丢弃消息。默认就是这种方式</p><p>2、ImmediateRequeueMessageRecoverer：重试耗尽后，返回 nack，消息重新入队</p><p>3、RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221014285.png" alt="image-20231022101421805"></p><p>测试下 RepublishMessageRcoverer 处理模式：</p><p>1、首先，定义接收失败消息的交换机，队列及其绑定关系：</p><p>2、然后定义 RepublishMessageRecoverer：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErrorMessageConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"error.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"error.queue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">errorMessageBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MessageRecoverer</span> <span class="token function">republishMessageRecoverer</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RepublishMessageRecoverer</span><span class="token punctuation">(</span>rabbitTemplate<span class="token punctuation">,</span> <span class="token string">"error.direct"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动消费者服务查看 mq 的交换机和队列情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221027869.png" alt="image-20231022102732042"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221027294.png" alt="image-20231022102744943"></p><p>发送一条消息进行测试，找到 simple.queue 进行发送消息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221030573.png" alt="image-20231022103002600"></p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221032487.png" alt="image-20231022103250120"></p><p>idea 控制台打印情况</p><pre><code>消费者接收到simple.queue的消息：【hello spring !】
消费者接收到simple.queue的消息：【hello spring !】
消费者接收到simple.queue的消息：【hello spring !】
10:30:18:538  WARN 6996 --- [ntContainer#0-1] o.s.a.r.retry.RepublishMessageRecoverer  : Republishing failed message to exchange 'error.direct' with routing key error
</code></pre><p>然后再查看队列情况</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221031933.png" alt="image-20231022103105401"></p><p>在 error.queue 队列的详细消息中可以看到报错的信息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221032636.png" alt="image-20231022103202192"></p><blockquote><p><strong>总结</strong>:</p><p>如何确保 RabbitMQ 消息的可靠性？</p><ol><li>开启生产者确认机制，确保生产者的消息能到达队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失</li><li>开启消费者确认机制为 auto，由 spring 确认消息处理成功后完成 ack</li><li>开启消费者失败重试机制，并设置 MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ol></blockquote><h1 id="十-死信交换机"><a class="anchor" href="#十-死信交换机">#</a> 十、死信交换机🎄</h1><ul><li>初识死信交换机</li><li>TTL</li><li>延迟队列</li></ul><h2 id="101-初识死信交换机"><a class="anchor" href="#101-初识死信交换机">#</a> 10.1、初识死信交换机🌳</h2><p>当一个队列中的消息满足下列情况之一时，可以称为 &lt;font color='red'&gt; 死信 (dead letter)&lt;/font&gt;：</p><p>1、消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false</p><p>2、消息是一个过期消息，超时无人消费</p><p>3、要投递的队列消息堆积满了，最早的消息可能成为死信</p><p>如果该队列配置了 dead-letter-exchange 属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为 &lt;font color='red'&gt; 死信交换机 &lt;/font&gt;. (Dead Letter Exchange ， 简称 DLX)。</p><p>如果有一个消息发送到了消费者，假设消费者采用默认的重试机制不断重试直到次数耗尽就会将消息拒绝，而消息一旦被拒绝默认情况下就会被丢弃了。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221043785.png" alt="image-20231022104354267"></p><p>如果说不想丢失就必须给 simple.queue 这个队列绑定死信交换机，这时消息就不会被丢弃了而是变成一个死信再回到队列，队列再投递到死信交换机。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221046386.png" alt="image-20231022104628552"></p><p>交换机不能存储消息那么为了保证消息不丢失，还需要绑定一个队列，这个消息就会到达 dl.queue 队列中称为死信队列</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221049450.png" alt="image-20231022104901077"></p><p>这里与上述的 消费者失败消息处理策略 一样，但是还是有差异的，就是在上述方式中，所有的失败消息都是有消费者来做投递的。而在现在的方式中是由队列做投递的</p><p>如果只是做消息的兜底处理建议使用上述方式，如果是做消息兜底处理以及额外的功能建议使用当前方式</p><blockquote><p><strong>总结</strong>：</p><p>什么样的消息会成为死信？</p><p>1、消息被消费者 reject 或者返回 nack</p><p>2、消息超时未消费</p><p>3、队列满了</p><p>如何给队列绑定死信交换机？</p><p>1、给队列设置 dead-letter-exchange 属性，指定一个交换机</p><p>2、给队列设置 dead-letter-routing-key 属性，设置死信交换机与死信队列的 RoutingKey</p></blockquote><h2 id="102-ttl"><a class="anchor" href="#102-ttl">#</a> 10.2、TTL🌳</h2><p>TTL，也就是 Time-To-Live。如果一个队列中的消息 TTL 结束仍未消费，则会变为死信，TTL 超时分为两种情况：</p><p>1、消息所在的队列设置了存活时间</p><p>2、消息本身设置了存活时间</p><p>假如一个消息自己设置了时间为 5000 毫秒到消息发出去，到达了队列的时候就会开始计时，计时结束后这个消息就会成为死信，从而投递到死信交换机 最终到达了死信队列。这时如果恰好有一个消费者在监听死信队列它就会收到这个死信消息</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221102065.gif" alt="test"></p><p>我们声明一组死信交换机和队列，基于注解方式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"dl.queue"</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"dl.direct"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   key <span class="token operator">=</span> <span class="token string">"dl"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDlQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消费者接收到了dl.queue的延迟消息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>要给队列设置超时时间，需要在声明队列的类中编写如下代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TTLMessageConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">ttlDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"ttl.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">ttlQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"ttl.queue"</span><span class="token punctuation">)</span> <span class="token comment">// 指定队列名称，并持久化</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">ttl</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token comment">// 设置队列的超时时间，10 秒</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">deadLetterExchange</span><span class="token punctuation">(</span><span class="token string">"dl.direct"</span><span class="token punctuation">)</span> <span class="token comment">// 指定死信交换机</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">deadLetterRoutingKey</span><span class="token punctuation">(</span><span class="token string">"dl"</span><span class="token punctuation">)</span> <span class="token comment">// 指定死信 RoutingKey</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">ttlBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">ttlQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">ttlDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token string">"ttl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编写发布者代码：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTTLMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, ttl message"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                             <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"ttl.direct"</span><span class="token punctuation">,</span> <span class="token string">"ttl"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">// 3. 记录日志</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息已经成功发送了 ！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动服务进行测试：</p><p>消息发布者发送出去的时间为：46</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221122622.png" alt="image-20231022112215176"></p><p>消息接收者接收到消息时间为：56</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221122464.png" alt="image-20231022112249139"></p><p>延迟了 10 秒钟的时间，这样延迟消息就实现了</p><p>上述是基于队列实现的延迟消息，下面来学习给消息设置延迟时间</p><p>发送消息时，给消息本身设置超时时间：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTTLMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, ttl message"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                             <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setExpiration</span><span class="token punctuation">(</span><span class="token string">"5000"</span><span class="token punctuation">)</span> <span class="token comment">// 设置消息的延迟时间为 5 秒</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"ttl.direct"</span><span class="token punctuation">,</span> <span class="token string">"ttl"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token comment">// 3. 记录日志</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息已经成功发送了 ！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>启动服务器测试查看消息延迟多久时间：</p><p>发送者发送消息时间为：16</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221127666.png" alt="image-20231022112741830"></p><p>接受者收到消息时间为：21</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221128275.png" alt="image-20231022112808892"></p><p>消息延迟了 5 秒的时间，<mark>当队列与消息本身都设置了延迟时间时，以最短的时间为准</mark>。</p><blockquote><p><strong>总结</strong>：</p><p>消息超时的两种方式是？</p><p>1、给队列设置 ttl 属性，进入队列后超过 ttl 时间的消息变为死信</p><p>2、给消息设置 ttl 属性，队列接收到消息超过 ttl 时间后变为死信</p><p>3、两者共存时，以时间短的 ttl 为准</p><p>如何实现发送一个消息 20 秒后消费者才收到消息？</p><p>1、给消息的目标队列指定死信交换机</p><p>2、消费者监听与死信交换机绑定的队列</p><p>3、发送消息时给消息设置 tll 为 20 秒</p></blockquote><p>下面学习延迟队列的插件来实现延迟消息</p><h2 id="103-延迟队列"><a class="anchor" href="#103-延迟队列">#</a> 10.3、延迟队列🌳</h2><p>利用 TTL 结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为 &lt;font color='red'&gt; 延迟队列 (Delay Queue) 模式 &lt;/font&gt;.</p><p>延迟队列的使用场景包括：</p><p>1、延迟发送短信</p><p>2、用户下单，如果用户在 15 分钟内未支付，则自动取消</p><p>3、预约工作会议，20 分钟后自动通知所有参会人员</p><h3 id="1031-延迟队列插件"><a class="anchor" href="#1031-延迟队列插件">#</a> 10.3.1、延迟队列插件🌲</h3><p>因为延迟队列的需求非常多，所以 RabbitMQ 的官方也推出了一个插件，原生支持延迟队列效果。</p><p>详细安装查看文章：<a href="../RabbitMQ/%E9%AB%98%E7%BA%A7%E7%AF%87/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.md">RabbitMQ 部署指南</a>.</p><h3 id="1032-springamqp使用延迟队列插件"><a class="anchor" href="#1032-springamqp使用延迟队列插件">#</a> 10.3.2、SpringAMQP 使用延迟队列插件🌲</h3><p>DelayExchange 的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定 delayed 属性为 true 即可</p><p>基于注解方式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"delay.queue"</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"delay.direct"</span><span class="token punctuation">,</span> delayed <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   key <span class="token operator">=</span> <span class="token string">"delay"</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDelayExchange</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消费者接收到了delay.queue的延迟消息 , &#123;&#125;"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>先启动消费者服务让它先等着</p><p>查看 mq 的交换机情况：</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221614876.png" alt="image-20231022161400235"></p><p>然后我们向这个 delay 为 true 的交换机中发送消息，一定要给消息添加一个 header: x-delay，值为延迟的时间，单位为毫秒：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSndDelayMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, ttl message"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                                             <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">PERSISTENT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"x-delay"</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token comment">// 设置消息的延迟时间为 5 秒</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token comment">// 1.1. 准备 CorrelationData</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">// 1.2. 消息 ID</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   <span class="token class-name">CorrelationData</span> correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"delay.direct"</span><span class="token punctuation">,</span> <span class="token string">"delay"</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span>correlationData <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>再启动发布者测试代码进行发布：</p><p>发布后测试代码会提示一个错误但是这个错误是没有问题的，因为延迟它会误以为需要重试，就会触发重发机制。但是我们不需要对延迟消息进行重试，所以我们需要对其做一下判断</p><pre><code>ERROR 17588 --- [nectionFactory1] cn.itcast.mq.config.CommonConfig         : 消息发送到队列失败，响应码：312，失败原因：NO_ROUTE，交换机：delay.direct，路由key：delay，消息：(Body:'[B@71c09e9d(byte[18])' MessageProperties [headers=&#123;spring_returned_message_correlation=b85f2836-22b6-406e-9e49-d5f44a07af32&#125;, contentType=application/octet-stream, contentLength=0, receivedDeliveryMode=PERSISTENT, priority=0, receivedDelay=5000, deliveryTag=0])
</code></pre><p>对 receivedDelay 进行判断是否存在值</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Slf4j</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//                         实现 Spring 工厂的通知</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 重写 Bean 工厂准备好后调用的函数</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 取出 RabbitTempalte 的 Bean</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 配置 ReturnCallback</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">// 判断是否是延迟消息</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getReceivedDelay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 是一个延迟消息，忽略这个错误提示</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 记录日志 &#123;&#125; 为占位符</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送到队列失败，响应码：&#123;&#125;，失败原因：&#123;&#125;，"</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token string">"交换机：&#123;&#125;，路由key：&#123;&#125;，消息：&#123;&#125;"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">// 如果有需要的话，重发消息</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在运行发布者测试代码后打印如下：</p><p>可以看到就没有错误提示了，也就解决了明明没有错误却重试的问题了</p><pre><code>16:22:35:703  INFO 2568 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : 消息发送成功
</code></pre><blockquote><p><strong>总结</strong>：</p><p>延迟队列插件的使用步骤包括哪些？</p><p>1、声明一个交换机，添加 delayed 属性为 true</p><p>2、发送消息时，添加 x-delay 头，值为超时时间</p></blockquote><h1 id="十一-惰性队列"><a class="anchor" href="#十一-惰性队列">#</a> 十一、惰性队列🎄</h1><ul><li>消息堆积问题</li><li>惰性队列</li></ul><h2 id="111-消息堆积问题"><a class="anchor" href="#111-消息堆积问题">#</a> 11.1、消息堆积问题🌳</h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。最早接收到的消息，可能就会成为死信，会被丢弃，这就是 &lt;font color='red'&gt; 消息堆积 &lt;/font &gt; 问题。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221629911.gif" alt="test"></p><p><strong>解决消息堆积有三种思路</strong>：</p><p>1、增加更多消费者，提高消费速度</p><p>2、在消费者内开启线程池加快消息处理速度</p><p>3、扩大队列容积，提高堆积上限</p><h2 id="112-惰性队列"><a class="anchor" href="#112-惰性队列">#</a> 11.2、惰性队列🌳</h2><p>从 RabbitMQ 的 3.6.0 版本开始，就增加了 Lazy Queues 的概念，也就是 &lt;font color='red'&gt; 惰性队列 &lt;/font&gt;.</p><p>惰性队列的特征如下：</p><p>1、接受到消息后直接存入磁盘而非内存</p><p>2、消费者要消费时才会从磁盘中读取并加载到内存</p><p>3、支持数百万条的消息存储</p><p>而要设置一个队列为惰性队列，只需要在声明队列时，指定 x-queue-mode 属性为 lazy 即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>rabbitmqctl set_policy <span class="token class-name">Lazy</span> <span class="token string">"^lazy-queue$"</span> '<span class="token punctuation">&#123;</span><span class="token string">"queue-mode"</span><span class="token operator">:</span> <span class="token string">"lazy"</span><span class="token punctuation">&#125;</span>' <span class="token operator">--</span>apply<span class="token operator">-</span><span class="token keyword">to</span> <span class="token namespace">queues</span></pre></td></tr></table></figure><p>用 SpringAMQP 声明惰性队列分两种方式：</p><p>@Bean 方式</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Configuration</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyConfig</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token annotation punctuation">@Bean</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">lazyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">QueueBuilder</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"lazy.queue"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启 x-queue-mode 为 lazy</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queuesToDeclare <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	name <span class="token operator">=</span> <span class="token string">"lazy.queue"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   durable <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token string">"arguments"</span> <span class="token operator">=</span> <span class="token annotation punctuation">@Argument</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"x-queue-mode"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"lazy"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenLazyQueue</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接收到 lazy.queue的消息: &#123;&#125;"</span> <span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编写测试代码进行百万消息测试：</p><p>先对 delay.direct 消息队列进行百万消息的测试</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLazyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, ttl message"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                                <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">NON_PERSISTENT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"delay.direct"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到它没有存储磁盘而却呢爆红了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221657687.png" alt="image-20231022165706663"></p><p>下面测试惰性队列的情况：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLazyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token comment">// 1. 准备消息</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span><span class="token string">"hello, ttl message"</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                                <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span><span class="token class-name">MessageDeliveryMode</span><span class="token punctuation">.</span><span class="token constant">NON_PERSISTENT</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>         <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token comment">// 2. 发送消息</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"lazy.queue"</span><span class="token punctuation">,</span>  message<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到消息都存储到了磁盘中，这样性能就会比较好</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221702921.png" alt="image-20231022170213243"></p><blockquote><p><strong>总结</strong>：</p><p>消息堆积问题的解决方案？</p><p>1、队列上绑定多个消费者，提高消费速度</p><p>2、给消费者开启线程池，提高消费速度</p><p>3、使用惰性队列，可以再 mq 中保存更多消息</p><p>惰性队列的优点有哪些？</p><p>1、基于磁盘存储，消息上限高</p><p>2、没有间歇性的 page-out，性能比较稳定</p><p>惰性队列的缺点有哪些？</p><p>1、基于磁盘存储，消息时效性会降低</p><p>2、性能受限于磁盘的 IO</p></blockquote><h1 id="十二-mq集群"><a class="anchor" href="#十二-mq集群">#</a> 十二、MQ 集群🎄</h1><ul><li>集群分类</li><li>普通集群</li><li>镜像集群</li><li>仲载队列</li></ul><h2 id="121-集群分类"><a class="anchor" href="#121-集群分类">#</a> 12.1、集群分类🌳</h2><p>RabbitMQ 是基于 Erlang 语言编写，而 Erlang 又是一个面向并发的语言，天然支持集群模式，搭建比较简单。RabbitMQ 的集群有两种模式：</p><p>1、<mark>普通集群</mark>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</p><p>2、<mark>镜像集群</mark>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</p><p>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在 RabbitMQ 的 3.8 版本以后，推出了新的功能：<mark>仲载队列</mark> 来代替镜像集群，底层采用 Raft 协议确保主从的数据一致性。</p><h3 id="1211-普通集群"><a class="anchor" href="#1211-普通集群">#</a> 12.1.1、普通集群🌲</h3><p>普通集群，或者叫标准集群 (classic cluster) ，具备下列特征：</p><ul><li>会在集群的各个节点间共享部分数据， 包括：交换机，队列元信息。不包含队列中的消息。</li></ul><p>比如说有三台 RabbitMQ，然后创建一个交换机</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221716648.png" alt="image-20231022171634984"></p><p>由于交换机可以在各个节点间共享，所以将来这三个节点都能看到</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221717792.png" alt="image-20231022171726859"></p><p>但是，现在要创建一个队列这个队列叫 queue1 它是在第一个交换机上声明的，此时队列是不共享的。但是有队列元信息，比如说 queue1 它会有其它节点上有 queue1 的名字，位置等信息。相当于是一个引用</p><ul><li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li></ul><p>比如说现在有一个消费者绑定到了 queue1 但是在访问的时候不小心访问到了第三个节点。这个节点上没有 queue1 但是有 queue1 的元信息，当获取数据的时候就会根据第三节点有 queue1 的位置信息来找到 queue1 然后拿到数据</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221722945.png" alt="image-20231022172221484"></p><ul><li>队列所在节点宕机，队列中的消息就会丢失</li></ul><p>比如说 queue1 挂了，因为第三节点和 queue1 是引用关系再来取数据的时候就取不到了</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221723703.png" alt="image-20231022172351386"></p><h4 id="12111-搭建普通集群"><a class="anchor" href="#12111-搭建普通集群">#</a> 12.1.1.1、搭建普通集群🌴</h4><p>搭建普通集群可以参考文章：<a href="../RabbitMQ/%E9%AB%98%E7%BA%A7%E7%AF%87/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.md">RabbitMQ 部署指南</a>.</p><h3 id="1212-镜像集群"><a class="anchor" href="#1212-镜像集群">#</a> 12.1.2、镜像集群🌲</h3><p>比方说，三个节点，交换机都能看到。那队列呢这时就要看你是不是镜像了。比方说在 queue1 这个节点上创建了一个队列。因为是在节点 1 上创建的 queue1 队列所以节点 1 就是 queue1 的主节点，然后我们还可以挑出一个镜像节点。比如说在节点二上做一个镜像，那么节点二就会找节点一去同步 queue1 的所有数据。这样它俩的数据就共享了。</p><p>而主节点和镜像节点是可以互相备份的</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221753072.png" alt="image-20231022175329422"></p><p>镜像集群：本质是主从模式，具备下面的特征：</p><p>1、交换机，队列，队列中的消息会在各个 mq 的镜像节点之间同步备份。</p><p>2、创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</p><p>3、一个队列的主节点可能是另一个队列的镜像节点</p><p>4、所有操作都是主节点完成，然后同步给镜像节点</p><p>5、主宕机后，镜像节点会替代成新的主</p><p>比方说 queue1 它的镜像节点是在 queue2 上，queue2 这个队列是在节点 2 上的，但是它可以再节点 3 上备份，而 queue3 是在节点 3 上，而它的镜像节点是在节点 1 上。</p><p><img data-src="https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202310221942543.png" alt="image-20231022194205210"></p><h4 id="12121-搭建镜像集群"><a class="anchor" href="#12121-搭建镜像集群">#</a> 12.1.2.1、搭建镜像集群🌴</h4><p>搭建镜像集群可以参考文章：<a href="../RabbitMQ/%E9%AB%98%E7%BA%A7%E7%AF%87/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.md">RabbitMQ 部署指南</a>.</p><h3 id="1213-仲载队列"><a class="anchor" href="#1213-仲载队列">#</a> 12.1.3、仲载队列🌲</h3><p>仲载队列：仲载队列是在 3.8 版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p><p>1、与镜像队列一样，都是主从模式，支持主从数据同步</p><p>2、使用非常简单，没有复杂的配置</p><p>3、主从同步基于 Raft 协议，强一致</p><h4 id="12131-仲载队列搭建"><a class="anchor" href="#12131-仲载队列搭建">#</a> 12.1.3.1、仲载队列搭建🌴</h4><p>仲载队列搭建可以参考文章：<a href="../RabbitMQ/%E9%AB%98%E7%BA%A7%E7%AF%87/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.md">RabbitMQ 部署指南</a>.</p><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91/" rel="tag"><i class="ic i-tag"></i> 计算机学科</a> <a href="/tags/springcloud/" rel="tag"><i class="ic i-tag"></i> springcloud</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-01-06 10:44:16" itemprop="dateModified" datetime="2024-01-06T10:44:16+08:00">2024-01-06</time> </span><span id="computer-science/java/spring/springcloud/springcloud-高级/微服务高级篇/" class="item leancloud_visitors" data-flag-title="SpringCloud 高级篇" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="D 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="D 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="D 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Dkx： </strong>D <i class="ic i-at"><em>@</em></i>D の Java</li><li class="link"><strong>本文链接：</strong> <a href="https://pigpigletsgo.github.io/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E7%BA%A7%E7%AF%87/" title="SpringCloud 高级篇">https://pigpigletsgo.github.io/computer-science/java/spring/springcloud/springcloud-高级/微服务高级篇/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/java/spring/springcloud/RabbitMQ/%E9%AB%98%E7%BA%A7/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;a8d0ac76b87f7593653e29559d61b32d.jpg" title="RabbitMQ部署指南-集群部署"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 高级</span><h3>RabbitMQ部署指南-集群部署</h3></a></div><div class="item right"><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/canal/%E5%AE%89%E8%A3%85Canal/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;6c7f469735b99a6a04773240429dc7e0.jpg" title="安装和配置Canal"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> canal</span><h3>安装和配置Canal</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.</span> <span class="toc-text">一、微服务保护🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%88%9D%E5%A7%8Bsentinel"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、初始 Sentinel🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#111-%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1、雪崩问题🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-%E8%A7%A3%E5%86%B3%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2、解决雪崩问题🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3、服务保护技术对比🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%AE%A4%E8%AF%86sentinel"><span class="toc-number">1.2.</span> <span class="toc-text">1.2、认识 Sentinel🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121-%E5%AE%89%E8%A3%85sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1、安装 Sentinel 控制台🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AE%89%E8%A3%85sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1.3、安装 Sentinel 控制台🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Esentinel%E6%95%B4%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text">1.4、微服务与 Sentinel 整合🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#141-%E5%BC%95%E5%85%A5cloud-demo"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1、引入 cloud-demo🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B4%E5%90%88sentinel"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2、微服务整合 Sentinel🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">1.5、限流规则🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#151-%E8%94%9F%E7%82%B9%E9%93%BE%E8%B7%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1、蔟点链路🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1511-%E6%A1%88%E4%BE%8B%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.5.1.1、案例，流控规则入门案例🌴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2、流控模式🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1521-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E5%85%B3%E8%81%94"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.5.2.1、流控模式 - 关联🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15211-%E6%A1%88%E4%BE%8B%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E5%85%B3%E8%81%94"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">1.5.2.1.1、案例，流控模式 - 关联🎋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1523-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E9%93%BE%E8%B7%AF"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">1.5.2.3、流控模式 - 链路🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15231-%E6%A1%88%E4%BE%8B%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E9%93%BE%E8%B7%AF"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">1.5.2.3.1、案例，流控模式 - 链路🎋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1524-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">1.5.2.4、流控效果🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15241-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-warm-up"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">1.5.2.4.1、流控效果 - warm up🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#152411-%E6%A1%88%E4%BE%8B%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-warm-up"><span class="toc-number">1.5.2.3.1.1.</span> <span class="toc-text">1.5.2.4.1.1、案例，流控效果 - warm up🎋</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15242-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text">1.5.2.4.2、流控效果 - 排队等待🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#152421-%E6%A1%88%E4%BE%8B%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">1.5.2.3.2.1.</span> <span class="toc-text">1.5.2.4.2.1、案例，流控效果 - 排队等待🎋</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.5.3、热点参数限流🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1531-%E9%85%8D%E7%BD%AE%E7%83%AD%E7%82%B9%E9%99%90%E6%B5%81"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1.5.3.1、配置热点限流🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1532-%E9%85%8D%E7%BD%AE%E7%83%AD%E7%82%B9%E9%99%90%E6%B5%81%E9%AB%98%E7%BA%A7%E9%A1%B9"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">1.5.3.2、配置热点限流高级项🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1533-%E6%A1%88%E4%BE%8B%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">1.5.3.3、案例，热点参数限流🌴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%9A%94%E7%A6%BB%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="toc-number">1.6.</span> <span class="toc-text">1.6、隔离和降级🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#161-feign%E6%95%B4%E5%90%88sentinel"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1、Feign 整合 Sentinel🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2、线程隔离🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1621-%E4%B8%A4%E8%80%85%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1.6.2.1、两者的优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">线程池隔离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">信号量隔离</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1622-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB-%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">1.6.2.2、线程隔离 (舱壁模式)🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16221-%E6%A1%88%E4%BE%8B%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB-%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">1.6.2.2.1、案例，线程隔离 (舱壁模式)🎋</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#163-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">1.6.3.</span> <span class="toc-text">1.6.3、熔断降级🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1631-%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5-%E6%85%A2%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1.6.3.1、熔断策略 - 慢调用🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16311-%E6%A1%88%E4%BE%8B%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5-%E6%85%A2%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">1.6.3.1.1、案例，熔断策略 - 慢调用🎋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1632-%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5-%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B%E5%BC%82%E5%B8%B8%E6%95%B0"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">1.6.3.2、熔断策略 - 异常比例，异常数🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16321-%E6%A1%88%E4%BE%8B%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5-%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B"><span class="toc-number">1.6.3.2.1.</span> <span class="toc-text">1.6.3.2.1、案例，熔断策略 - 异常比例🎋</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text">1.7、授权规则🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#171-%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.7.1、授权规则🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#172-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C"><span class="toc-number">1.7.2.</span> <span class="toc-text">1.7.2、自定义异常结果🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">1.8、规则持久化🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#181-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F-pull%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.8.1、规则管理模式 - pull 模式🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#182-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F-push%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">1.8.2、规则管理模式 - push 模式🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#183-%E5%AE%9E%E7%8E%B0push%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">1.8.3、实现 push 模式🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">二、分布式事务🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、分布式服务案例🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%BC%94%E7%A4%BA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、演示分布式事务问题 🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、理论基础🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-cap%E5%AE%9A%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1、CAP 定理🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2311-cap%E5%AE%9A%E7%90%86-consistency"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">2.3.1.1、CAP 定理 - Consistency🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2312-cap%E5%AE%9A%E7%90%86-availability"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2.3.1.2、CAP 定理 - Availability🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2313-cap%E5%AE%9A%E7%90%86-partition-tolerance"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">2.3.1.3、CAP 定理 - Partition tolerance🌴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-base%E7%90%86%E8%AE%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2、BASE 理论🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2321-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">2.3.2.1、分布式事务模型🌴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%88%9D%E5%A7%8Bseata"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、初始 Seata🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241-%E9%83%A8%E7%BD%B2tc%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1、部署 TC 服务🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%89%8B%E5%8A%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2、手动实践🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2421-xa%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">2.4.2.1、XA 模式原理🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2422-seata%E7%9A%84xa%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">2.4.2.2、seata 的 XA 模式🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2423-%E5%AE%9E%E7%8E%B0xa%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">2.4.2.3、实现 XA 模式🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2424-at%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">2.4.2.4、AT 模式原理🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#24241-at%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.4.1.</span> <span class="toc-text">2.4.2.4.1、AT 模式的脏写问题🎋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2425-%E5%AE%9E%E7%8E%B0at%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">2.4.2.5、实现 AT 模式🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2426-tcc%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">2.4.2.6、TCC 模式原理🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#24261-%E6%A1%88%E4%BE%8B%E6%94%B9%E9%80%A0account-service%E6%9C%8D%E5%8A%A1%E5%88%A9%E7%94%A8tcc%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.4.2.6.1.</span> <span class="toc-text">2.4.2.6.1、案例，改造 account-service 服务，利用 TCC 实现分布式事务🎋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24262-tcc%E7%9A%84%E7%A9%BA%E5%9B%9E%E6%BB%9A%E5%92%8C%E4%B8%9A%E5%8A%A1%E6%82%AC%E6%8C%82"><span class="toc-number">2.4.2.6.2.</span> <span class="toc-text">2.4.2.6.2、TCC 的空回滚和业务悬挂🎋</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24263-%E5%A3%B0%E6%98%8Etcc%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.2.6.3.</span> <span class="toc-text">2.4.2.6.3、声明 TCC 接口：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2427-saga%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.7.</span> <span class="toc-text">2.4.2.7、Saga 模式🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2428-%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">2.4.2.8.</span> <span class="toc-text">2.4.2.8、四种模式对比🌴</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">三、高可用🎄</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">四，多级缓存🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%BC%A0%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、传统缓存的问题🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、多级缓存方案🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-jvm%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、JVM 进程缓存🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-%E5%AF%BC%E5%85%A5%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1、导入商品案例🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#432-%E5%88%9D%E5%A7%8Bcaffeine"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2、初始 Caffeine🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4321-%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">4.3.2.1、本地进程缓存🌴</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#43211-caffeine%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.3.2.1.1.</span> <span class="toc-text">4.3.2.1.1、Caffeine 示例🎋</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#433-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3、实现进程缓存🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4331-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">4.3.3.1、案例，实现商品的查询的本地进程缓存🌴</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-lua%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8"><span class="toc-number">5.</span> <span class="toc-text">五、Lua 语言入门🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%88%9D%E5%A7%8Blua"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、初始 Lua🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-helloworld"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1、HelloWorld🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2、数据类型🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3、变量🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.4.</span> <span class="toc-text">5.1.4、循环🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.5.</span> <span class="toc-text">5.1.5、函数🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">5.1.6.</span> <span class="toc-text">5.1.6、条件控制🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">六、多级缓存🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%88%9D%E5%A7%8Bopenresty"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、初始 OpenResty🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611-openresty%E5%AE%89%E8%A3%85"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1、OpenResty 安装🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#612-%E6%A1%88%E4%BE%8Bopenresty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2、案例，OpenResty 快速入门，实现商品详情页数据查询🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-openresty%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、OpenResty 获取请求参数🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E6%A1%88%E4%BE%8B%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%95%86%E5%93%81id%E4%BF%A1%E6%81%AF%E6%8B%BC%E6%8E%A5%E5%88%B0json%E7%BB%93%E6%9E%9C%E4%B8%AD%E8%BF%94%E5%9B%9E"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1、案例，获取请求路径中的商品 id 信息，拼接到 json 结果中返回🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E6%9F%A5%E8%AF%A2tomcat"><span class="toc-number">6.3.</span> <span class="toc-text">6.3、查询 Tomcat🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-%E6%A1%88%E4%BE%8B%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E5%95%86%E5%93%81id%E4%BF%A1%E6%81%AF%E6%A0%B9%E6%8D%AEid%E5%90%91tomcat%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1、案例，获取请求路径中的商品 id 信息，根据 id 向 Tomcat 查询商品信息🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6311-%E5%B0%81%E8%A3%85http%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">6.3.1.1、封装 HTTP 查询的函数🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6312-json%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">6.3.1.2、JSON 结果处理🌴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-tomcat%E9%9B%86%E7%BE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2、Tomcat 集群的负载均衡🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%B7%BB%E5%8A%A0redis%E7%BC%93%E5%AD%98%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">6.4.</span> <span class="toc-text">6.4、添加 Redis 缓存的需求🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E6%B7%BB%E5%8A%A0redis%E7%BC%93%E5%AD%98%E8%A6%81%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1、添加 Redis 缓存要面临的问题🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6411-%E5%86%B7%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">6.4.1.1、冷启动与缓存预热🌴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6412-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">6.4.1.2、缓存预热🌴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E6%9F%A5%E8%AF%A2redis%E7%BC%93%E5%AD%98"><span class="toc-number">6.5.</span> <span class="toc-text">6.5、查询 Redis 缓存🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-openresty%E7%9A%84redis%E6%A8%A1%E5%9D%97"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.5.1、OpenResty 的 Redis 模块🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-nginx%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.6.</span> <span class="toc-text">6.6、Nginx 本地缓存🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#661-%E6%A1%88%E4%BE%8B%E5%9C%A8%E6%9F%A5%E8%AF%A2%E5%95%86%E5%93%81%E6%97%B6%E4%BC%98%E5%85%88%E6%9F%A5%E8%AF%A2openresty%E7%9A%84%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6.1、案例，在查询商品时，优先查询 OPenResty 的本地缓存🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">7.</span> <span class="toc-text">七、缓存同步🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">7.1、数据同步策略🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#711-%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1、缓存同步策略🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-%E5%88%9D%E5%A7%8Bcanal"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2、初始 Canal🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-canal%E5%AE%89%E8%A3%85"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3、Canal 安装🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#714-canal%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4、Canal 客户端🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E6%80%BB%E7%BB%93%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">八、总结多级缓存架构🎄</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">9.</span> <span class="toc-text">九、服务异步通讯🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">9.1、消息可靠性问题🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#911-%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1、生产者确认机制🌲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-springamqp%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">9.2.</span> <span class="toc-text">9.2、SpringAMQP 实现生产者确认🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">9.3、消息持久化🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">9.4.</span> <span class="toc-text">9.4、消费者确认🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">9.5.</span> <span class="toc-text">9.5、失败重试机制🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#951-%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">9.5.1.</span> <span class="toc-text">9.5.1、消费者失败消息处理策略🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">10.</span> <span class="toc-text">十、死信交换机🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%88%9D%E8%AF%86%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">10.1.</span> <span class="toc-text">10.1、初识死信交换机🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-ttl"><span class="toc-number">10.2.</span> <span class="toc-text">10.2、TTL🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">10.3.</span> <span class="toc-text">10.3、延迟队列🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1031-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-number">10.3.1.</span> <span class="toc-text">10.3.1、延迟队列插件🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1032-springamqp%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-number">10.3.2.</span> <span class="toc-text">10.3.2、SpringAMQP 使用延迟队列插件🌲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">十一、惰性队列🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">11.1、消息堆积问题🌳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">11.2.</span> <span class="toc-text">11.2、惰性队列🌳</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-mq%E9%9B%86%E7%BE%A4"><span class="toc-number">12.</span> <span class="toc-text">十二、MQ 集群🎄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">12.1、集群分类🌳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1211-%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">12.1.1.</span> <span class="toc-text">12.1.1、普通集群🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12111-%E6%90%AD%E5%BB%BA%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">12.1.1.1.</span> <span class="toc-text">12.1.1.1、搭建普通集群🌴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1212-%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">12.1.2.</span> <span class="toc-text">12.1.2、镜像集群🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12121-%E6%90%AD%E5%BB%BA%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">12.1.2.1、搭建镜像集群🌴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1213-%E4%BB%B2%E8%BD%BD%E9%98%9F%E5%88%97"><span class="toc-number">12.1.3.</span> <span class="toc-text">12.1.3、仲载队列🌲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12131-%E4%BB%B2%E8%BD%BD%E9%98%9F%E5%88%97%E6%90%AD%E5%BB%BA"><span class="toc-number">12.1.3.1.</span> <span class="toc-text">12.1.3.1、仲载队列搭建🌴</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E7%BA%A7%E7%AF%87/" rel="bookmark" title="SpringCloud高级篇">SpringCloud高级篇</a></li><li><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/canal/%E5%AE%89%E8%A3%85Canal/" rel="bookmark" title="安装和配置Canal">安装和配置Canal</a></li><li><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/OpenResty/%E5%AE%89%E8%A3%85OpenResty/" rel="bookmark" title="安装OpenResty">安装OpenResty</a></li><li><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/seata/seata%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90/" rel="bookmark" title="seata的部署和集成">seata的部署和集成</a></li><li><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/" rel="bookmark" title="Sentinel规则持久化">Sentinel规则持久化</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="D" data-src="/images/avatar.jpg"><p class="name" itemprop="name">D</p><div class="description" itemprop="description">欢迎来我的博客空间</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">440</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">112</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">157</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BpZ1BpZ0xldHNHbw==" title="https:&#x2F;&#x2F;github.com&#x2F;PigPigLetsGo"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9Ea3gxMjE5" title="https:&#x2F;&#x2F;twitter.com&#x2F;Dkx1219"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS96dWktaG91LXllLWJlaS1sdWUtc2hh" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zui-hou-ye-bei-lue-sha"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTU3NjUxMDQ1OQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;576510459"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93d3cud2VpYm8uY29tL3UvNTk5OTU0OTg0MQ==" title="https:&#x2F;&#x2F;www.weibo.com&#x2F;u&#x2F;5999549841"><i class="ic i-weibo"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3Byb2ZpbGUucGhwP2lkPTEwMDA5NDA4Nzc0ODIwMQ==" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100094087748201"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xOTQwNjAyOS9kLWt4" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;19406029&#x2F;d-kx"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vQERreC12djdsbQ==" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;@Dkx-vv7lm"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9kb3Vka3g/aWdzaD1PR1E1WkRjMk9EazJaQSUzRCUzRCZ1dG1fc291cmNlPXFy" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;doudkx?igsh&#x3D;OGQ5ZDc2ODk2ZA%3D%3D&amp;utm_source&#x3D;qr"><i class="ic i-instagram"></i></span> <span class="exturl item telegram" data-url="aHR0cHM6Ly90Lm1lL2RvdTAxMDg=" title="https:&#x2F;&#x2F;t.me&#x2F;dou0108"><i class="ic i-twitter"></i></span> <span class="exturl item skype" data-url="aHR0cHM6Ly9qb2luLnNreXBlLmNvbS9UN25TSWhvbmMxcWQ=" title="https:&#x2F;&#x2F;join.skype.com&#x2F;T7nSIhonc1qd"><i class="ic i-skype"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/java/spring/springcloud/RabbitMQ/%E9%AB%98%E7%BA%A7/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/java/spring/springcloud/springcloud-%E9%AB%98%E7%BA%A7/canal/%E5%AE%89%E8%A3%85Canal/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/" title="分类于 linux">linux</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/%E5%9F%BA%E7%A1%80/" title="分类于 基础">基础</a></div><span><a href="/computer-science/linux/%E5%9F%BA%E7%A1%80/%E6%8C%87%E4%BB%A4/" title="指令">指令</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 java">java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/spring/" title="分类于 spring">spring</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/spring/springboot/" title="分类于 springboot">springboot</a></div><span><a href="/computer-science/java/spring/springboot/SpringBoot+vue%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5/" title="SpringBoot+vue前后端对接，解决跨域问题。">SpringBoot+vue前后端对接，解决跨域问题。</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/tools/" title="分类于 tools">tools</a> <i class="ic i-angle-right"></i> <a href="/categories/tools/windows/" title="分类于 windows">windows</a></div><span><a href="/tools/windows/PowerShell%E9%85%8D%E7%BD%AEohmyzsh/" title="PowerShell配置ohmyzsh">PowerShell配置ohmyzsh</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/" title="分类于 linux">linux</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/%E5%9F%BA%E7%A1%80/" title="分类于 基础">基础</a></div><span><a href="/computer-science/linux/%E5%9F%BA%E7%A1%80/%E6%89%BE%E5%9B%9Eroot%E5%AF%86%E7%A0%81/" title="找回root密码">找回root密码</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 java">java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/" title="分类于 知识点">知识点</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%AF%B9%E8%B1%A1/" title="分类于 对象">对象</a></div><span><a href="/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%AF%B9%E8%B1%A1/this%E9%80%83%E9%80%B8/" title="This引用逃逸详解">This引用逃逸详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/" title="分类于 linux">linux</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/linux/%E5%9F%BA%E7%A1%80/" title="分类于 基础">基础</a></div><span><a href="/computer-science/linux/%E5%9F%BA%E7%A1%80/%E6%9D%83%E9%99%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" title="权限的基本介绍">权限的基本介绍</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/C/" title="分类于 C">C</a></div><span><a href="/computer-science/C/C-%E4%B8%8B/" title="C语言-下">C语言-下</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 java">java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/" title="分类于 知识点">知识点</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/stream%E6%B5%81/" title="分类于 stream 流">stream 流</a></div><span><a href="/computer-science/java/%E7%9F%A5%E8%AF%86%E7%82%B9/steam%E6%B5%81/Stream%E6%B5%81%E7%9A%84%E6%80%9D%E6%83%B3%E5%92%8C%E8%8E%B7%E5%8F%96Stream%E6%B5%81/" title="Stream流的思想和获取Stream流">Stream流的思想和获取Stream流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/js/" title="分类于 js">js</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/js/%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81/" title="分类于 案例代码">案例代码</a></div><span><a href="/computer-science/web/js/%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%AE%9E%E7%8E%B0bilibili%E7%82%B9%E5%87%BB%E5%B0%8F%E6%BB%91%E5%9D%97%E7%A7%BB%E5%8A%A8%E6%95%88%E6%9E%9C/" title="实现bilibili点击小滑块移动效果">实现bilibili点击小滑块移动效果</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机学科">计算机学科</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 java">java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/maven/" title="分类于 maven">maven</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/maven/%E5%85%A5%E9%97%A8/" title="分类于 入门">入门</a></div><span><a href="/computer-science/java/maven/%E5%85%A5%E9%97%A8/maven%E6%A6%82%E8%BF%B0/" title="maven-概述">maven-概述</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">D @ D & PersonalBlog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">3.1m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">47:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/java/spring/springcloud/springcloud-高级/微服务高级篇/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="https://cdn.jsdelivr.net/gh/PigPigLetsGo/live2d-widget@latest/autoload.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>